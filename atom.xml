<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>存钱买电瓶车创业的猛男程序员</title>
  
  
  <link href="http://xuexuanfeng.github.io/atom.xml" rel="self"/>
  
  <link href="http://xuexuanfeng.github.io/"/>
  <updated>2025-07-04T15:38:03.131Z</updated>
  <id>http://xuexuanfeng.github.io/</id>
  
  <author>
    <name>xuexuanfeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双人游戏的分屏处理</title>
    <link href="http://xuexuanfeng.github.io/2025/07/04/%E5%8F%8C%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E5%B1%8F%E5%A4%84%E7%90%86/"/>
    <id>http://xuexuanfeng.github.io/2025/07/04/%E5%8F%8C%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E5%B1%8F%E5%A4%84%E7%90%86/</id>
    <published>2025-07-04T14:20:04.000Z</published>
    <updated>2025-07-04T15:38:03.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双人游戏的分屏处理"><a href="#双人游戏的分屏处理" class="headerlink" title="双人游戏的分屏处理"></a>双人游戏的分屏处理</h1><pre><code>类似于双人成行那种左右两边分屏的功能，可以使用两个摄像机，设置摄像机的viewport Rect来做。但是测下来，drawcall会成倍增加，貌似不是一个很好的解决方案。</code></pre><p><img src="/img/_20250704222449.png" alt="截图"></p><pre><code>尝试使用cinemachine,drawcall并不会减少。使用Split Screen Pro，drawcall会减少些，但是摄像机跟随在demo里面并没有很好的实现。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双人游戏的分屏处理&quot;&gt;&lt;a href=&quot;#双人游戏的分屏处理&quot; class=&quot;headerlink&quot; title=&quot;双人游戏的分屏处理&quot;&gt;&lt;/a&gt;双人游戏的分屏处理&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;类似于双人成行那种左右两边分屏的功能，可以使用两个摄像机，设置摄像机</summary>
      
    
    
    
    
    <category term="unity游戏功能开发" scheme="http://xuexuanfeng.github.io/tags/unity%E6%B8%B8%E6%88%8F%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2D游戏开发H2D技术</title>
    <link href="http://xuexuanfeng.github.io/2025/06/21/2D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91H2D%E6%8A%80%E6%9C%AF/"/>
    <id>http://xuexuanfeng.github.io/2025/06/21/2D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91H2D%E6%8A%80%E6%9C%AF/</id>
    <published>2025-06-21T03:16:53.000Z</published>
    <updated>2025-06-24T14:19:28.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><pre><code>最近有接触2D游戏初创，聊到了潜水员大夫以及八方旅人这类的2D游戏，说是用到了叫做H2D的技术，所以就稍微了解了一下，记录一下。</code></pre><ol><li>H2D核心技术构成</li></ol><ul><li>传统2D游戏使用静态精灵（Sprite），而H2D技术通过​​2D光源系统​​（如Unity URP的Freeform&#x2F;Sprite灯光）实现动态阴影、全局光照，增强场景层次感。例如，《空洞骑士》通过多层光源营造氛围。</li><li>​​后期处理效果​​（如景深、色彩校正）提升视觉表现，Unity的URP管线支持此类效果无需复杂编码。</li></ul><ol start="2"><li>骨骼动画与物理融合</li></ol><ul><li>角色动画采用​​骨骼绑定​​（如Unity的2D Animation工具），替代逐帧动画，节省资源并支持更流畅的动作。</li><li>物理引擎集成​​（如Box2D或Unity Rigidbody 2D）实现真实碰撞反馈，例如平台跳跃游戏中的角色与地面互动。</li></ul><ol start="3"><li>​​混合维度效果</li></ol><ul><li>2.5D透视​​：使用正交或倾斜投影（如等轴测视角），在2D平面模拟3D空间深度。《塞尔达传说：众神的三角量》是经典案例。</li><li>粒子系统与着色器​​：通过Shader Graph编写自定义着色器，实现水面折射、动态烟雾等效果，增强沉浸感。</li></ul><h2 id="2D场景的光照"><a href="#2D场景的光照" class="headerlink" title="2D场景的光照"></a>2D场景的光照</h2><ol><li><p>2D光照的设置</p><p> 原来2D光照需要packagemanager中install才能使用，现在已经集成在了universal rp中，Hierarcy右键Light-&gt;2D LIGHT，里面有各种2D光源。<br> 2D的默认材质是不受光照影响的，像默认渲染管线材质球转urp材质球那样，但是新版本我似乎找不到这个批量转换选项，只能选择材质球之后转换。目前看来只要是URP的项目，创建的2D对象都会使用Sprite-Lit-Default这个支持3D灯光的材质球。<br> 2D光源也支持normalmap，可以让2D物体有凹凸感，但是2D光源不支持阴影，所以需要配合3D光源使用。</p><p> 以下是批量转换脚本代码</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 文件名：TilemapMaterialConverter.cs</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">using UnityEditor;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class TilemapMaterialConverter</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(<span class="string">&quot;Tools/Batch Convert Tilemap Materials&quot;</span>)]</span><br><span class="line">    public static void <span class="function"><span class="title">ConvertMaterials</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        // 找到所有旧材质（根据您的原材质命名调整匹配规则）</span><br><span class="line">        string searchFilter = <span class="string">&quot;t:Material&quot;</span>;</span><br><span class="line">        string[] materialPaths = AssetDatabase.FindAssets(searchFilter);</span><br><span class="line"></span><br><span class="line">        int convertedCount = 0;</span><br><span class="line">        Shader targetShader = Shader.Find(<span class="string">&quot;Universal Render Pipeline/2D/Sprite-Lit-Default&quot;</span>);</span><br><span class="line"></span><br><span class="line">        foreach (string guid <span class="keyword">in</span> materialPaths)</span><br><span class="line">        &#123;</span><br><span class="line">            string path = AssetDatabase.GUIDToAssetPath(guid);</span><br><span class="line">            Material mat = AssetDatabase.LoadAssetAtPath&lt;Material&gt;(path);</span><br><span class="line"></span><br><span class="line">            // 仅转换特定条件的材质（调整过滤逻辑）</span><br><span class="line">            <span class="keyword">if</span> (mat.shader.name.Contains(<span class="string">&quot;Sprites/Default&quot;</span>) || </span><br><span class="line">                mat.shader.name.Contains(<span class="string">&quot;Sprites/Diffuse&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                mat.shader = targetShader;</span><br><span class="line">                EditorUtility.SetDirty(mat);</span><br><span class="line">                convertedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AssetDatabase.SaveAssets();</span><br><span class="line">        Debug.Log($<span class="string">&quot;转换完成！共转换了&#123;convertedCount&#125;个材质&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p><img src="/img/2DLIGHT_EXAMPLE.png" alt="截图"></p><ol start="2"><li>2D光源的性能</li></ol><ul><li>每个 ​​动态光源​​（如 Point Light 2D）会产生 ​​独立的光照贴图​</li><li>最终叠加到场景需进行 ​​Alpha 混合​​，消耗 GPU 带宽</li><li>典型场景：10 个动态光源 &#x3D; 10 次光照纹理绘制 + 1 次主场景绘制</li><li>每个激活的 ​​Light 2D​​ 会遍历其 ​​光照范围内的所有 Renderer​，物体数量越多，CPU 侧计算耗时越高</li></ul><ol start="3"><li>优化策略</li></ol><ul><li>减少动态光源数量​</li><li>使用烘焙光照​(虽然AI给出了烘培的方案，但是我并没有网上查到烘培相关的教程)</li><li>​​合并光源范围​<ol><li>多个相邻光源 → 替换为 ​​1 个覆盖更大区域的点光源​</li><li>或使用 ​​Sprite Mask + 单一光源​​ 模拟局部光照</li></ol></li><li>​​优化光源属性​<ol><li>启用 ​​Light Volume Intensity​​：近亮远暗，降低边缘计算</li><li>关闭不必要光源的 ​​Use Normal Maps​​（如背景光）</li></ol></li><li>材质层级优化​<ol><li>非交互背景​​：使用无光照材质（Sprite&#x2F;Unlit-Default）</li><li>​​动态物体​​：批量使用相同光照材质（减少 Shader 切换）</li></ol></li><li>移除或者禁用远处的额光源</li></ul><h2 id="2D-Animation工具"><a href="#2D-Animation工具" class="headerlink" title="2D Animation工具"></a>2D Animation工具</h2><pre><code>跟着教程跑了一边，大致了解一下，主要是PS源素材进行分层，保存PSB文件。导入unity中，素材图标会类似于FBX，而inspector面板是类似图片的选项，点击openSpriteEditor,打开如下面板</code></pre><p><img src="/img/2DANIMATION_EXAMPLE2.png" alt="截图"></p><pre><code>点击左上角切换skinning Editor，之后的流程就和blender差不多，就是创建骨骼，生成蒙皮，刷上权重，随后图片的顶点坐标就会随着骨骼的偏移而进行移动。完成2D骨骼的处理之后就可以添加animator，录制动画了。因为spine没有怎么用过，不好评论2D Animator和Spine哪个比较好用点，但是B站上有博主对比过，大致的意思就是spine的工作流比起unity来更加人性化、易操作。但是在我看来2D Animaton也是可以用的，避免了spine的学习投入成本。但是2D Animaton我并没有找到换装相关的功能，unity还有一个插件叫Character Creator 2D，可以用来制作2D角色动画以及支持换装。PS:2D Animation可以使用sprite library组件实现换装。换装教程https://www.bilibili.com/video/BV1ht4y177Ev/?spm_id_from=333.1391.0.0&amp;vd_source=757af868ca167689ee49a2bde553ef7f</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习记录&quot;&gt;&lt;a href=&quot;#学习记录&quot; class=&quot;headerlink&quot; title=&quot;学习记录&quot;&gt;&lt;/a&gt;学习记录&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;最近有接触2D游戏初创，聊到了潜水员大夫以及八方旅人这类的2D游戏，说是用到了叫做H2D的技术，所以就稍微了</summary>
      
    
    
    
    
    <category term="学习记录" scheme="http://xuexuanfeng.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>微信小游戏的转换遇到的一些问题</title>
    <link href="http://xuexuanfeng.github.io/2025/05/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://xuexuanfeng.github.io/2025/05/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2025-05-16T16:27:16.000Z</published>
    <updated>2025-05-16T16:39:20.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小游戏的转换遇到的一些问题"><a href="#微信小游戏的转换遇到的一些问题" class="headerlink" title="微信小游戏的转换遇到的一些问题"></a>微信小游戏的转换遇到的一些问题</h1><ol><li>抖音小游戏转换之后onApplicationPause不生效，需要改为抖音sdk提供的接口</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StarkSDK.API.GetStarkAppLifeCycle().OnHide += OnHideFun;</span><br><span class="line">StarkSDK.API.GetStarkAppLifeCycle().OnShowWithDict += OnShowWithDictFun;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>抖音小游戏PlayerPrefs获取本地缓存，当StarkFileSystemManager.IsDataMigrated()为false的时候重启应用之后会不生效，主要原因是抖音sdk过老，可以写死StarkFileSystemManager.IsDataMigrated为true或者直接调用StarkStorage接口，当然这也是有问题的，比如切换账号之后本地缓存也会丢失，最终方案是使用抖音自带的文件系统。</p></li><li><p>抖音侧边栏是必接入项</p></li><li><p>抖音小游戏没有内购的情况下可以不用接入客服</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小游戏的转换遇到的一些问题&quot;&gt;&lt;a href=&quot;#微信小游戏的转换遇到的一些问题&quot; class=&quot;headerlink&quot; title=&quot;微信小游戏的转换遇到的一些问题&quot;&gt;&lt;/a&gt;微信小游戏的转换遇到的一些问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;抖音小游戏转换之后onA</summary>
      
    
    
    
    
    <category term="Unity微信小游戏" scheme="http://xuexuanfeng.github.io/tags/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Unity资源网站</title>
    <link href="http://xuexuanfeng.github.io/2025/05/13/Unity%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/"/>
    <id>http://xuexuanfeng.github.io/2025/05/13/Unity%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/</id>
    <published>2025-05-13T14:28:45.000Z</published>
    <updated>2025-05-13T14:32:53.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity资源网站"><a href="#Unity资源网站" class="headerlink" title="Unity资源网站"></a>Unity资源网站</h1><h1 id="2DTilemap相关素材"><a href="#2DTilemap相关素材" class="headerlink" title="2DTilemap相关素材"></a>2DTilemap相关素材</h1><p><a href="https://itch.io/">https://itch.io/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity资源网站&quot;&gt;&lt;a href=&quot;#Unity资源网站&quot; class=&quot;headerlink&quot; title=&quot;Unity资源网站&quot;&gt;&lt;/a&gt;Unity资源网站&lt;/h1&gt;&lt;h1 id=&quot;2DTilemap相关素材&quot;&gt;&lt;a href=&quot;#2DTilemap相关素</summary>
      
    
    
    
    
    <category term="unity资源相关" scheme="http://xuexuanfeng.github.io/tags/unity%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>unity的插值计算</title>
    <link href="http://xuexuanfeng.github.io/2025/05/08/unity%E7%9A%84%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <id>http://xuexuanfeng.github.io/2025/05/08/unity%E7%9A%84%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97/</id>
    <published>2025-05-08T08:05:02.000Z</published>
    <updated>2025-05-08T08:19:20.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="unity的插值计算"><a href="#unity的插值计算" class="headerlink" title="unity的插值计算"></a>unity的插值计算</h1><h2 id="Mathf的插值运算API"><a href="#Mathf的插值运算API" class="headerlink" title="Mathf的插值运算API"></a>Mathf的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个浮点数之间的插值运算。</li><li>API：Mathf.Lerp(float a, float b, float t)</li><li>参数：a为起始值，b为结束值，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的插值结果。</li></ul></li></ul><p><img src="/img/202505081609.png" alt="截图"></p><p><img src="/img/MathfLerp.gif" alt="截图"></p><h2 id="Vector3的插值运算API"><a href="#Vector3的插值运算API" class="headerlink" title="Vector3的插值运算API"></a>Vector3的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个三维向量之间的线性插值运算。</li><li>API：Vector3.Lerp(Vector3 a, Vector3 b, float t)</li><li>参数：a为起始向量，b为结束向量，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的线性插值向量。</li><li>应用场景：常用于物体的位置移动、方向变化等线性过渡效果。</li></ul></li></ul><p><img src="/img/202505081613.png" alt="截图"></p><p><img src="/img/Vector3Lerp.gif" alt="截图"></p><p>Slerp方法：</p><ul><li>功能：实现两个三维向量之间的球形插值运算，即沿球面的大圆弧进行插值。<ul><li>API：Vector3.Slerp(Vector3 a, Vector3 b, float t)</li><li>参数：a为起始向量，b为结束向量，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的球形插值向量。</li><li>应用场景：常用于物体的平滑旋转、摄像机朝向变化等需要保持恒定角速度的插值效果。</li><li>相比线性插值Lerp将Vector3当作空间的点，球形插值Slerp则是将Vector3当作方向，返回的Vector3的长度是两点之前的距离插值，方向是两个向量之间的夹角度数的插值。游戏中主要的应用场景有角色或物体的曲线跳跃,武器或抛射物的弧形弹道。</li></ul></li></ul><p><img src="/img/202505081614.png" alt="截图"></p><p><img src="/img/Vector3SLerp.gif" alt="截图"></p><h2 id="Quaternion的插值运算API"><a href="#Quaternion的插值运算API" class="headerlink" title="Quaternion的插值运算API"></a>Quaternion的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个四元数之间的线性插值运算，用于旋转的线性过渡。</li><li>API及参数：与Vector3.Lerp类似，但操作对象为四元数。</li><li>返回值：根据插值因子返回两个四元数之间的线性插值结果。</li><li>应用场景：虽然可以用于旋转插值，但可能产生“万向节锁”问题，因此不如Slerp常用。</li></ul></li><li><p>Slerp方法：</p><ul><li>功能：实现两个四元数之间的球形插值运算，用于旋转的平滑过渡。</li><li>API：Quaternion.Slerp(Quaternion a, Quaternion b, float t)</li><li>参数：a为起始四元数，b为结束四元数，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的球形插值四元数。</li><li>应用场景：相机的平滑跟随与视角切换，角色的平滑转向，动画中的关节旋转过渡，UI 元素的动态旋转效果等等</li></ul></li></ul><p>Quaternion的插值分析及总结<br>Lerp求得的是四元数在圆上的弦上的等分，而Slerp求得的是四元数载圆上的圆弧的等分</p><p><img src="/img/202505081617.png" alt="截图"></p><p>从这张图可以看出lerp的运动轨迹是开始和结束慢，中间又比较快</p><p><img src="/img/202505081618.png" alt="截图"></p><p><img src="/img/QuaternionSlerp.gif" alt="截图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;unity的插值计算&quot;&gt;&lt;a href=&quot;#unity的插值计算&quot; class=&quot;headerlink&quot; title=&quot;unity的插值计算&quot;&gt;&lt;/a&gt;unity的插值计算&lt;/h1&gt;&lt;h2 id=&quot;Mathf的插值运算API&quot;&gt;&lt;a href=&quot;#Mathf的插值</summary>
      
    
    
    
    
    <category term="学习记录" scheme="http://xuexuanfeng.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Addressables小游戏改造</title>
    <link href="http://xuexuanfeng.github.io/2025/05/08/Addressables%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%94%B9%E9%80%A0/"/>
    <id>http://xuexuanfeng.github.io/2025/05/08/Addressables%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%94%B9%E9%80%A0/</id>
    <published>2025-05-08T02:14:00.000Z</published>
    <updated>2025-05-08T02:49:50.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Addressables小游戏改造"><a href="#Addressables小游戏改造" class="headerlink" title="Addressables小游戏改造"></a>Addressables小游戏改造</h1><ol><li><p>安装addressables的package</p></li><li><p>打开Addressables Groups，这里遇到几个问题，我发现直接把Resource目录的Addressable勾上，他Resource目录中的资源并不会移出包体</p></li></ol><p><img src="/img/202405081038.png" alt="截图"></p><p><img src="/img/202405081038_1.png" alt="截图"></p><p>&emsp;&emsp;只有当勾选resource内部的时候才会有移出资源的提示，所以不能直接偷懒这么做。</p><ol start="3"><li>导出路径可以选择Remote</li></ol><p><img src="/img/202505081041.png" alt="截图"></p><p>&emsp;&emsp;打开Manage Profiles修改LoadPath路径</p><p><img src="/img/202505081042.png" alt="截图"></p><ol start="4"><li>打包的时候如果Bundle Mode选择Pack Together的话单个Group的资源会打成一个bundle，这样会产生一些无用资源的加载浪费，所以我的解决办法是一个类型文件一个Group，然后Bundle Mode选择Pack Separately，这样一个文件打成一个bundle。个人测下来Pack Separately的打包逻辑是当前目录下的所有子对象都自成一个bundle，并不是目录下的所有资源都打成单独的bundle，比方说目录A勾选addressables,然后目录A里面又有目录B,C,D，打包的资源在第三层目录结构下，如果这时候build，他会生成三个bundle，分别代表目录B,C,D。所以正确的做法是目录B,C,D勾选为addressables，而不是勾选目录A。</li></ol><p><img src="/img/202505081043.png" alt="截图"></p><ol start="5"><li>加载资源使用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;GameObject&gt; handle = Addressables.LoadAssetAsync&lt;GameObject&gt;(<span class="string">&quot;Name&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>加载场景使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;SceneInstance&gt; sceneHandle = Addressables.LoadSceneAsync(<span class="string">&quot;Assets/Scenes/Level1.unity&quot;</span>, LoadSceneMode.Additive);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还可以通过SceneInstance控制场景的激活和加载进度</p><p><img src="/img/202505081045.png" alt="截图"></p><ol start="6"><li>最后就是将同步加载结构改为异步加载API的枯燥过程了</li></ol><p>PS：这里有几点需要注意，刚开始从together切换成Pack Separately后打出来的包还是一整个，清理下缓存恢复正常，建议每次build之前都清理一下。</p><p><img src="/img/202505081046.png" alt="截图"></p><p>PS: 使用服务器下载bundle的方式测试会报错</p><p><img src="/img/202505081047.png" alt="截图"></p><p>经检查服务器地址和端口都没有问题，但是断点进去看了之后发现最终的请求地址端口为字符串HostingServicePort。Clear和Update之后能够正常访问。</p><p><img src="/img/202505081047_1.png" alt="截图"></p><p><img src="/img/202505081048_1.png" alt="截图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Addressables小游戏改造&quot;&gt;&lt;a href=&quot;#Addressables小游戏改造&quot; class=&quot;headerlink&quot; title=&quot;Addressables小游戏改造&quot;&gt;&lt;/a&gt;Addressables小游戏改造&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安</summary>
      
    
    
    
    
    <category term="Unity微信小游戏" scheme="http://xuexuanfeng.github.io/tags/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>worldstreamer的Terrain分割原理</title>
    <link href="http://xuexuanfeng.github.io/2025/04/24/worldstreamer%E7%9A%84Terrain%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86/"/>
    <id>http://xuexuanfeng.github.io/2025/04/24/worldstreamer%E7%9A%84Terrain%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86/</id>
    <published>2025-04-24T14:43:26.000Z</published>
    <updated>2025-04-24T15:09:25.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="worldstreamer的Terrain分割原理"><a href="#worldstreamer的Terrain分割原理" class="headerlink" title="worldstreamer的Terrain分割原理"></a>worldstreamer的Terrain分割原理</h1><p>SplitTerrain 函数的逻辑主要是将选定的地形（Terrain）进行分割，并将每个分割后的地形保存为独立的地形对象。以下是该函数的主要步骤和逻辑：</p><ol><li><p>创建目录：首先检查是否存在用于存储分割地形的目录，如果不存在则创建该目录。</p></li><li><p><strong>开始撤销组</strong>：使用 <code>Undo.SetCurrentGroupName</code> 开始一个撤销操作组，以便在用户需要撤销操作时能够恢复到之前的状态。</p></li><li><p><strong>设置分割数量</strong>：根据 <code>splitSize</code> 属性计算出将要创建的地形数量。</p></li><li><p><strong>获取选定的地形</strong>：根据用户的选择获取当前选定的地形，如果 <code>allTerrains</code> 为真，则获取所有活动的地形。</p></li><li><p><strong>遍历每个地形</strong>：对于每个选定的地形，执行以下操作：</p><ul><li><p><strong>创建新地形</strong>：根据分割数量创建新的地形数据和地形对象(Terrain.CreateTerrainGameObject这个接口可以想创建Gameobject一样直接在场景上面放一个terrain)。</p></li><li><p><strong>复制地形原型</strong>：将原始地形的所有原型（如树木、细节等）复制到新地形中。</p></li><li><p><strong>设置地形属性</strong>：调用 <code>SetTerrainSettings</code> 函数来设置新地形的各种属性。</p></li><li><p><strong>分割高度图</strong>：根据分割的大小，从原始地形的高度图中提取相应的部分并设置到新地形中。</p></li><li><p><strong>分割孔数据</strong>：同样处理地形的孔数据（如空洞）。</p></li><li><p><strong>分割纹理数据</strong>：处理地形的纹理数据，将其分割并设置到新地形中。</p></li><li><p><strong>分割细节数据</strong>：处理地形的细节数据（如草、灌木等），将其分割并设置到新地形中。</p></li><li><p><strong>处理树木实例</strong>：遍历原始地形的树木实例，将其位置调整并添加到新地形中。</p></li><li><p><strong>设置新地形的位置</strong>：根据原始地形的位置调整新地形的位置。</p></li></ul></li><li><p><strong>结束撤销组</strong>：在所有操作完成后，结束撤销操作组。</p></li><li><p><strong>清理进度条</strong>：在操作完成后，清理进度条。</p></li></ol><p>通过这些步骤，<code>SplitTerrain</code> 函数能够将一个大的地形分割成多个小的地形，便于管理和使用。每个新地形都保留了原始地形的特性和数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;worldstreamer的Terrain分割原理&quot;&gt;&lt;a href=&quot;#worldstreamer的Terrain分割原理&quot; class=&quot;headerlink&quot; title=&quot;worldstreamer的Terrain分割原理&quot;&gt;&lt;/a&gt;worldstream</summary>
      
    
    
    
    
    <category term="worldstreamer的Terrain分割原理" scheme="http://xuexuanfeng.github.io/tags/worldstreamer%E7%9A%84Terrain%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>unity中Sprite和Image的区别</title>
    <link href="http://xuexuanfeng.github.io/2025/04/23/unity%E4%B8%ADSprite%E5%92%8CImage%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://xuexuanfeng.github.io/2025/04/23/unity%E4%B8%ADSprite%E5%92%8CImage%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-04-23T09:34:10.000Z</published>
    <updated>2025-04-23T09:42:47.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="unity中Sprite和Image的区别"><a href="#unity中Sprite和Image的区别" class="headerlink" title="unity中Sprite和Image的区别"></a>unity中Sprite和Image的区别</h1><ol><li><p>渲染上</p><ul><li>Image 通过UGUI的Image和CanvasRenderer组件组件来渲染；</li><li>Sprite 通过SpriteRenderer组件来渲染；</li><li>两者在视觉上没有任何区别（都使用默认材质时）。它们默认的渲染也都是在Transparent Geometry队列中。</li></ul></li><li><p>原理上：</p><ul><li>GPU接收到DrawCall指令后，通过一系列流程生成最终要显示的内容并进行渲染，其中大致的步骤包括：<ul><li>CPU发送Draw Call指令给GPU；</li><li>GPU读取必要的数据到自己的显存；</li><li>GPU通过顶点着色器（vertex shader）等步骤将输入的几何体信息转化为像素点数据；</li><li>每个像素都通过片段着色器（fragment shader）处理后写入帧缓存(显存)；</li><li>当全部计算完成后，GPU将帧缓存内容显示在屏幕上。</li></ul></li><li>通过上面的认知，我们可以推断：<ul><li>Sprite由于顶点数据更加复杂，进行顶点计算时在第1、2步会比Image效率更低；</li><li>Sprite会比Image执行较多的顶点着色器运算；</li><li>Image会比Sprite执行更多的片段着色器运算；</li></ul></li></ul></li><li><p>使用上：</p><ul><li>Hierarchy窗口,可以把sprite随便放在哪，通过Transform移动其它游戏物体那样移动sprite； Image必须放在Canvas下面, 且只能通过RectTransform在UI界面中移动；</li><li>sprite和Image的一个最重要的区别在于sprite支持网格的自动构造，而UI Image的网格始终由矩形构成;SpriteRenderer会创建额外的几何体来裁剪掉多余的透明像素区域，从而减少了大量的片段着色器运算，并降低了overdraw。SpriteRenderer确实是经过优化以显示更多的元素的。所以在2D游戏开发中，游戏场景中的元素，应该尽量使用它去渲染，尤其时复杂的几何图像；</li><li>Image仅用于UI显示；</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;unity中Sprite和Image的区别&quot;&gt;&lt;a href=&quot;#unity中Sprite和Image的区别&quot; class=&quot;headerlink&quot; title=&quot;unity中Sprite和Image的区别&quot;&gt;&lt;/a&gt;unity中Sprite和Image的区别&lt;/</summary>
      
    
    
    
    
    <category term="unity优化" scheme="http://xuexuanfeng.github.io/tags/unity%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>设计模式的应用场景</title>
    <link href="http://xuexuanfeng.github.io/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://xuexuanfeng.github.io/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2025-04-18T03:17:58.000Z</published>
    <updated>2025-04-18T03:58:14.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、创建型模式（封装对象的创建）"><a href="#一、创建型模式（封装对象的创建）" class="headerlink" title="一、创建型模式（封装对象的创建）"></a>一、创建型模式（封装对象的创建）</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>需要全局唯一实例（如日志管理器、配置中心、数据库连接池）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singleton </span><br><span class="line">&#123; </span><br><span class="line">    private static Singleton _instance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>创建对象时需依赖子类决定具体类型（如不同数据库驱动、UI 控件的动态生成）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Creator </span><br><span class="line">&#123; </span><br><span class="line">    public abstract IProduct FactoryMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>创建一组相关或依赖的对象（如跨平台 UI 组件库：Windows&#x2F;Mac 的按钮、文本框）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IGUIFactory </span><br><span class="line">&#123; </span><br><span class="line">    IButton CreateButton(); </span><br><span class="line">    ITextBox CreateTextBox(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>分步骤构建复杂对象（如生成 XML&#x2F;JSON 文档、配置 HTTP 请求头）。</p><p>StringBuilder 类的链式调用</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>通过克隆已有对象创建新对象，避免重复初始化（如游戏中的敌人复制、配置模板）。</p><p>实现 ICloneable 接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public object <span class="function"><span class="title">Clone</span></span>() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">return</span> MemberwiseClone(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、结构型模式（处理对象间的组合关系）"><a href="#二、结构型模式（处理对象间的组合关系）" class="headerlink" title="二、结构型模式（处理对象间的组合关系）"></a>二、结构型模式（处理对象间的组合关系）</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将不兼容接口转换为客户端期望的接口（如旧系统接口适配新框架）。</p><p>包装第三方库的类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LegacyAdapter : INewInterface </span><br><span class="line">&#123; </span><br><span class="line">    private Legacy _legacy; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>分离抽象与实现，支持多维变化（如不同图形渲染API：OpenGL&#x2F;DirectX）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Shape</span><br><span class="line">&#123; </span><br><span class="line">    protected IRenderer _renderer; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>处理树形结构（如文件系统、UI 控件嵌套）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IComponent </span><br><span class="line">&#123; </span><br><span class="line">    void Add(IComponent component); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>动态添加功能（如日志记录、缓存、权限校验的链式扩展）</p><p>Stream 类的装饰器：BufferedStream, CryptoStream</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>简化复杂子系统调用（如封装支付流程：验证、扣款、通知）。</p><p>提供统一入口类：PaymentFacade.ProcessPayment(order)。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>共享大量细粒度对象（如字符格式复用、游戏中的粒子系统）。</p><p>String.Intern() 方法复用字符串常量</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>控制对象访问（如延迟加载、远程调用、权限验证）。</p><p>Lazy<T> 类实现延迟加载，WCF 的客户端代理。</p><h1 id="三、行为型模式（管理对象间的交互）"><a href="#三、行为型模式（管理对象间的交互）" class="headerlink" title="三、行为型模式（管理对象间的交互）"></a>三、行为型模式（管理对象间的交互）</h1><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>多个对象依次处理请求（如审批流程、异常处理过滤器）。</p><p>ASP.NET Core 中间件管道：app.UseMiddleware<LoggingMiddleware>()。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>封装请求为对象（如撤销&#x2F;重做操作、任务队列）。</p><p>WPF 的 ICommand 接口：RelayCommand。</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>定义语法规则并解释执行（如正则表达式、SQL解析）。</p><p>正则表达式引擎 System.Text.RegularExpressions</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>遍历集合元素（如自定义集合的遍历逻辑）。</p><p>实现 IEnumerable<T> 和 IEnumerator<T> 接口。</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>减少对象间直接耦合（如聊天室消息转发、UI控件交互）。</p><p>使用 MediatR 库实现事件调度。</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>保存和恢复对象状态（如游戏存档、事务回滚）。</p><p>序列化对象到文件或数据库。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>一对多依赖通知（如事件发布-订阅、数据绑定）。</p><p>C# 的 event 关键字和 IObservable<T>&#x2F;IObserver<T> 接口。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>对象行为随状态改变（如订单状态流转、游戏角色行为切换）。</p><p>定义状态接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState </span><br><span class="line">&#123; </span><br><span class="line">    void Handle(Context context); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>动态切换算法（如排序算法选择、支付方式切换）。</p><p>依赖注入中的不同服务实现：services.AddScoped&lt;IPaymentStrategy, AlipayStrategy&gt;()。</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>定义算法骨架，子类实现步骤（如工作流引擎、数据导入流程）</p><p>抽象类定义流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class DataImporter </span><br><span class="line">&#123; </span><br><span class="line">    public void <span class="function"><span class="title">Import</span></span>() </span><br><span class="line">    &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>分离数据结构与操作（如AST树解析、报表生成）。</p><p>实现 IVisitor 接口遍历复杂对象结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、创建型模式（封装对象的创建）&quot;&gt;&lt;a href=&quot;#一、创建型模式（封装对象的创建）&quot; class=&quot;headerlink&quot; title=&quot;一、创建型模式（封装对象的创建）&quot;&gt;&lt;/a&gt;一、创建型模式（封装对象的创建）&lt;/h1&gt;&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="架构设计" scheme="http://xuexuanfeng.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Unity场景物体贴地操作</title>
    <link href="http://xuexuanfeng.github.io/2025/03/19/Unity%E5%9C%BA%E6%99%AF%E7%89%A9%E4%BD%93%E8%B4%B4%E5%9C%B0%E6%93%8D%E4%BD%9C/"/>
    <id>http://xuexuanfeng.github.io/2025/03/19/Unity%E5%9C%BA%E6%99%AF%E7%89%A9%E4%BD%93%E8%B4%B4%E5%9C%B0%E6%93%8D%E4%BD%9C/</id>
    <published>2025-03-19T07:50:24.000Z</published>
    <updated>2025-03-19T07:54:26.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity场景物体贴地操作"><a href="#Unity场景物体贴地操作" class="headerlink" title="Unity场景物体贴地操作"></a>Unity场景物体贴地操作</h1><p>以前会专门为底边开发一个物体贴地的工具，但unity其实编辑器内原生自带了这个功能，选中物体按下Ctrl+Shift,场景物体中间会出现一个灰色的小方框，拖动物体编辑器就会自动处理贴地的效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity场景物体贴地操作&quot;&gt;&lt;a href=&quot;#Unity场景物体贴地操作&quot; class=&quot;headerlink&quot; title=&quot;Unity场景物体贴地操作&quot;&gt;&lt;/a&gt;Unity场景物体贴地操作&lt;/h1&gt;&lt;p&gt;以前会专门为底边开发一个物体贴地的工具，但unity</summary>
      
    
    
    
    
    <category term="UnityEditor小技巧" scheme="http://xuexuanfeng.github.io/tags/UnityEditor%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>微信小游戏反编译</title>
    <link href="http://xuexuanfeng.github.io/2025/03/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://xuexuanfeng.github.io/2025/03/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%8F%8D%E7%BC%96%E8%AF%91/</id>
    <published>2025-03-17T13:58:36.000Z</published>
    <updated>2025-03-17T15:19:31.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小游戏反编译"><a href="#微信小游戏反编译" class="headerlink" title="微信小游戏反编译"></a>微信小游戏反编译</h1><p><a href="https://www.cnblogs.com/thebeastofwar/p/17611201.html">参考文献</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>注册开发者工具+申请小游戏类目</li></ol><p>不能用微信开发者工具自带的测试者账号，有一些小程序需要调用你的token</p><p><a href="https://developers.weixin.qq.com/">https://developers.weixin.qq.com/</a></p><ol start="2"><li>安装并下载反编译软件</li></ol><p><a href="https://www.cnblogs.com/thebeastofwar/p/17611201.html">https://www.cnblogs.com/thebeastofwar/p/17611201.html</a></p><ol><li><p>wxappUnpacker-master</p><p> <a href="../../file/wxappUnpacker-master.zip">下载文件</a></p></li><li><p>UnpackMiniApp</p><p> <a href="../../file/UnpackMiniApp.zip">下载文件</a></p></li></ol><h1 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h1><ol><li>反编译小游戏</li></ol><p>在windows上的微信中打开并加载小游戏</p><p>找到小游戏的下载目录WeChatFiles\Applet,有两个包</p><p>找到游戏主包(unity转换的游戏包含_WITHOUT_MULTI_PLUGINCODE_.wxapkg),另一个自爆里面包含的是插件包，不用管</p><p>不要移动这几个包的位置，直接双击运行UnpackMiniApp.exe,选择加密小程序包</p><p>选择一个包(每次选择一个)</p><p>解密成功后，报的位置位于UnpackMiniApp.exe统计目录的wxpack目录下，由于每次解密后的包名相同，需要给解密后的包重命名，以防被覆盖</p><p>在依次解密_wasmcode_.wxapkg和_wasmcode1_.wxapkg这两个包,都重命名，得到如下三个解密的包</p><p>在使用wxappUnpacker-master这个工具，主要用到的是wuWxapkg.jg这个解包脚本和wuJs.js这个分包脚本</p><p>安装node.js，运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node .\wuWxapkg.js E:\tools\wxpack\main.wxapkg <span class="comment"># 加入路径</span></span><br></pre></td></tr></table></figure><p>解压成功</p><p>在依次解压pkg1.wxapkg和pkg2.wxapkg,得到两个文件夹</p><ol start="2"><li>导入小游戏</li></ol><ul><li><p>打开微信开发者工具-&gt;微信小游戏-&gt;import</p></li><li><p>选择项目路径-&gt;设置提前申请好的小游戏类目appid</p></li><li><p>点击create</p></li></ul><ol start="3"><li>项目设置(本地设置Local setting)</li></ol><p>首先检查微信开发者工具的相关设置</p><ul><li>确保这几项设置正确勾选(新人并运行，将JS编译成ES5,不校验合法域名)</li></ul><ol start="4"><li>Subpackages添加和配置删除</li></ol><p>根据主目录game.json中的subpackages配置，添加我们反编译的子包,并删除不存在的子包配置</p><ol start="5"><li>引擎配置问题</li></ol><p>详情查看<a href="#question3">常见问题3</a></p><p>修改game.json中的gamePlugins-&gt;plugins</p><ol start="6"><li>报错:VM2_INTERNAL_STATE_DONOT_USE_OR_PROGRAM_WILL_FAIL</li></ol><p>VM2_INTERNAL_STATE_DONOT_USE_OR_PROGRAM_WILL_FAIL undefined</p><p>在game.js中添加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL = &#123;</span><br><span class="line">  handleException: (e) =&gt; &#123;</span><br><span class="line">    console.warn(e);</span><br><span class="line">    <span class="built_in">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="7"><li>删除game.js报错(常出现在subpackages中)</li></ol><p>可能会有显示(console)和隐式(非debug模式下无法运行但没有log)的错误，导致微信开发者工具内无法显示游戏页面，通常需要对main包之外的包中game.js进行如下define和require的处理:</p><p><img src="/img/fa37821da338f520c2579457435214b.jpg" alt="图标"></p><p>例如在这个额外导入的wasmcode1包中，需要将外层注释。</p><p>建议对所有包进行预处理，避免host中可能的require错误（尽管此错误不会影响游戏运行）</p><ol start="8"><li>Mock Login</li></ol><p>详情查看<a href="#loginpipline">微信登陆服务模拟搭建流程</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><h2 id="question3">常见问题</h2></h2><ol><li>PARAMOUNT</li></ol><p>首先检查微信开发者工具的相关设置</p><ul><li>确保这几项设置正确勾选（信任并运行，将JS编译成ES5，不校验合法域名）</li></ul><ol start="2"><li>*&#x2F;game.js预处理</li></ol><p>可能会有显示(console)和隐式(非debug模式下无法运行但没有log)的错误，导致微信开发者工具内无法显示游戏页面，通常需要对main包之外的包中game.js进行如下define和require的处理:</p><p><img src="/img/fa37821da338f520c2579457435214b.jpg" alt="图标"></p><p>例如在这个额外导入的wasmcode1包中，需要将外层注释。</p><p>建议对所有包进行预处理，避免host中可能的require错误（尽管此错误不会影响游戏运行）</p><ol start="3"><li>引擎引用问题</li></ol><p>修改game.json中的gamePlugins-&gt;plugins</p><h3 id="UnityPlugin问题"><a href="#UnityPlugin问题" class="headerlink" title="UnityPlugin问题"></a>UnityPlugin问题</h3><p>在unity引擎的游戏中，需要通过微信账号导入能力地图-开发提效包-快适配，并将game.json中的gamePlugins改为plugins。一般情况下,游戏可以正常运行。</p><p>如果遇到无法运行的情况，可以留意plugins下UnityPlugin的版本。</p><p>实测1.2.38会遇到微信开发这工具中无法正确获取插件的情况。可以在此处将版本更新后在启动游戏。</p><p>建议将版本更新到1.2.54,与unity-wx-to-webgl-host转换包中的版本相对应。</p><h3 id="cocos的requirePlugin"><a href="#cocos的requirePlugin" class="headerlink" title="cocos的requirePlugin"></a>cocos的requirePlugin</h3><p>有游戏会将Cocos作为gamePlugin卸载game.json中，main&#x2F;app目录下的cocos目录里缺少cocos2d-js-min.js文件。此时游戏不会正常加载，亦不会有明显报错。需要做出一下改动：</p><ul><li><p>删除game.json下的cocos plugin定义</p></li><li><p>从网上或过往的项目里扒一个对应版本的cocos2d-js-min.js,黏贴到cocos目录下</p></li><li><p>修改game.js的</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirePlugin(<span class="string">&quot;cocos&quot;</span>);</span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">&quot;cocos/cocos2d-js-min.js&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Laya引擎处理方式"><a href="#Laya引擎处理方式" class="headerlink" title="Laya引擎处理方式"></a>Laya引擎处理方式</h3><p>同上</p><ol start="4"><li>快速hook login</li></ol><p>在game.js中添加如下代码，将url替换成本游戏的登陆密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var orgR = wx.request;</span><br><span class="line">wx.request = (obj) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.url.indexOf(<span class="string">&#x27;weixingamelogin.php?jscode=&#x27;</span>) &gt; -1) &#123;</span><br><span class="line">        debugger</span><br><span class="line">        console.log(<span class="string">&quot;获得的obj为:&quot;</span>, obj);</span><br><span class="line">        obj.url = <span class="string">&#x27;https://bd11-rel.52playgame.com&#x27;</span> + </span><br><span class="line">        <span class="string">&#x27;/gmsys/weblogic/webc/weixingamelogin.php?jscode=0e3FP5ll2xbd7e4xLPkl25sgD40FP5l1&amp;group=1&amp;systematic=3&amp;encrypteddata=undefined&amp;iv=undefined&amp;os=Windows%2011%20x64&amp;model=microsoft&amp;toutiao_cluetoken=&amp;toutiao_create_id=&amp;toutiao_ad_id=&amp;guangdiantong_minigamechannel=&amp;guangdiantong_clickid=&amp;weixinadinfo=&amp;xingtu_callback=&amp;chuanshanjia_cluetoken=&amp;baidu_bd_vid=&amp;baidu_ext_info=&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> orgR(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>加解密</li></ol><p>遇到类似  “sign1”:”OTAyMTY1M3d4NjEzMjEyZTNkNDk3ZWVkOTE3MjcyNTAxMTE&#x3D;” 的值，可以尝试用 base64解码，可能可以获取wxid和timestamp</p><p><a href="https://www.sojson.com/base64.html">https://www.sojson.com/base64.html</a></p><ol start="6"><li>[“workers”]字段需要为目录</li></ol><p>在目录下找打了workers.js的文件</p><p><img src="/img/5ab912ead2e88e55b3bdca157bb6f6a.jpg" alt="图标"></p><p>需要用wxappUnpacker-master这个工具中的wuJs.js进行分包，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node .\wuJs.js E:\tools\wxpack\main\workers.js</span><br></pre></td></tr></table></figure><p>分包成功,得到worker&#x2F;response&#x2F;index.js</p><ol start="7"><li>Unity plugin加载 data-package失败</li></ol><p>在获取游戏是，目录中没有_data-package_.wxapkg这个包。在微信开发者工具中手动创建data-package目录后，在console中遇到如下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PLUGIN ERROR 16:58.17.613]  解压资源失败, 加载方式: 分包, errMsg:  readCompressedFile:fail data-package/830ce1e8f65310db.webgl.data.unityweb.bin.br not found(<span class="built_in">env</span>: Windows,mg,1.06.2405020; lib: development)</span><br></pre></td></tr></table></figure><p>发现在data-package目录下，加载游戏分包时，并没有得到 830ce1e8f65310db.webgl.data.unityweb.bin.br 这个文件这种情况可能是在加载游戏的时候，data package 缓存到了用户的本地目录WeChat Files&lt;用户的hash码&gt;\Applet&lt;游戏的码&gt;\usr（如：WeChat Files\wxid_hq52a973p00x22\Applet\wxfc5347dec6075f3a\usr）下面解决方法：把WeChat Files&lt;用户的hash码&gt;\Applet\下的缓存文件全部删掉，并且把WeChat Files\Applet\下面的游戏缓存全部删掉，重新打开并加载游戏有可能会在游戏的文件中得到 <em>data-package</em>.wxapkg 文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小游戏反编译&quot;&gt;&lt;a href=&quot;#微信小游戏反编译&quot; class=&quot;headerlink&quot; title=&quot;微信小游戏反编译&quot;&gt;&lt;/a&gt;微信小游戏反编译&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/thebeastofwar</summary>
      
    
    
    
    
    <category term="Unity微信小游戏" scheme="http://xuexuanfeng.github.io/tags/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>FPS游戏武器被墙体遮挡的问题</title>
    <link href="http://xuexuanfeng.github.io/2025/03/11/FPS%E6%B8%B8%E6%88%8F%E6%AD%A6%E5%99%A8%E8%A2%AB%E5%A2%99%E4%BD%93%E9%81%AE%E6%8C%A1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://xuexuanfeng.github.io/2025/03/11/FPS%E6%B8%B8%E6%88%8F%E6%AD%A6%E5%99%A8%E8%A2%AB%E5%A2%99%E4%BD%93%E9%81%AE%E6%8C%A1%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2025-03-11T10:05:55.000Z</published>
    <updated>2025-03-11T10:11:12.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FPS游戏武器被墙体遮挡的问题"><a href="#FPS游戏武器被墙体遮挡的问题" class="headerlink" title="FPS游戏武器被墙体遮挡的问题"></a>FPS游戏武器被墙体遮挡的问题</h1><p>&emsp;&emsp;在FPS游戏中武器经常会因为摄像机透视视角的原因导致被游戏中的某些环境遮挡，有些游戏会要求武器永远被渲染在屏幕中不会被遮挡，这时候可以使用单独的一个相机设置culling mask来渲染武器这个层</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FPS游戏武器被墙体遮挡的问题&quot;&gt;&lt;a href=&quot;#FPS游戏武器被墙体遮挡的问题&quot; class=&quot;headerlink&quot; title=&quot;FPS游戏武器被墙体遮挡的问题&quot;&gt;&lt;/a&gt;FPS游戏武器被墙体遮挡的问题&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在FPS游戏</summary>
      
    
    
    
    
    <category term="unity优化" scheme="http://xuexuanfeng.github.io/tags/unity%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>架构设计</title>
    <link href="http://xuexuanfeng.github.io/2025/02/04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xuexuanfeng.github.io/2025/02/04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2025-02-04T07:01:41.000Z</published>
    <updated>2025-02-04T07:41:59.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><pre><code>架构设计的理论框架</code></pre><h2 id="三种需要架构的情景"><a href="#三种需要架构的情景" class="headerlink" title="三种需要架构的情景"></a>三种需要架构的情景</h2><ol><li><p>一个系统，构成复杂，需要多个子系统协同以实现系统目标</p></li><li><p>一个系统，他由多个功能相似的模块构成，模块内的功能重复度很高，且容易出错。</p></li><li><p>一个系统，规模太大，需要多人协作完成，需要保证多人协作的效率和稳定性。</p></li></ol><h2 id="三种架构设计的思维"><a href="#三种架构设计的思维" class="headerlink" title="三种架构设计的思维"></a>三种架构设计的思维</h2><ol><li><p>分层思维</p></li><li><p>分治思维</p></li><li><p>演化思维</p></li></ol><h2 id="架构设计时的考量点"><a href="#架构设计时的考量点" class="headerlink" title="架构设计时的考量点"></a>架构设计时的考量点</h2><ul><li><p>游戏引擎的选择</p></li><li><p>UI的事件系统</p></li><li><p>AI行为算法</p></li><li><p>数据如何获取和存储</p></li><li><p>场景如何拆分</p></li><li><p>是否需要将资源分离出去</p></li><li><p>长连接短连接的选择</p></li><li><p>服务器语言的选择</p></li><li><p>使用关系型数据库还是加入cache机制</p></li><li><p>网络协议是protobuf，json，xml的选择</p></li></ul><h2 id="架构的五种能力"><a href="#架构的五种能力" class="headerlink" title="架构的五种能力"></a>架构的五种能力</h2><ol><li><p>承载力</p></li><li><p>可扩展性</p></li><li><p>易用性</p></li><li><p>可伸缩力</p></li><li><p>容错力以及错误的感知力</p></li></ol><h2 id="基本的架构思维"><a href="#基本的架构思维" class="headerlink" title="基本的架构思维"></a>基本的架构思维</h2><ul><li><p>算法和数据结构</p></li><li><p>软件工程</p></li><li><p>面向对象程序设计</p></li><li><p>抽象：分层、分治、演化</p></li></ul><h2 id="前端架构的思考点"><a href="#前端架构的思考点" class="headerlink" title="前端架构的思考点"></a>前端架构的思考点</h2><ol><li>用户体验</li></ol><ul><li><p>如何让游戏加载更快</p></li><li><p>如何制作更绚丽的特效</p></li><li><p>如何减少DrawCall</p></li><li><p>如何减少CPU的负载</p></li><li><p>如何最快的响应用户的操作</p></li><li><p>如何适应更多的手机</p></li></ul><ol start="2"><li><p>操作系统</p></li><li><p>游戏引擎</p></li><li><p>应用层框架</p></li><li><p>业务逻辑</p></li></ol><h2 id="UI前端框架的技术栈"><a href="#UI前端框架的技术栈" class="headerlink" title="UI前端框架的技术栈"></a>UI前端框架的技术栈</h2><ol><li><p>UI框架</p></li><li><p>主要逻辑框架</p></li></ol><ul><li><p>编辑器</p></li><li><p>角色行为框架</p></li><li><p>AI框架</p></li><li><p>地图场景与寻路框架</p></li><li><p>Shader与特效</p></li><li><p>设备平台</p></li></ul><ol start="3"><li>资源管理</li></ol><ul><li><p>Assetbundle资源管理</p></li><li><p>prefab资源管理</p></li></ul><ol start="4"><li>数据管理</li></ol><ul><li><p>内存数据管理</p></li><li><p>外部数据管理</p></li></ul><ol start="5"><li>网络</li></ol><h2 id="各个模块的拆分"><a href="#各个模块的拆分" class="headerlink" title="各个模块的拆分"></a>各个模块的拆分</h2><ol><li>数据表</li></ol><ul><li>XLS导为二进制文件还是json或者其他格式，读取接口和解析接口的定义</li></ul><ol start="2"><li>UI层</li></ol><ul><li><p>使用UGUI,NGUI,FGUI框架</p></li><li><p>界面基类，界面管理，输入事件封装，自定义各类通用组件</p></li></ul><ol start="3"><li>外部资源管理</li></ol><ul><li>是否使用AssetBundle，AssetBundle资源分类，AssetBundle资源之间的依赖关系，加载与释放AssetBundle的管理，AssetBundle加密</li></ul><ol start="4"><li>AI层</li></ol><ul><li>使用状态机还是行为树或是其他，状态机或行为树接口实现，AI可视化工具，AI扩展接口</li></ul><ol start="5"><li>地形地图</li></ol><ul><li>地图是2D还是3D，场景编辑器的结构，是否需要mesh合并，场景内的大小物件区别对待，大地形在游戏里该怎么逐步显示，是否需要划分区块。</li></ul><ol start="6"><li>寻路与网格</li></ol><ul><li><p>使用A星还是跳点算法还是其他</p></li><li><p>使用网格栅格还是三角形</p></li><li><p>长距离寻路的解决方案</p></li><li><p>地图数据管理</p></li></ul><ol start="7"><li>常用库</li></ol><ul><li>时间函数、数学函数、数字变量加密封装、坐标转换函数、Debug调试工具、各大逻辑系统通用工具</li></ul><ol start="8"><li>角色行为控制</li></ol><ul><li>人物移动处理方案，摄像机的碰撞检测，动画特效编辑器，技能编辑器、行为流的建立</li></ul><ol start="9"><li>2D动画控制</li></ol><ul><li>动画组件封装，2D动画的制作流程，2D图合并为图集</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;架构设计&quot;&gt;&lt;a href=&quot;#架构设计&quot; class=&quot;headerlink&quot; title=&quot;架构设计&quot;&gt;&lt;/a&gt;架构设计&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;架构设计的理论框架
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;三种需要架构的情景&quot;&gt;&lt;a href=&quot;#三</summary>
      
    
    
    
    
    <category term="架构设计" scheme="http://xuexuanfeng.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>TextMeshPro中文字体的处理</title>
    <link href="http://xuexuanfeng.github.io/2025/01/10/TextMeshPro%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://xuexuanfeng.github.io/2025/01/10/TextMeshPro%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E7%9A%84%E5%A4%84%E7%90%86/</id>
    <published>2025-01-10T15:38:21.000Z</published>
    <updated>2025-01-10T15:40:54.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity插件工具相关"><a href="#Unity插件工具相关" class="headerlink" title="Unity插件工具相关"></a>Unity插件工具相关</h1><p>网上有很多TextMeshPro的中文处理，主要都是使用预制常用字体文件生成静态字体</p><p>这篇文章使用了动态字体，感觉很方便。</p><p><a href="https://www.bilibili.com/opus/816972383961219126">https://www.bilibili.com/opus/816972383961219126</a></p><p>字体下载git<br><a href="https://github.com/adobe-fonts/source-han-sans/tree/release">https://github.com/adobe-fonts/source-han-sans/tree/release</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity插件工具相关&quot;&gt;&lt;a href=&quot;#Unity插件工具相关&quot; class=&quot;headerlink&quot; title=&quot;Unity插件工具相关&quot;&gt;&lt;/a&gt;Unity插件工具相关&lt;/h1&gt;&lt;p&gt;网上有很多TextMeshPro的中文处理，主要都是使用预制常用字体</summary>
      
    
    
    
    
    <category term="Unity插件工具相关" scheme="http://xuexuanfeng.github.io/tags/Unity%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>捏脸系统</title>
    <link href="http://xuexuanfeng.github.io/2024/12/19/%E6%8D%8F%E8%84%B8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://xuexuanfeng.github.io/2024/12/19/%E6%8D%8F%E8%84%B8%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-12-19T15:37:42.000Z</published>
    <updated>2025-02-04T07:04:40.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="捏脸系统学习开发"><a href="#捏脸系统学习开发" class="headerlink" title="捏脸系统学习开发"></a>捏脸系统学习开发</h1><h2 id="学习日志"><a href="#学习日志" class="headerlink" title="学习日志"></a>学习日志</h2><ul><li><p>目前看下来主要的流程是模型导入到blend中，添加blendshape参数，然后导入unity中，通过unity中UI动态设置skinmesh里的blendshape参数来调整模型的容貌</p></li><li><p>blender里面的值是0-1，unity中对应的是0-100</p></li><li><p>unity里面有个插件叫UMA，可以做blendershape，还能有换装的效果，具体的话以后单独开一期研究下</p></li><li><p>决定先将大奉的捏脸模块单独拿出来，用于以后的修改</p></li><li><p>大奉家里老版本，需要晚上更新一下最新版本，但是半天的时候看了下uma发现这个插件可以满足捏脸的一切需求，决定深入研究一下。</p></li><li><p>由于先看了uma，感觉这个插件大有可为，系统分为recipe，slot，overlay，整体撸了一遍插件使用，但是模型制作的pipline还是有所缺失，补习blender中。</p></li><li><p>gitee测试项目地址<a href="https://gitee.com/xuexuanfeng/unity_-uma.git">https://gitee.com/xuexuanfeng/unity_-uma.git</a></p></li><li><p>目前来看制作衣橱配方再blend里面需要将导出fbx设为6.1，如果是7.4的话坐标会对不上，目前还不知到原理</p></li><li><p>免费模型网站 Daz3D，Adobe fuse已经停止服务了，相对的可以再stream上面找到Mixamo fuse，但是steam版本没法直接上传mixamo，老是提示登陆203.</p></li><li><p>Mixamo fuse由于不能再软件里上传mixamo，所以得导出obj去上传绑定骨骼，这样的话贴图就没了</p></li><li><p>经过尝试，youtube教程上的模型导出流程已经过时了，故而用character creator导出FBX，导入blender之后2.X版本材质丢失，4.x版本显示正常，而且也有blendshape。看来新的工作流与教程上的blender2还是有出路的，但是blender4的界面和2又很不一样，学习过程中会比较绕。目前看来也没什么好的解决办法，只能用4.x处理模型了。</p></li><li><p>自己创建baserace，bone的结构很重要，必须要又Global和Position节点。另一步是分割网格，把一个body分割成头身体手脚这些部分</p></li><li><p>再制作base race的时候发现一个问题，当一个mesh里面又多个submesh的时候转换slot会有问题，比如说两个眼珠子，他只会转一个眼珠子出来，目前看来解决办法是将blender里面的材质球全部删除就没有submesh，导出的fbx为白模，这样的话mesh也就没有submesh了，但是这样材质需要合并，合并材质B站上也有教学，比较麻烦，就先无视了</p></li><li><p>大风捏脸系统的界面lua转C#处理</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;捏脸系统学习开发&quot;&gt;&lt;a href=&quot;#捏脸系统学习开发&quot; class=&quot;headerlink&quot; title=&quot;捏脸系统学习开发&quot;&gt;&lt;/a&gt;捏脸系统学习开发&lt;/h1&gt;&lt;h2 id=&quot;学习日志&quot;&gt;&lt;a href=&quot;#学习日志&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="学习记录" scheme="http://xuexuanfeng.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Dots学习心得</title>
    <link href="http://xuexuanfeng.github.io/2024/12/18/Dots%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <id>http://xuexuanfeng.github.io/2024/12/18/Dots%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</id>
    <published>2024-12-18T15:47:31.000Z</published>
    <updated>2024-12-23T14:15:02.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网球游戏开发"><a href="#网球游戏开发" class="headerlink" title="网球游戏开发"></a>网球游戏开发</h1><p>codemonkey的免费学习教程学习记录</p><h2 id="学习日志"><a href="#学习日志" class="headerlink" title="学习日志"></a>学习日志</h2><ul><li><p>Entity可以通过mono脚本进行烘培，通过Baker类中的抽象接口写入烘培逻辑，先get一个Entity，然后再addcomponent</p></li><li><p>Isytem使用非托管内存，建议使用</p></li><li><p>创建Entity和NativeArray都需要加上一个参数</p></li><li><p>使用碰撞检测比较麻烦，需要先获得一个PhysicsWorldSingleton，然后通过这个单例获取CollisionWorld，其中CollisionWorld就类似于主线程中的Physic。</p></li><li><p>感觉主要的变成思想就是IcomponentData内存储数据，然后再System中处理数据，Entity就是单纯的IcomponentData载体。</p></li><li><p>debuger目前知道的只能通过打log，并没有很好的办法。</p></li><li><p>Isystem内的逻辑是不会使用多线程的，根据教程上面说的主要是先再Isystem内的OnUpdate写好逻辑，测试没什么问题，创建IJobEntity，再IJobEntity内的Execute函数内写逻辑。调用方法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UnitMoverJob unitMoverJob = new UnitMoverJob</span><br><span class="line">&#123;</span><br><span class="line">    daltaTime = SystemAPI.Time.DeltaTime</span><br><span class="line">&#125;;</span><br><span class="line">unitMoverJob.ScheduleParallel();</span><br></pre></td></tr></table></figure><ul><li>使用Jobes的Execute有一点很方便，不用像再System的Update里面写很长的foreach，直接把想要的component写在形参里面就行了，ref代表RW，in代表RO</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[BurstCompile]</span><br><span class="line">public partial struct UnitMoverJob : IJobEntity</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="built_in">float</span> daltaTime;</span><br><span class="line">    public void Execute(ref LocalTransform localTransform,<span class="keyword">in</span> UnitMover unitMover, ref PhysicsVelocity physicVelocity)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>mono脚本可以访问entity数据，system也可以访问主线程的数据，但是这样的话burst会失效。</p></li><li><p>mono访问entity脚本很麻烦，需要先获取实体管理器，然后调用实体查询器，查询器依赖于管理器。其中有一个暗坑。获取到的component组件修改完之后需要调用SetComponentData来保存，要不然entity上的值是不会变得，因为component是struct值类型，具体代码如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EntityManager entitymanager = World.DefaultGameObjectInjectionWorld.EntityManager;</span><br><span class="line">EntityQuery entityQuery = new EntityQueryBuilder(Allocator.Temp).WithAll&lt;Selected&gt;().Build(entitymanager);</span><br><span class="line">NativeArray&lt;Entity&gt; entityArray = entityQuery.ToEntityArray(Allocator.Temp);</span><br><span class="line">NativeArray&lt;Selected&gt; selectedArray = entityQuery.ToComponentDataArray&lt;Selected&gt;(Allocator.Temp);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; entityArray.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    entitymanager.SetComponentEnabled&lt;Selected&gt;(entityArray[i], <span class="literal">false</span>);</span><br><span class="line">    Selected selected = selectedArray[i];</span><br><span class="line">    selected.onDeselected = <span class="literal">true</span>;</span><br><span class="line">    selectedArray[i] = selected;</span><br><span class="line">    entitymanager.SetComponentData(entityArray[i], selected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>System中获取DeltaTime需要用SystemAPI.Time.DeltaTime</p></li><li><p>Entity的判空处理是 &#x3D;&#x3D; Entity.Null</p></li><li><p>entitymanager给我的感觉就好像是GameObject类，里面有很多的getcomponent，setcomponet，hascomponet这种关于component的操作</p></li><li><p>system中通过查询component可以很方便的使用WithEntityAccess获取entity，通过state可以直接访问实体管理器，foreach中是不能直接删除entity的，必须把entity删除命令放到EntityCommandBuffer中，再foreach结束之后调用entityCommandBuffer.Playback</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    EntityCommandBuffer entityCommandBuffer = new EntityCommandBuffer(Unity.Collections.Allocator.Temp);</span><br><span class="line">    foreach ((RefRO&lt;Health&gt; health,</span><br><span class="line">        Entity entity) </span><br><span class="line">        in SystemAPI.Query&lt;RefRO&lt;Health&gt;&gt;().WithEntityAccess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(health.ValueRO.healthAmount &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            //state.EntityManager.DestroyEntity(entity);</span><br><span class="line">            entityCommandBuffer.DestroyEntity(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entityCommandBuffer.Playback(state.EntityManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果使用系统自带的缓冲区，就不需要new一个EntityCommandBuffer了，而且会自动Playback</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    EntityCommandBuffer entityCommandBuffer = SystemAPI.GetSingleton&lt;EndSimulationEntityCommandBufferSystem.Singleton&gt;().CreateCommandBuffer(state.WorldUnmanaged);</span><br><span class="line">    foreach ((RefRO&lt;Health&gt; health,</span><br><span class="line">        Entity entity) </span><br><span class="line">        in SystemAPI.Query&lt;RefRO&lt;Health&gt;&gt;().WithEntityAccess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(health.ValueRO.healthAmount &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            //state.EntityManager.DestroyEntity(entity);</span><br><span class="line">            entityCommandBuffer.DestroyEntity(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一般再system遇到报错时候堆栈会无法跳转，难以阅读，这时候需要关闭burst进行调试</p></li><li><p>当一个entity被销毁之后不能判断他是不是null，需要通过SystemAPI.Exists(target.ValueRO.targetEntity)来进行判断</p></li><li><p>system可以通过[UpdateInGroup(typeof(LateSimulationSystemGroup))]属性来设置不同system的执行时序，避免逻辑混乱</p></li><li><p>如果DestroyEntity之后实体消失了但是网格渲染还在，这说明entity的预制件上面需要添加LinkedEntityGroupAuthoring组件</p></li><li><p>再system中可以实例化entity对象，就像实例化gameobject对象一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entity bulletEntity = state.EntityManager.Instantiate(entityReferences.bulletPrefabEntity);</span><br></pre></td></tr></table></figure></li><li><p>如果某个component全局只有一个，如同单例一般，可以直接通过SystemAPI直接调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityReference entityReferences = SystemAPI.GetSingleton&lt;EntityReference&gt;();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网球游戏开发&quot;&gt;&lt;a href=&quot;#网球游戏开发&quot; class=&quot;headerlink&quot; title=&quot;网球游戏开发&quot;&gt;&lt;/a&gt;网球游戏开发&lt;/h1&gt;&lt;p&gt;codemonkey的免费学习教程学习记录&lt;/p&gt;
&lt;h2 id=&quot;学习日志&quot;&gt;&lt;a href=&quot;#学习日志</summary>
      
    
    
    
    
    <category term="学习记录" scheme="http://xuexuanfeng.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>网球游戏开发</title>
    <link href="http://xuexuanfeng.github.io/2024/12/08/%E7%BD%91%E7%90%83%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://xuexuanfeng.github.io/2024/12/08/%E7%BD%91%E7%90%83%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</id>
    <published>2024-12-08T15:59:13.000Z</published>
    <updated>2024-12-19T14:16:38.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网球游戏开发"><a href="#网球游戏开发" class="headerlink" title="网球游戏开发"></a>网球游戏开发</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>闲来无事，也是为了个人竞争力提升决定立项一个网球游戏，主要类似于网球王子，网球加入抽象技能。可能比较小众，但是记得某个UP主说过，每个独立游戏开发者都会开发这么一款不赚钱的游戏。</code></pre><h2 id="工作日志"><a href="#工作日志" class="headerlink" title="工作日志"></a>工作日志</h2><ol><li>2024&#x2F;12&#x2F;9</li></ol><ul><li>下载了地图场景以及淘宝游戏源码，击球音效，动作的话准备击球逻辑整理清楚了之后再说，毕竟淘宝也要买8块钱了，如果明天unity那边可以免费下资源的话可以尝试白嫖一下。</li></ul><ol start="2"><li>2024&#x2F;12&#x2F;10</li></ol><ul><li>新建Game场景</li><li>搭建碰撞空气墙</li><li>场景内加入角色</li><li>加入输入系统</li><li>角色可移动</li><li>角色可击球<br>但是网球的运动轨迹还不是抛物线，接下来主要攻克。</li></ul><ol start="3"><li>2024&#x2F;12&#x2F;11</li></ol><ul><li>修复了击球报错bug</li><li>网球的位置重置<br>今天没什么时间制作击球功能，但是白天的网上查询决定使用贝塞尔曲线来实现网球的运动，这样可以做出各种各样的球路了</li></ul><ol start="4"><li>2024&#x2F;12&#x2F;12</li></ol><ul><li>修复击球不符合预期的bug</li><li>增加hit委托事件</li><li>调整击球力度</li><li>增加网球的贝塞尔运动轨迹<br>实测下来网球运动用贝塞尔曲线是可行的，落点很精确，剩下要做的是确认击球后的贝塞尔的中间点位置，以及球落地之后的反弹表现，希望可以通过落点之前前两帧计算出向下以及向前的加速度算出反弹的表现</li></ul><ol start="5"><li>2024&#x2F;12&#x2F;13</li></ol><ul><li>新增控制击球效果的manager类</li><li>增加网球落地之后的反弹效果</li><li>增加对战AI<br>接下来需要复刻一下网球王子的击球，控制击球落点,玩了会游戏，感觉需要做球路的预判，然后再按下击球判断是否可以蓄力，如果可以的话进入蓄力状态，上下左右控制落点</li></ul><ol start="6"><li>2024&#x2F;12&#x2F;14</li></ol><ul><li>击球路线预测</li><li>网球落地抖动的问题</li><li>击球点的边界逻辑，默认击球落点逻辑设定</li><li>运动第一轨迹关闭重力，避免网球运动轨迹不符合预期<br>界限来的就是预判占位是否再预判轨迹上，当符合自动击球逻辑的时候按下击球，移动aim光标的坐标来设定击球点</li></ul><ol start="7"><li>2024&#x2F;12&#x2F;15</li></ol><ul><li>击球点的预测</li><li>预判球路之后的自动位移<br>击球这块做得八九不离十了，接下来需要制作主角的locomotion，淘宝买的八块钱资产貌似不好用，焦虑</li></ul><ol start="8"><li>2024&#x2F;12&#x2F;16</li></ol><ul><li>加入有限状态机，添加待机，行走，击球状态</li><li>调整animator状态树，加入待机，行走，击球动作</li><li>重构击球逻辑<br>重构了击球逻辑，改动较大，之前说资产不好用还是不严谨了，只要生成骨骼信息，动画导出为骨骼动画还是能讲究用一下的，就是动作怪了点，但是不至于一动不动。后续可能需要加上左右击球动作的判断。挥拍的动作也要和网球的路线对应上。</li></ul><ol start="9"><li>2024&#x2F;12&#x2F;17</li></ol><ul><li>击球逻辑优化</li><li>加入反手击球的部分逻辑，包括球路的左右判断，动画的提取<br>今天主要的时间都用来改击球bug了，反手逻辑还没有加入，目前比较尴尬的是预判球路之后自动移动到对应的位置再击球会导致预备动画没播完球就飞过去了。其实是可以打到的。可以考虑击球动画加入layer，一边走一边挥拍。</li></ul><ol start="10"><li>2024&#x2F;12&#x2F;18</li></ol><ul><li>将网球的飞行速度设为恒定，原来是按时间那就导致不懂的路径飞行速度有快有慢</li><li>网球不与角色发生碰撞，避免飞行路径会碰到人导致反弹，之后会做trigger处理<br>现在主要的问题是再预判球路径之后做完表现，球已经飞走了，表现不符合预期。得定一个规则处理下这种情况。<br>用过击球动画分层，让我再按下击球的时候就开始做动作，而不用先跑到目标点再挥拍而耽误时间，手感提升显著。接下来可以开始制作反手击球。</li></ul><ol start="11"><li>2024&#x2F;12&#x2F;19</li></ol><ul><li>反手抽球动画逻辑添加<br>目前处于瓶颈期，对于网球的轨迹存在疑问，不知道目前的网球飞行逻辑对于日后的开发是否可扩展，还是得沉淀沉淀。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网球游戏开发&quot;&gt;&lt;a href=&quot;#网球游戏开发&quot; class=&quot;headerlink&quot; title=&quot;网球游戏开发&quot;&gt;&lt;/a&gt;网球游戏开发&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="游戏开发记录" scheme="http://xuexuanfeng.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>UnityAI编程工具Cursor</title>
    <link href="http://xuexuanfeng.github.io/2024/11/04/UnityAI%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7Cursor/"/>
    <id>http://xuexuanfeng.github.io/2024/11/04/UnityAI%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7Cursor/</id>
    <published>2024-11-04T14:45:01.000Z</published>
    <updated>2025-05-14T14:39:56.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UnityAI编程工具Cursor"><a href="#UnityAI编程工具Cursor" class="headerlink" title="UnityAI编程工具Cursor"></a>UnityAI编程工具Cursor</h1><p>B站闲逛发现了一个很炸裂的工具Cursor，chatGpt的免费平替了</p><p>Cursor下载: <a href="https://www.cursor.com/">https://www.cursor.com/</a><br>Uinty 插件下下载: <a href="https://github.com/boxqkrtm/com.unity.ide.cursor">https://github.com/boxqkrtm/com.unity.ide.cursor</a><br>或者packagemanager直接输入: <a href="https://github.com/boxqkrtm/com.unity.ide.cursor.git">https://github.com/boxqkrtm/com.unity.ide.cursor.git</a></p><ol><li><p>先要去Cursor官网下载，需要翻墙。安装完毕之后选择中文。</p></li><li><p>打开unity工程，在packagemanager中install by githuburl 安装unity插件。</p></li><li><p>Preferences中加入Cursor编辑器</p></li><li><p>双击脚本打开编辑器，界面和vs code差不多。在插件扩展栏搜索unity，把相关的插件都装了。</p></li><li><p>Ctrl+L 呼出AI进行对话，生成代码，点击accept复制代码到文件中。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UnityAI编程工具Cursor&quot;&gt;&lt;a href=&quot;#UnityAI编程工具Cursor&quot; class=&quot;headerlink&quot; title=&quot;UnityAI编程工具Cursor&quot;&gt;&lt;/a&gt;UnityAI编程工具Cursor&lt;/h1&gt;&lt;p&gt;B站闲逛发现了一个很</summary>
      
    
    
    
    
    <category term="Unity插件工具相关" scheme="http://xuexuanfeng.github.io/tags/Unity%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>批量修改图片脚本</title>
    <link href="http://xuexuanfeng.github.io/2024/11/04/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E8%84%9A%E6%9C%AC/"/>
    <id>http://xuexuanfeng.github.io/2024/11/04/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E8%84%9A%E6%9C%AC/</id>
    <published>2024-11-04T13:48:05.000Z</published>
    <updated>2024-11-04T14:50:37.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity插件工具相关"><a href="#Unity插件工具相关" class="headerlink" title="Unity插件工具相关"></a>Unity插件工具相关</h1><p>借鉴现有工程代码，比较完美的工具代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">using System.Linq;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEditor;</span><br><span class="line"></span><br><span class="line">public static class WebGLTextureSet</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(<span class="string">&quot;OptimizeTool/Texture/WebGLTextureSet&quot;</span>)]</span><br><span class="line">    private static void <span class="function"><span class="title">_Set</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        var paths = AssetDatabase.FindAssets(<span class="string">&quot;t:Texture&quot;</span>, GetPath()).Select(AssetDatabase.GUIDToAssetPath);</span><br><span class="line"></span><br><span class="line">        foreach (var path <span class="keyword">in</span> paths)</span><br><span class="line">        &#123;</span><br><span class="line">            Set(path);</span><br><span class="line">        &#125;</span><br><span class="line">        AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static string[] <span class="function"><span class="title">GetPath</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> new string[] &#123; <span class="string">&quot;Assets/HotUpdateResources&quot;</span>, <span class="string">&quot;Assets/Resources&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Set(string path)</span><br><span class="line">    &#123;</span><br><span class="line">        var item = TextureImporter.GetAtPath(path) as TextureImporter;</span><br><span class="line">        <span class="keyword">if</span> (item != null)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bool isChange = Set(item);</span><br><span class="line">        <span class="keyword">if</span> (isChange)</span><br><span class="line">        &#123;</span><br><span class="line">            AssetDatabase.ImportAsset(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static bool Set(TextureImporter item)</span><br><span class="line">    &#123;</span><br><span class="line">        bool isChange = Set(item, <span class="string">&quot;WebGL&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> isChange; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static bool Set(TextureImporter item, string str)</span><br><span class="line">    &#123;</span><br><span class="line">        var seting = item.GetPlatformTextureSettings(str);</span><br><span class="line">        bool isChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!seting.overridden)</span><br><span class="line">        &#123;</span><br><span class="line">            seting.overridden = <span class="literal">true</span>;</span><br><span class="line">            isChange = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seting.format != TextureImporterFormat.ASTC_8x8)</span><br><span class="line">        &#123;</span><br><span class="line">            seting.format = TextureImporterFormat.ASTC_8x8;</span><br><span class="line">            isChange = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seting.textureCompression == TextureImporterCompression.Uncompressed)</span><br><span class="line">        &#123;</span><br><span class="line">            seting.textureCompression = TextureImporterCompression.Compressed;</span><br><span class="line">            isChange = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isChange)</span><br><span class="line">        &#123;</span><br><span class="line">            item.SetPlatformTextureSettings(seting);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> isChange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity插件工具相关&quot;&gt;&lt;a href=&quot;#Unity插件工具相关&quot; class=&quot;headerlink&quot; title=&quot;Unity插件工具相关&quot;&gt;&lt;/a&gt;Unity插件工具相关&lt;/h1&gt;&lt;p&gt;借鉴现有工程代码，比较完美的工具代码&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    
    <category term="Unity插件工具相关" scheme="http://xuexuanfeng.github.io/tags/Unity%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>Webgl与Js的交互</title>
    <link href="http://xuexuanfeng.github.io/2024/11/03/Webgl%E4%B8%8EJs%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>http://xuexuanfeng.github.io/2024/11/03/Webgl%E4%B8%8EJs%E7%9A%84%E4%BA%A4%E4%BA%92/</id>
    <published>2024-11-03T11:54:06.000Z</published>
    <updated>2024-11-03T12:01:27.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webgl与Js的交互"><a href="#Webgl与Js的交互" class="headerlink" title="Webgl与Js的交互"></a>Webgl与Js的交互</h1><p>工作中遇到需求，想要将某些URL进行配置，首先想到的是配置本地数据文件，加载之后反序列化。过程复杂了点，但是可以实现功能。还发现了一种简单的配置方法，就是将url写入js文件中，然后通过Webgl去调用对应的函数取值。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先要创建jslib文件存入工程中，再编辑器中会看到一个类似于dll状态的文件。大致写法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mergeInto(LibraryManager.library, &#123;</span><br><span class="line">    </span><br><span class="line">    Hello: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        window.alert(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    HelloString: <span class="keyword">function</span> (str) &#123;</span><br><span class="line">        //这里使用Pointer_stringify方法转换unity传递过来的字符串</span><br><span class="line">        window.alert(Pointer_stringify(str));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    PrintFloatArray: <span class="keyword">function</span> (array, size) &#123;</span><br><span class="line">        <span class="keyword">for</span>(var i = 0; i &lt; size; i++)&#123;</span><br><span class="line">            //遍历<span class="built_in">float</span>数组使用HEAPF32，更多类型：HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64</span><br><span class="line">            console.log(HEAPF32[(array &gt;&gt; 2) + i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    AddNumbers: <span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">        //这里unity传递过来int类型数字，不需要转换</span><br><span class="line">        <span class="built_in">return</span> x + y;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    //返回一个字符串到unity</span><br><span class="line">    StringReturnValueFunction: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var returnStr = <span class="string">&quot;bla&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        var bufferSize = lengthBytesUTF8(returnStr) + 1;</span><br><span class="line">        var buffer = _malloc(bufferSize);</span><br><span class="line">        stringToUTF8(returnStr, buffer, bufferSize);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> buffer;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    BindWebGLTexture: <span class="keyword">function</span> (texture) &#123;</span><br><span class="line">        GLctx.bindTexture(GLctx.TEXTURE_2D, GL.textures[texture]);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>C#代码中调用如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using System.Runtime.InteropServices;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class callJSTest : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern void Hello();</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern void HelloString(string str);</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern void PrintFloatArray(<span class="built_in">float</span>[] array, int size);</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern int AddNumbers(int x, int y);</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern string StringReturnValueFunction();</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern void BindWebGLTexture(int texture);</span><br><span class="line"></span><br><span class="line">    void <span class="function"><span class="title">Start</span></span>() &#123;</span><br><span class="line">        Hello();</span><br><span class="line">        </span><br><span class="line">        HelloString(<span class="string">&quot;This is a string.&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">float</span>[] myArray = new <span class="built_in">float</span>[10];</span><br><span class="line">        PrintFloatArray(myArray, myArray.Length);</span><br><span class="line">        </span><br><span class="line">        int result = AddNumbers(5, 7);</span><br><span class="line">        Debug.Log(result);</span><br><span class="line">        </span><br><span class="line">        Debug.Log(StringReturnValueFunction());</span><br><span class="line">        </span><br><span class="line">        var texture = new Texture2D(0, 0, TextureFormat.ARGB32, <span class="literal">false</span>);</span><br><span class="line">        BindWebGLTexture(texture.GetNativeTextureID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际操作中需要到了点问题，Js中直接return字符串，C#这边取到的值一直为空，网上找了下貌似js的string和C#的string还是有点区别的，不能直接传递。string要从Javascript返回到 Unity，必须使用_malloc分配内存，然后将数据从变量stringToUTF8复制到新分配的内存中，然后返回该内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Webgl与Js的交互&quot;&gt;&lt;a href=&quot;#Webgl与Js的交互&quot; class=&quot;headerlink&quot; title=&quot;Webgl与Js的交互&quot;&gt;&lt;/a&gt;Webgl与Js的交互&lt;/h1&gt;&lt;p&gt;工作中遇到需求，想要将某些URL进行配置，首先想到的是配置本地数据文</summary>
      
    
    
    
    
    <category term="Unity微信小游戏" scheme="http://xuexuanfeng.github.io/tags/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
</feed>
