<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>存钱买电瓶车创业的猛男程序员</title>
  
  
  <link href="http://xuexuanfeng.github.io/atom.xml" rel="self"/>
  
  <link href="http://xuexuanfeng.github.io/"/>
  <updated>2025-12-15T09:31:05.928Z</updated>
  <id>http://xuexuanfeng.github.io/</id>
  
  <author>
    <name>xuexuanfeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优化编辑器下UGUI的点击选取对象脚本</title>
    <link href="http://xuexuanfeng.github.io/2025/12/15/%E4%BC%98%E5%8C%96%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8BUGUI%E7%9A%84%E7%82%B9%E5%87%BB%E9%80%89%E5%8F%96%E5%AF%B9%E8%B1%A1%E8%84%9A%E6%9C%AC/"/>
    <id>http://xuexuanfeng.github.io/2025/12/15/%E4%BC%98%E5%8C%96%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8BUGUI%E7%9A%84%E7%82%B9%E5%87%BB%E9%80%89%E5%8F%96%E5%AF%B9%E8%B1%A1%E8%84%9A%E6%9C%AC/</id>
    <published>2025-12-15T09:19:54.000Z</published>
    <updated>2025-12-15T09:31:05.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化编辑器下UGUI点击选取对象脚本"><a href="#优化编辑器下UGUI点击选取对象脚本" class="headerlink" title="优化编辑器下UGUI点击选取对象脚本"></a>优化编辑器下UGUI点击选取对象脚本</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在新项目中接触到一个便捷脚本，在编辑器运行模式下点击Game视图中的UGUI对象，会自动选中对应的GameObject，极大提升了调试效率。</p><h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line">public class UGUIEditorTool : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void <span class="function"><span class="title">Start</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line"></span><br><span class="line">    [SerializeField]</span><br><span class="line">    <span class="built_in">float</span> PingObjectTime = 1;</span><br><span class="line">    <span class="built_in">float</span> holdTime = 0;</span><br><span class="line">    void <span class="function"><span class="title">Update</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(0))</span><br><span class="line">        &#123;</span><br><span class="line">            holdTime += Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (holdTime &gt;= PingObjectTime)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3 mousePos = Input.mousePosition;</span><br><span class="line"></span><br><span class="line">                var go = PointerOverUIGameObject(new Vector2(mousePos.x, mousePos.y));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (go)</span><br><span class="line">                &#123;</span><br><span class="line">                    UnityEditor.EditorGUIUtility.PingObject(go);</span><br><span class="line">                    //Debug.Log($<span class="string">&quot;Pressed secondary button &#123;Input.mousePosition&#125; &#123;go.name&#125;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                holdTime = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            holdTime = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    GameObject PointerOverUIGameObject(Vector2 screenPos)</span><br><span class="line">    &#123;</span><br><span class="line">        var hitObject = UIRaycast(ScreenPosToPointerData(screenPos));</span><br><span class="line">        <span class="built_in">return</span> hitObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObject UIRaycast(PointerEventData pointerData)</span><br><span class="line">    &#123;</span><br><span class="line">        var results = new List&lt;RaycastResult&gt;();</span><br><span class="line">        EventSystem.current.RaycastAll(pointerData, results);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> results.Count &lt; 1 ? null : results[0].gameObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PointerEventData ScreenPosToPointerData(Vector2 screenPos)</span><br><span class="line">       =&gt; new PointerEventData(EventSystem.current) &#123; position = screenPos &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>在实际项目中可以采用以下优化方案：</p><ol><li><strong>单例模式</strong> - 将脚本作为单例，避免重复实例</li><li><strong>逻辑分离</strong> - 将执行逻辑移至其他Mono脚本的Update方法中</li><li><strong>条件编译</strong> - 通过宏指令控制，减少不必要的性能消耗</li><li><strong>按需执行</strong> - 优化检测频率，避免每帧执行</li></ol><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol><li>将脚本挂载到场景任意GameObject</li><li>设置<code>PingObjectTime</code>参数（默认1秒）</li><li>进入Play模式</li><li>在Game视图中长按UI元素，Hierarchy中会自动选中对应GameObject</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>仅Unity编辑器运行模式下有效</li><li>需要场景中存在有效的EventSystem</li><li>长按时间可根据需求调整</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;优化编辑器下UGUI点击选取对象脚本&quot;&gt;&lt;a href=&quot;#优化编辑器下UGUI点击选取对象脚本&quot; class=&quot;headerlink&quot; title=&quot;优化编辑器下UGUI点击选取对象脚本&quot;&gt;&lt;/a&gt;优化编辑器下UGUI点击选取对象脚本&lt;/h1&gt;&lt;h2 id=&quot;概</summary>
      
    
    
    
    
    <category term="Unity插件工具相关" scheme="http://xuexuanfeng.github.io/tags/Unity%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>微信小游戏StripEngineCode的问题</title>
    <link href="http://xuexuanfeng.github.io/2025/11/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8FStripEngineCode%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://xuexuanfeng.github.io/2025/11/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8FStripEngineCode%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2025-11-11T14:08:13.000Z</published>
    <updated>2025-11-11T14:19:24.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小游戏Strip-Engine-Code的问题"><a href="#微信小游戏Strip-Engine-Code的问题" class="headerlink" title="微信小游戏Strip Engine Code的问题"></a>微信小游戏Strip Engine Code的问题</h1><p>今天接入快手小游戏时导出的unity小游戏运行时报错Could not produce class with ID 81。推测class编号为81的类被裁剪掉了，导致没有找到对应代码。</p><p>对应的引擎类ID可以通过 <a href="https://docs.unity3d.com/6000.2/Documentation/Manual/ClassIDReference.html">官网文档</a> 找到，通过文档发现ID为81的类是AudioListener，在vs中找到AudioListener对应的dll为UnityEngine.AudioModule，在工程目录中的link.xml文件加入以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;assembly fullname=<span class="string">&quot;UnityEngine.AudioModule&quot;</span> preserve=<span class="string">&quot;all&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>重新打包测试游戏，问题解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小游戏Strip-Engine-Code的问题&quot;&gt;&lt;a href=&quot;#微信小游戏Strip-Engine-Code的问题&quot; class=&quot;headerlink&quot; title=&quot;微信小游戏Strip Engine Code的问题&quot;&gt;&lt;/a&gt;微信小游戏Strip </summary>
      
    
    
    
    
    <category term="Unity微信小游戏" scheme="http://xuexuanfeng.github.io/tags/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>NGUI界面SafeArea自适应</title>
    <link href="http://xuexuanfeng.github.io/2025/09/23/NGUI%E7%95%8C%E9%9D%A2SafeArea%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <id>http://xuexuanfeng.github.io/2025/09/23/NGUI%E7%95%8C%E9%9D%A2SafeArea%E8%87%AA%E9%80%82%E5%BA%94/</id>
    <published>2025-09-23T13:32:00.000Z</published>
    <updated>2025-09-23T14:06:02.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NGUI界面SafeArea自适应"><a href="#NGUI界面SafeArea自适应" class="headerlink" title="NGUI界面SafeArea自适应"></a>NGUI界面SafeArea自适应</h1><p>主要需要修改的类有以下几个：</p><ol><li>UIRectEditor</li></ol><p>修改代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void <span class="function"><span class="title">DrawFinalProperties</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((target as UIRect).canBeAnchored))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NGUIEditorTools.DrawHeader(<span class="string">&quot;SafeArea&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            NGUIEditorTools.BeginContents();</span><br><span class="line">            &#123;</span><br><span class="line">                GUILayout.BeginHorizontal();</span><br><span class="line">                NGUIEditorTools.SetLabelWidth(100f);</span><br><span class="line">                NGUIEditorTools.DrawProperty(<span class="string">&quot;ShowInSafeArea&quot;</span>, serializedObject, <span class="string">&quot;mShowInSafeArea&quot;</span>, GUILayout.Width(120f));</span><br><span class="line">                GUILayout.Label(<span class="string">&quot;控制子节点的锚点在安全区域内显示&quot;</span>);</span><br><span class="line">                GUILayout.EndHorizontal();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            NGUIEditorTools.EndContents();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NGUISettings.unifiedTransform) DrawAnchorTransform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>NGUITools</li></ol><p>修改代码（因为是横屏游戏，这里图方便上下并没有做自适应，如果是竖屏游戏的话需要的话需要另外添加一个yOffset）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Get sides relative to the specified camera. The order is left, top, right, bottom.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">    static public Vector3[] GetSides(this Camera cam, Transform relativeTo, bool showInSafeArea = <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> cam.GetSides(Mathf.Lerp(cam.nearClipPlane, cam.farClipPlane, 0.5f), relativeTo, showInSafeArea);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Get sides relative to the specified camera. The order is left, top, right, bottom.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">    static public Vector3[] GetSides(this Camera cam, <span class="built_in">float</span> depth, Transform relativeTo, bool showInSafeArea = <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">#if UNITY_4_3 || UNITY_4_5 || UNITY_4_6</span></span><br><span class="line"><span class="keyword">if</span> (cam.isOrthoGraphic)</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        <span class="keyword">if</span> (cam.orthographic)</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> xOffset = 1f;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (showInSafeArea)</span><br><span class="line">            &#123;</span><br><span class="line">                xOffset = Simulate_SafeAreaScale;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> os = cam.orthographicSize;</span><br><span class="line">            <span class="built_in">float</span> x0 = -os * xOffset;</span><br><span class="line">            <span class="built_in">float</span> x1 = os * xOffset;</span><br><span class="line">            <span class="built_in">float</span> y0 = -os;</span><br><span class="line">            <span class="built_in">float</span> y1 = os;</span><br><span class="line"></span><br><span class="line">            Rect rect = cam.rect;</span><br><span class="line">            Vector2 size = screenSize;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> aspect = size.x / size.y;</span><br><span class="line">            aspect *= rect.width / rect.height;</span><br><span class="line">            x0 *= aspect;</span><br><span class="line">            x1 *= aspect;</span><br><span class="line"></span><br><span class="line">            // We want to ignore the scale, as scale doesn<span class="string">&#x27;t affect the camera&#x27;</span>s view region <span class="keyword">in</span> Unity</span><br><span class="line">            Transform t = cam.transform;</span><br><span class="line">            Quaternion rot = t.rotation;</span><br><span class="line">            Vector3 pos = t.position;</span><br><span class="line"></span><br><span class="line">            int w = Mathf.RoundToInt(size.x);</span><br><span class="line">            int h = Mathf.RoundToInt(size.y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((w &amp; <span class="number">1</span>) == <span class="number">1</span>) pos.x -= <span class="number">1</span>f / size.x;</span><br><span class="line">            if ((h &amp; <span class="number">1</span>) == <span class="number">1</span>) pos.y += <span class="number">1</span>f / size.y;</span><br><span class="line"></span><br><span class="line">            mSides[<span class="number">0</span>] = rot * (new Vector3(x0, <span class="number">0</span>f, depth)) + pos;</span><br><span class="line">            mSides[1] = rot * (new Vector3(0f, y1, depth)) + pos;</span><br><span class="line">            mSides[2] = rot * (new Vector3(x1, 0f, depth)) + pos;</span><br><span class="line">            mSides[3] = rot * (new Vector3(0f, y0, depth)) + pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mSides[0] = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, depth));</span><br><span class="line">            mSides[1] = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, depth));</span><br><span class="line">            mSides[2] = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, depth));</span><br><span class="line">            mSides[3] = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (relativeTo != null)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 4; ++i)</span><br><span class="line">                mSides[i] = relativeTo.InverseTransformPoint(mSides[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> mSides;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">    private static Rect WeChatASafeArea;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 获取异型屏幕的安全区域SafeArea</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;Rect&lt;/returns&gt;</span><br><span class="line">    public static Rect <span class="function"><span class="title">GetSafeArea</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">#if !UNITY_EDITOR &amp;&amp; USE_WECHATMINISDK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(WeChatASafeArea.width == 0 &amp;&amp; WeChatASafeArea.height == 0)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> radio = (<span class="built_in">float</span>)WX.GetWindowInfo().windowWidth / Screen.width;</span><br><span class="line"></span><br><span class="line">    WeChatASafeArea = new Rect();</span><br><span class="line">WeChatASafeArea.width = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.width / radio;</span><br><span class="line">    WeChatASafeArea.height = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.height / radio;</span><br><span class="line">WeChatASafeArea.x = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.left / radio;</span><br><span class="line">WeChatASafeArea.y = ((float)WX.GetWindowInfo().windowHeight - (float)WX.GetWindowInfo().safeArea.height)/radio;</span><br><span class="line"></span><br><span class="line">UnityEngine.Debug.Log(&quot;WeChatASafeArea---------&quot;+WeChatASafeArea);</span><br><span class="line">&#125;</span><br><span class="line">return WeChatASafeArea;</span><br><span class="line">#elif !UNITY_EDITOR &amp;&amp; RPK_TTDOUYIN</span><br><span class="line">        if (WeChatASafeArea.width == <span class="number">0</span> &amp;&amp; WeChatASafeArea.height == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            float radio = (float)TT.GetSystemInfo().screenWidth / Screen.width;</span><br><span class="line"></span><br><span class="line">            WeChatASafeArea = new Rect();</span><br><span class="line">            WeChatASafeArea.width = (float)TT.GetSystemInfo().safeArea.width / radio;</span><br><span class="line">            WeChatASafeArea.height = (float)TT.GetSystemInfo().safeArea.height / radio;</span><br><span class="line">            WeChatASafeArea.x = (float)TT.GetSystemInfo().safeArea.left / radio;</span><br><span class="line">            WeChatASafeArea.y = ((float)TT.GetSystemInfo().screenHeight - (float)TT.GetSystemInfo().safeArea.height) / radio;</span><br><span class="line"></span><br><span class="line">            UnityEngine.Debug.Log(&quot;WeChatASafeArea---------&quot; + WeChatASafeArea);</span><br><span class="line">        &#125;</span><br><span class="line">        return WeChatASafeArea;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">        return Screen.safeArea;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static bool Simulate_SafeArea</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return ((WindowInfoWidth() != WindowInfoSafeWidth() || WindowInfoHeight() != WindowInfoSafeHeight()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">float</span> windowWidth;</span><br><span class="line">public static <span class="built_in">float</span> <span class="function"><span class="title">WindowInfoWidth</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(windowWidth == 0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">windowWidth = Screen.width;</span><br><span class="line"><span class="comment">#elif USE_WECHATMINISDK</span></span><br><span class="line">            windowWidth = WX.GetWindowInfo().windowWidth;</span><br><span class="line"><span class="comment">#elif RPK_TTDOUYIN</span></span><br><span class="line">            windowWidth = TT.GetSystemInfo().screenWidth;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> windowWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="built_in">float</span> safeWidth;</span><br><span class="line">    public static <span class="built_in">float</span> <span class="function"><span class="title">WindowInfoSafeWidth</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (safeWidth == 0)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">            safeWidth = GetSafeArea().width;</span><br><span class="line"><span class="comment">#elif USE_WECHATMINISDK</span></span><br><span class="line">            safeWidth = WX.GetWindowInfo().safeArea.width;</span><br><span class="line"><span class="comment">#elif RPK_TTDOUYIN</span></span><br><span class="line">            safeWidth = TT.GetSystemInfo().safeArea.width;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> safeWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="built_in">float</span> windowHeight;</span><br><span class="line">    public static <span class="built_in">float</span> <span class="function"><span class="title">WindowInfoHeight</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (windowHeight == 0)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">            windowHeight = Screen.height;</span><br><span class="line"><span class="comment">#elif USE_WECHATMINISDK</span></span><br><span class="line">            windowHeight = WX.GetWindowInfo().windowHeight;</span><br><span class="line"><span class="comment">#elif RPK_TTDOUYIN</span></span><br><span class="line">            windowHeight = TT.GetSystemInfo().screenHeight;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> windowHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="built_in">float</span> windowSafeHeight;</span><br><span class="line">    public static <span class="built_in">float</span> <span class="function"><span class="title">WindowInfoSafeHeight</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (windowSafeHeight == 0)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">            windowSafeHeight = GetSafeArea().height;</span><br><span class="line"><span class="comment">#elif USE_WECHATMINISDK</span></span><br><span class="line">            windowSafeHeight = WX.GetWindowInfo().safeArea.height;</span><br><span class="line"><span class="comment">#elif RPK_TTDOUYIN</span></span><br><span class="line">            windowSafeHeight = TT.GetSystemInfo().safeArea.height;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> windowSafeHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 模拟iPhone X比例</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public static <span class="built_in">float</span> Simulate_SafeAreaScale</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Simulate_SafeArea) <span class="built_in">return</span> 1f;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> (Screen.width - GetSafeArea().x * 2) / Screen.width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>UIRect</li></ol><p>添加变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[HideInInspector]</span><br><span class="line">[SerializeField]</span><br><span class="line">public bool mShowInSafeArea = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// Get the sides of the rectangle relative to the specified transform.</span><br><span class="line">/// The order is left, top, right, bottom.</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">public virtual Vector3[] GetSides(Transform relativeTo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (anchorCamera != null) <span class="built_in">return</span> mCam.GetSides(cameraRayDistance, relativeTo, mShowInSafeArea);</span><br><span class="line"></span><br><span class="line">    Vector3 pos = cachedTransform.position;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 4; ++i)</span><br><span class="line">        mSides[i] = pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (relativeTo != null)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 4; ++i)</span><br><span class="line">            mSides[i] = relativeTo.InverseTransformPoint(mSides[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> mSides;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Convenience <span class="keyword">function</span> that returns the sides the anchored point is anchored to.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">        public Vector3[] GetSides(Transform relativeTo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (target != null)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (rect != null) <span class="built_in">return</span> rect.GetSides(relativeTo);</span><br><span class="line"><span class="comment">#if UNITY_4_3 || UNITY_4_5 || UNITY_4_6 || UNITY_4_7</span></span><br><span class="line"><span class="keyword">if</span> (target.camera != null) <span class="built_in">return</span> target.camera.GetSides(relativeTo,rect.mShowInSafeArea);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">                var cam = target.GetComponent&lt;Camera&gt;();</span><br><span class="line">                <span class="keyword">if</span> (cam != null) <span class="built_in">return</span> cam.GetSides(relativeTo, rect.mShowInSafeArea);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>UIAnchor</li></ol><p>修改代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">Update</span></span> ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mAnim != null &amp;&amp; mAnim.enabled &amp;&amp; mAnim.isPlaying) <span class="built_in">return</span>;</span><br><span class="line"><span class="keyword">if</span> (mTrans == null) <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">bool useCamera = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">UIWidget <span class="built_in">wc</span> = (container == null) ? null : container.GetComponent&lt;UIWidget&gt;();</span><br><span class="line">UIPanel pc = (container == null &amp;&amp; <span class="built_in">wc</span> == null) ? null : container.GetComponent&lt;UIPanel&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">wc</span> != null)</span><br><span class="line">&#123;</span><br><span class="line">Bounds b = wc.CalculateBounds(container.transform.parent);</span><br><span class="line"></span><br><span class="line">mRect.x = b.min.x;</span><br><span class="line">mRect.y = b.min.y;</span><br><span class="line"></span><br><span class="line">mRect.width = b.size.x;</span><br><span class="line">mRect.height = b.size.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pc != null)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span> (pc.clipping == UIDrawCall.Clipping.None)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> ratio = (mRoot != null) ? (<span class="built_in">float</span>)mRoot.activeHeight / Screen.height : 0.5f;</span><br><span class="line">                mRect.xMin = -Screen.width * ratio * 0.5f + NGUITools.GetSafeArea().x * ratio;</span><br><span class="line">                mRect.yMin = -Screen.height * ratio * 0.5f + NGUITools.GetSafeArea().y * ratio;</span><br><span class="line">                mRect.xMax = mRect.xMin + NGUITools.GetSafeArea().width * ratio;</span><br><span class="line">                mRect.yMax = mRect.yMin+ NGUITools.GetSafeArea().height * ratio; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                // Panel has clipping -- use it as the mRect</span><br><span class="line">                Vector4 pos = pc.finalClipRegion;</span><br><span class="line">                mRect.x = pos.x - (pos.z * 0.5f);</span><br><span class="line">                mRect.y = pos.y - (pos.w * 0.5f);</span><br><span class="line">                mRect.width = pos.z;</span><br><span class="line">                mRect.height = pos.w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (container != null)</span><br><span class="line">&#123;</span><br><span class="line">Transform root = container.transform.parent;</span><br><span class="line">Bounds b = (root != null) ? NGUIMath.CalculateRelativeWidgetBounds(root, container.transform) :</span><br><span class="line">NGUIMath.CalculateRelativeWidgetBounds(container.transform);</span><br><span class="line"></span><br><span class="line">mRect.x = b.min.x;</span><br><span class="line">mRect.y = b.min.y;</span><br><span class="line"></span><br><span class="line">mRect.width = b.size.x;</span><br><span class="line">mRect.height = b.size.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (uiCamera != null)</span><br><span class="line">&#123;</span><br><span class="line">useCamera = <span class="literal">true</span>;</span><br><span class="line">mRect = uiCamera.pixelRect;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> cx = (mRect.xMin + mRect.xMax) * 0.5f;</span><br><span class="line"><span class="built_in">float</span> cy = (mRect.yMin + mRect.yMax) * 0.5f;</span><br><span class="line">Vector3 v = new Vector3(cx, cy, 0f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (side != Side.Center)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (side == Side.Right || side == Side.TopRight || side == Side.BottomRight) v.x = mRect.xMax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (side == Side.Top || side == Side.Center || side == Side.Bottom) v.x = cx;</span><br><span class="line"><span class="keyword">else</span> v.x = mRect.xMin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (side == Side.Top || side == Side.TopRight || side == Side.TopLeft) v.y = mRect.yMax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (side == Side.Left || side == Side.Center || side == Side.Right) v.y = cy;</span><br><span class="line"><span class="keyword">else</span> v.y = mRect.yMin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> width = mRect.width;</span><br><span class="line"><span class="built_in">float</span> height = mRect.height;</span><br><span class="line"></span><br><span class="line">v.x += pixelOffset.x + relativeOffset.x * width;</span><br><span class="line">v.y += pixelOffset.y + relativeOffset.y * height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (useCamera)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (uiCamera.orthographic)</span><br><span class="line">&#123;</span><br><span class="line">v.x = Mathf.Round(v.x);</span><br><span class="line">v.y = Mathf.Round(v.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.z = uiCamera.WorldToScreenPoint(mTrans.position).z;</span><br><span class="line">v = uiCamera.ScreenToWorldPoint(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v.x = Mathf.Round(v.x);</span><br><span class="line">v.y = Mathf.Round(v.y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pc != null)</span><br><span class="line">&#123;</span><br><span class="line">v = pc.cachedTransform.TransformPoint(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (container != null)</span><br><span class="line">&#123;</span><br><span class="line">Transform t = container.transform.parent;</span><br><span class="line"><span class="keyword">if</span> (t != null) v = t.TransformPoint(v);</span><br><span class="line">&#125;</span><br><span class="line">v.z = mTrans.position.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Wrapped <span class="keyword">in</span> an <span class="string">&#x27;if&#x27;</span> so the scene doesn<span class="string">&#x27;t get marked as &#x27;</span>edited<span class="string">&#x27; every frame</span></span><br><span class="line"><span class="string">#if UNITY_4_3 || UNITY_4_5 || UNITY_4_6 || UNITY_4_7</span></span><br><span class="line"><span class="string">if (useCamera &amp;&amp; uiCamera.isOrthoGraphic &amp;&amp; mTrans.parent != null)</span></span><br><span class="line"><span class="string">#else</span></span><br><span class="line"><span class="string">if (useCamera &amp;&amp; uiCamera.orthographic &amp;&amp; mTrans.parent != null)</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">v = mTrans.parent.InverseTransformPoint(v);</span></span><br><span class="line"><span class="string">v.x = Mathf.RoundToInt(v.x);</span></span><br><span class="line"><span class="string">v.y = Mathf.RoundToInt(v.y);</span></span><br><span class="line"><span class="string">if (mTrans.localPosition != v) mTrans.localPosition = v;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else if (mTrans.position != v) mTrans.position = v;</span></span><br><span class="line"><span class="string">if (runOnlyOnce &amp;&amp; Application.isPlaying) enabled = false;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>PS：如果是小游戏的话需要另外获取胶囊按钮的layout来修改safeArea的数据，用于适配被胶囊按钮遮住的UI</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NGUI界面SafeArea自适应&quot;&gt;&lt;a href=&quot;#NGUI界面SafeArea自适应&quot; class=&quot;headerlink&quot; title=&quot;NGUI界面SafeArea自适应&quot;&gt;&lt;/a&gt;NGUI界面SafeArea自适应&lt;/h1&gt;&lt;p&gt;主要需要修改的类有以</summary>
      
    
    
    
    
    <category term="unity优化" scheme="http://xuexuanfeng.github.io/tags/unity%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity游戏开发RTS框选单位功能</title>
    <link href="http://xuexuanfeng.github.io/2025/09/04/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91RTS%E6%A1%86%E9%80%89%E5%8D%95%E4%BD%8D%E5%8A%9F%E8%83%BD/"/>
    <id>http://xuexuanfeng.github.io/2025/09/04/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91RTS%E6%A1%86%E9%80%89%E5%8D%95%E4%BD%8D%E5%8A%9F%E8%83%BD/</id>
    <published>2025-09-04T15:08:32.000Z</published>
    <updated>2025-09-08T14:54:29.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity游戏开发RTS框选单位功能"><a href="#Unity游戏开发RTS框选单位功能" class="headerlink" title="Unity游戏开发RTS框选单位功能"></a>Unity游戏开发RTS框选单位功能</h1><pre><code>Unity RTS游戏中框选单位的功能实现主要分为两种实现方式1.LineRender2.UGUI的Image组件这两种方式各有优缺点，LineRender可以实时渲染，但是需要手动去控制LineRender的顶点位置，而Image组件则不需要，只需要设置好Image的锚点，然后设置好Image的宽高，就可以实现框选功能了，但是Image组件需要手动去控制Image的宽高，所以需要写一个脚本去控制Image的宽高，然后把Image的宽高赋值给RectTransform的宽高，这样就可以实现框选功能了。两者的原理是一样的，都是先记录鼠标按下时的坐标，然后每帧记录当前鼠标的坐标，通过两点计算Rect矩阵的信息，然后通过Camera.main.ScreenToWorldPoint(screenPoint)将屏幕坐标转换为世界坐标，有了这个关键数据就可以进行UI绘制了。下面主要说一下LineRender的部分代码：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//设置loop之后第四个点才会和第一个点重合</span><br><span class="line">lineRenderer.loop = <span class="literal">true</span>;           </span><br><span class="line">lineRenderer.material = lineMaterial;</span><br><span class="line">lineRenderer.startColor = lineColor;</span><br><span class="line">lineRenderer.endColor = lineColor;</span><br><span class="line">lineRenderer.startWidth = lineWidth;</span><br><span class="line">lineRenderer.endWidth = lineWidth;</span><br><span class="line">//这个比较重要，如果不设置成<span class="literal">true</span>，那么lineRenderer的顶点坐标会随着物体的移动而移动，如果设置成<span class="literal">true</span>，那么lineRenderer的顶点坐标就不会随着物体的移动而移动，而是保持不变。</span><br><span class="line">lineRenderer.useWorldSpace = <span class="literal">true</span>;  </span><br><span class="line">lineRenderer.positionCount = 4;</span><br><span class="line">lineRenderer.loop = <span class="literal">true</span>;</span><br><span class="line">lineRenderer.enabled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取屏幕空间中的框选区域</span><br><span class="line">Vector3[] corners = GetSelectionCorners(startMousePosition, currentMousePosition);</span><br><span class="line"></span><br><span class="line">// 将屏幕坐标转换为世界坐标</span><br><span class="line">Vector3[] worldCorners = new Vector3[4];</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">    worldCorners[i] = ScreenToWorldPoint(corners[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lineRenderer.SetPositions(worldCorners);</span><br></pre></td></tr></table></figure><pre><code>单位单选功能实现原理主要是在场景单位上添加一个Collider，挂载一个继承IPointerClickHandler的脚本，并且重写OnPointerClick方法，这里需要注意的是Camera必须挂载Physics Raycaster，否则OnPointerClick不会触发。</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public override void OnPointerClick(PointerEventData eventData)</span><br><span class="line">&#123;</span><br><span class="line">    base.OnPointerClick(eventData);</span><br><span class="line">    SetSelect(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>单位多选功能实现原理主要是通过自定义的事件系统派发事件，之前生成的rect信息作为参数，场景的Unit单位作为事件的接收者，然后通过事件接收者去判断是否在rect内，如果在rect内，就设置该单位为选中状态，否则取消选中状态。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity游戏开发RTS框选单位功能&quot;&gt;&lt;a href=&quot;#Unity游戏开发RTS框选单位功能&quot; class=&quot;headerlink&quot; title=&quot;Unity游戏开发RTS框选单位功能&quot;&gt;&lt;/a&gt;Unity游戏开发RTS框选单位功能&lt;/h1&gt;&lt;pre&gt;&lt;cod</summary>
      
    
    
    
    
    <category term="Unity RTS游戏功能开发" scheme="http://xuexuanfeng.github.io/tags/Unity-RTS%E6%B8%B8%E6%88%8F%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>双人游戏的分屏处理</title>
    <link href="http://xuexuanfeng.github.io/2025/07/04/%E5%8F%8C%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E5%B1%8F%E5%A4%84%E7%90%86/"/>
    <id>http://xuexuanfeng.github.io/2025/07/04/%E5%8F%8C%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E5%B1%8F%E5%A4%84%E7%90%86/</id>
    <published>2025-07-04T14:20:04.000Z</published>
    <updated>2025-07-04T15:38:03.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双人游戏的分屏处理"><a href="#双人游戏的分屏处理" class="headerlink" title="双人游戏的分屏处理"></a>双人游戏的分屏处理</h1><pre><code>类似于双人成行那种左右两边分屏的功能，可以使用两个摄像机，设置摄像机的viewport Rect来做。但是测下来，drawcall会成倍增加，貌似不是一个很好的解决方案。</code></pre><p><img src="/img/_20250704222449.png" alt="截图"></p><pre><code>尝试使用cinemachine,drawcall并不会减少。使用Split Screen Pro，drawcall会减少些，但是摄像机跟随在demo里面并没有很好的实现。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双人游戏的分屏处理&quot;&gt;&lt;a href=&quot;#双人游戏的分屏处理&quot; class=&quot;headerlink&quot; title=&quot;双人游戏的分屏处理&quot;&gt;&lt;/a&gt;双人游戏的分屏处理&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;类似于双人成行那种左右两边分屏的功能，可以使用两个摄像机，设置摄像机</summary>
      
    
    
    
    
    <category term="unity游戏功能开发" scheme="http://xuexuanfeng.github.io/tags/unity%E6%B8%B8%E6%88%8F%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2D游戏开发H2D技术</title>
    <link href="http://xuexuanfeng.github.io/2025/06/21/2D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91H2D%E6%8A%80%E6%9C%AF/"/>
    <id>http://xuexuanfeng.github.io/2025/06/21/2D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91H2D%E6%8A%80%E6%9C%AF/</id>
    <published>2025-06-21T03:16:53.000Z</published>
    <updated>2025-06-24T14:19:28.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><pre><code>最近有接触2D游戏初创，聊到了潜水员大夫以及八方旅人这类的2D游戏，说是用到了叫做H2D的技术，所以就稍微了解了一下，记录一下。</code></pre><ol><li>H2D核心技术构成</li></ol><ul><li>传统2D游戏使用静态精灵（Sprite），而H2D技术通过​​2D光源系统​​（如Unity URP的Freeform&#x2F;Sprite灯光）实现动态阴影、全局光照，增强场景层次感。例如，《空洞骑士》通过多层光源营造氛围。</li><li>​​后期处理效果​​（如景深、色彩校正）提升视觉表现，Unity的URP管线支持此类效果无需复杂编码。</li></ul><ol start="2"><li>骨骼动画与物理融合</li></ol><ul><li>角色动画采用​​骨骼绑定​​（如Unity的2D Animation工具），替代逐帧动画，节省资源并支持更流畅的动作。</li><li>物理引擎集成​​（如Box2D或Unity Rigidbody 2D）实现真实碰撞反馈，例如平台跳跃游戏中的角色与地面互动。</li></ul><ol start="3"><li>​​混合维度效果</li></ol><ul><li>2.5D透视​​：使用正交或倾斜投影（如等轴测视角），在2D平面模拟3D空间深度。《塞尔达传说：众神的三角量》是经典案例。</li><li>粒子系统与着色器​​：通过Shader Graph编写自定义着色器，实现水面折射、动态烟雾等效果，增强沉浸感。</li></ul><h2 id="2D场景的光照"><a href="#2D场景的光照" class="headerlink" title="2D场景的光照"></a>2D场景的光照</h2><ol><li><p>2D光照的设置</p><p> 原来2D光照需要packagemanager中install才能使用，现在已经集成在了universal rp中，Hierarcy右键Light-&gt;2D LIGHT，里面有各种2D光源。<br> 2D的默认材质是不受光照影响的，像默认渲染管线材质球转urp材质球那样，但是新版本我似乎找不到这个批量转换选项，只能选择材质球之后转换。目前看来只要是URP的项目，创建的2D对象都会使用Sprite-Lit-Default这个支持3D灯光的材质球。<br> 2D光源也支持normalmap，可以让2D物体有凹凸感，但是2D光源不支持阴影，所以需要配合3D光源使用。</p><p> 以下是批量转换脚本代码</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 文件名：TilemapMaterialConverter.cs</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">using UnityEditor;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class TilemapMaterialConverter</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(<span class="string">&quot;Tools/Batch Convert Tilemap Materials&quot;</span>)]</span><br><span class="line">    public static void <span class="function"><span class="title">ConvertMaterials</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        // 找到所有旧材质（根据您的原材质命名调整匹配规则）</span><br><span class="line">        string searchFilter = <span class="string">&quot;t:Material&quot;</span>;</span><br><span class="line">        string[] materialPaths = AssetDatabase.FindAssets(searchFilter);</span><br><span class="line"></span><br><span class="line">        int convertedCount = 0;</span><br><span class="line">        Shader targetShader = Shader.Find(<span class="string">&quot;Universal Render Pipeline/2D/Sprite-Lit-Default&quot;</span>);</span><br><span class="line"></span><br><span class="line">        foreach (string guid <span class="keyword">in</span> materialPaths)</span><br><span class="line">        &#123;</span><br><span class="line">            string path = AssetDatabase.GUIDToAssetPath(guid);</span><br><span class="line">            Material mat = AssetDatabase.LoadAssetAtPath&lt;Material&gt;(path);</span><br><span class="line"></span><br><span class="line">            // 仅转换特定条件的材质（调整过滤逻辑）</span><br><span class="line">            <span class="keyword">if</span> (mat.shader.name.Contains(<span class="string">&quot;Sprites/Default&quot;</span>) || </span><br><span class="line">                mat.shader.name.Contains(<span class="string">&quot;Sprites/Diffuse&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                mat.shader = targetShader;</span><br><span class="line">                EditorUtility.SetDirty(mat);</span><br><span class="line">                convertedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AssetDatabase.SaveAssets();</span><br><span class="line">        Debug.Log($<span class="string">&quot;转换完成！共转换了&#123;convertedCount&#125;个材质&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p><img src="/img/2DLIGHT_EXAMPLE.png" alt="截图"></p><ol start="2"><li>2D光源的性能</li></ol><ul><li>每个 ​​动态光源​​（如 Point Light 2D）会产生 ​​独立的光照贴图​</li><li>最终叠加到场景需进行 ​​Alpha 混合​​，消耗 GPU 带宽</li><li>典型场景：10 个动态光源 &#x3D; 10 次光照纹理绘制 + 1 次主场景绘制</li><li>每个激活的 ​​Light 2D​​ 会遍历其 ​​光照范围内的所有 Renderer​，物体数量越多，CPU 侧计算耗时越高</li></ul><ol start="3"><li>优化策略</li></ol><ul><li>减少动态光源数量​</li><li>使用烘焙光照​(虽然AI给出了烘培的方案，但是我并没有网上查到烘培相关的教程)</li><li>​​合并光源范围​<ol><li>多个相邻光源 → 替换为 ​​1 个覆盖更大区域的点光源​</li><li>或使用 ​​Sprite Mask + 单一光源​​ 模拟局部光照</li></ol></li><li>​​优化光源属性​<ol><li>启用 ​​Light Volume Intensity​​：近亮远暗，降低边缘计算</li><li>关闭不必要光源的 ​​Use Normal Maps​​（如背景光）</li></ol></li><li>材质层级优化​<ol><li>非交互背景​​：使用无光照材质（Sprite&#x2F;Unlit-Default）</li><li>​​动态物体​​：批量使用相同光照材质（减少 Shader 切换）</li></ol></li><li>移除或者禁用远处的额光源</li></ul><h2 id="2D-Animation工具"><a href="#2D-Animation工具" class="headerlink" title="2D Animation工具"></a>2D Animation工具</h2><pre><code>跟着教程跑了一边，大致了解一下，主要是PS源素材进行分层，保存PSB文件。导入unity中，素材图标会类似于FBX，而inspector面板是类似图片的选项，点击openSpriteEditor,打开如下面板</code></pre><p><img src="/img/2DANIMATION_EXAMPLE2.png" alt="截图"></p><pre><code>点击左上角切换skinning Editor，之后的流程就和blender差不多，就是创建骨骼，生成蒙皮，刷上权重，随后图片的顶点坐标就会随着骨骼的偏移而进行移动。完成2D骨骼的处理之后就可以添加animator，录制动画了。因为spine没有怎么用过，不好评论2D Animator和Spine哪个比较好用点，但是B站上有博主对比过，大致的意思就是spine的工作流比起unity来更加人性化、易操作。但是在我看来2D Animaton也是可以用的，避免了spine的学习投入成本。但是2D Animaton我并没有找到换装相关的功能，unity还有一个插件叫Character Creator 2D，可以用来制作2D角色动画以及支持换装。PS:2D Animation可以使用sprite library组件实现换装。换装教程https://www.bilibili.com/video/BV1ht4y177Ev/?spm_id_from=333.1391.0.0&amp;vd_source=757af868ca167689ee49a2bde553ef7f</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习记录&quot;&gt;&lt;a href=&quot;#学习记录&quot; class=&quot;headerlink&quot; title=&quot;学习记录&quot;&gt;&lt;/a&gt;学习记录&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;最近有接触2D游戏初创，聊到了潜水员大夫以及八方旅人这类的2D游戏，说是用到了叫做H2D的技术，所以就稍微了</summary>
      
    
    
    
    
    <category term="学习记录" scheme="http://xuexuanfeng.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>微信小游戏的转换遇到的一些问题</title>
    <link href="http://xuexuanfeng.github.io/2025/05/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://xuexuanfeng.github.io/2025/05/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2025-05-16T16:27:16.000Z</published>
    <updated>2025-05-16T16:39:20.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小游戏的转换遇到的一些问题"><a href="#微信小游戏的转换遇到的一些问题" class="headerlink" title="微信小游戏的转换遇到的一些问题"></a>微信小游戏的转换遇到的一些问题</h1><ol><li>抖音小游戏转换之后onApplicationPause不生效，需要改为抖音sdk提供的接口</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StarkSDK.API.GetStarkAppLifeCycle().OnHide += OnHideFun;</span><br><span class="line">StarkSDK.API.GetStarkAppLifeCycle().OnShowWithDict += OnShowWithDictFun;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>抖音小游戏PlayerPrefs获取本地缓存，当StarkFileSystemManager.IsDataMigrated()为false的时候重启应用之后会不生效，主要原因是抖音sdk过老，可以写死StarkFileSystemManager.IsDataMigrated为true或者直接调用StarkStorage接口，当然这也是有问题的，比如切换账号之后本地缓存也会丢失，最终方案是使用抖音自带的文件系统。</p></li><li><p>抖音侧边栏是必接入项</p></li><li><p>抖音小游戏没有内购的情况下可以不用接入客服</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小游戏的转换遇到的一些问题&quot;&gt;&lt;a href=&quot;#微信小游戏的转换遇到的一些问题&quot; class=&quot;headerlink&quot; title=&quot;微信小游戏的转换遇到的一些问题&quot;&gt;&lt;/a&gt;微信小游戏的转换遇到的一些问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;抖音小游戏转换之后onA</summary>
      
    
    
    
    
    <category term="Unity微信小游戏" scheme="http://xuexuanfeng.github.io/tags/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Unity资源网站</title>
    <link href="http://xuexuanfeng.github.io/2025/05/13/Unity%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/"/>
    <id>http://xuexuanfeng.github.io/2025/05/13/Unity%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/</id>
    <published>2025-05-13T14:28:45.000Z</published>
    <updated>2025-05-13T14:32:53.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity资源网站"><a href="#Unity资源网站" class="headerlink" title="Unity资源网站"></a>Unity资源网站</h1><h1 id="2DTilemap相关素材"><a href="#2DTilemap相关素材" class="headerlink" title="2DTilemap相关素材"></a>2DTilemap相关素材</h1><p><a href="https://itch.io/">https://itch.io/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity资源网站&quot;&gt;&lt;a href=&quot;#Unity资源网站&quot; class=&quot;headerlink&quot; title=&quot;Unity资源网站&quot;&gt;&lt;/a&gt;Unity资源网站&lt;/h1&gt;&lt;h1 id=&quot;2DTilemap相关素材&quot;&gt;&lt;a href=&quot;#2DTilemap相关素</summary>
      
    
    
    
    
    <category term="unity资源相关" scheme="http://xuexuanfeng.github.io/tags/unity%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>unity的插值计算</title>
    <link href="http://xuexuanfeng.github.io/2025/05/08/unity%E7%9A%84%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <id>http://xuexuanfeng.github.io/2025/05/08/unity%E7%9A%84%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97/</id>
    <published>2025-05-08T08:05:02.000Z</published>
    <updated>2025-05-08T08:19:20.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="unity的插值计算"><a href="#unity的插值计算" class="headerlink" title="unity的插值计算"></a>unity的插值计算</h1><h2 id="Mathf的插值运算API"><a href="#Mathf的插值运算API" class="headerlink" title="Mathf的插值运算API"></a>Mathf的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个浮点数之间的插值运算。</li><li>API：Mathf.Lerp(float a, float b, float t)</li><li>参数：a为起始值，b为结束值，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的插值结果。</li></ul></li></ul><p><img src="/img/202505081609.png" alt="截图"></p><p><img src="/img/MathfLerp.gif" alt="截图"></p><h2 id="Vector3的插值运算API"><a href="#Vector3的插值运算API" class="headerlink" title="Vector3的插值运算API"></a>Vector3的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个三维向量之间的线性插值运算。</li><li>API：Vector3.Lerp(Vector3 a, Vector3 b, float t)</li><li>参数：a为起始向量，b为结束向量，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的线性插值向量。</li><li>应用场景：常用于物体的位置移动、方向变化等线性过渡效果。</li></ul></li></ul><p><img src="/img/202505081613.png" alt="截图"></p><p><img src="/img/Vector3Lerp.gif" alt="截图"></p><p>Slerp方法：</p><ul><li>功能：实现两个三维向量之间的球形插值运算，即沿球面的大圆弧进行插值。<ul><li>API：Vector3.Slerp(Vector3 a, Vector3 b, float t)</li><li>参数：a为起始向量，b为结束向量，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的球形插值向量。</li><li>应用场景：常用于物体的平滑旋转、摄像机朝向变化等需要保持恒定角速度的插值效果。</li><li>相比线性插值Lerp将Vector3当作空间的点，球形插值Slerp则是将Vector3当作方向，返回的Vector3的长度是两点之前的距离插值，方向是两个向量之间的夹角度数的插值。游戏中主要的应用场景有角色或物体的曲线跳跃,武器或抛射物的弧形弹道。</li></ul></li></ul><p><img src="/img/202505081614.png" alt="截图"></p><p><img src="/img/Vector3SLerp.gif" alt="截图"></p><h2 id="Quaternion的插值运算API"><a href="#Quaternion的插值运算API" class="headerlink" title="Quaternion的插值运算API"></a>Quaternion的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个四元数之间的线性插值运算，用于旋转的线性过渡。</li><li>API及参数：与Vector3.Lerp类似，但操作对象为四元数。</li><li>返回值：根据插值因子返回两个四元数之间的线性插值结果。</li><li>应用场景：虽然可以用于旋转插值，但可能产生“万向节锁”问题，因此不如Slerp常用。</li></ul></li><li><p>Slerp方法：</p><ul><li>功能：实现两个四元数之间的球形插值运算，用于旋转的平滑过渡。</li><li>API：Quaternion.Slerp(Quaternion a, Quaternion b, float t)</li><li>参数：a为起始四元数，b为结束四元数，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的球形插值四元数。</li><li>应用场景：相机的平滑跟随与视角切换，角色的平滑转向，动画中的关节旋转过渡，UI 元素的动态旋转效果等等</li></ul></li></ul><p>Quaternion的插值分析及总结<br>Lerp求得的是四元数在圆上的弦上的等分，而Slerp求得的是四元数载圆上的圆弧的等分</p><p><img src="/img/202505081617.png" alt="截图"></p><p>从这张图可以看出lerp的运动轨迹是开始和结束慢，中间又比较快</p><p><img src="/img/202505081618.png" alt="截图"></p><p><img src="/img/QuaternionSlerp.gif" alt="截图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;unity的插值计算&quot;&gt;&lt;a href=&quot;#unity的插值计算&quot; class=&quot;headerlink&quot; title=&quot;unity的插值计算&quot;&gt;&lt;/a&gt;unity的插值计算&lt;/h1&gt;&lt;h2 id=&quot;Mathf的插值运算API&quot;&gt;&lt;a href=&quot;#Mathf的插值</summary>
      
    
    
    
    
    <category term="学习记录" scheme="http://xuexuanfeng.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Addressables小游戏改造</title>
    <link href="http://xuexuanfeng.github.io/2025/05/08/Addressables%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%94%B9%E9%80%A0/"/>
    <id>http://xuexuanfeng.github.io/2025/05/08/Addressables%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%94%B9%E9%80%A0/</id>
    <published>2025-05-08T02:14:00.000Z</published>
    <updated>2025-05-08T02:49:50.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Addressables小游戏改造"><a href="#Addressables小游戏改造" class="headerlink" title="Addressables小游戏改造"></a>Addressables小游戏改造</h1><ol><li><p>安装addressables的package</p></li><li><p>打开Addressables Groups，这里遇到几个问题，我发现直接把Resource目录的Addressable勾上，他Resource目录中的资源并不会移出包体</p></li></ol><p><img src="/img/202405081038.png" alt="截图"></p><p><img src="/img/202405081038_1.png" alt="截图"></p><p>&emsp;&emsp;只有当勾选resource内部的时候才会有移出资源的提示，所以不能直接偷懒这么做。</p><ol start="3"><li>导出路径可以选择Remote</li></ol><p><img src="/img/202505081041.png" alt="截图"></p><p>&emsp;&emsp;打开Manage Profiles修改LoadPath路径</p><p><img src="/img/202505081042.png" alt="截图"></p><ol start="4"><li>打包的时候如果Bundle Mode选择Pack Together的话单个Group的资源会打成一个bundle，这样会产生一些无用资源的加载浪费，所以我的解决办法是一个类型文件一个Group，然后Bundle Mode选择Pack Separately，这样一个文件打成一个bundle。个人测下来Pack Separately的打包逻辑是当前目录下的所有子对象都自成一个bundle，并不是目录下的所有资源都打成单独的bundle，比方说目录A勾选addressables,然后目录A里面又有目录B,C,D，打包的资源在第三层目录结构下，如果这时候build，他会生成三个bundle，分别代表目录B,C,D。所以正确的做法是目录B,C,D勾选为addressables，而不是勾选目录A。</li></ol><p><img src="/img/202505081043.png" alt="截图"></p><ol start="5"><li>加载资源使用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;GameObject&gt; handle = Addressables.LoadAssetAsync&lt;GameObject&gt;(<span class="string">&quot;Name&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>加载场景使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;SceneInstance&gt; sceneHandle = Addressables.LoadSceneAsync(<span class="string">&quot;Assets/Scenes/Level1.unity&quot;</span>, LoadSceneMode.Additive);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还可以通过SceneInstance控制场景的激活和加载进度</p><p><img src="/img/202505081045.png" alt="截图"></p><ol start="6"><li>最后就是将同步加载结构改为异步加载API的枯燥过程了</li></ol><p>PS：这里有几点需要注意，刚开始从together切换成Pack Separately后打出来的包还是一整个，清理下缓存恢复正常，建议每次build之前都清理一下。</p><p><img src="/img/202505081046.png" alt="截图"></p><p>PS: 使用服务器下载bundle的方式测试会报错</p><p><img src="/img/202505081047.png" alt="截图"></p><p>经检查服务器地址和端口都没有问题，但是断点进去看了之后发现最终的请求地址端口为字符串HostingServicePort。Clear和Update之后能够正常访问。</p><p><img src="/img/202505081047_1.png" alt="截图"></p><p><img src="/img/202505081048_1.png" alt="截图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Addressables小游戏改造&quot;&gt;&lt;a href=&quot;#Addressables小游戏改造&quot; class=&quot;headerlink&quot; title=&quot;Addressables小游戏改造&quot;&gt;&lt;/a&gt;Addressables小游戏改造&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安</summary>
      
    
    
    
    
    <category term="Unity微信小游戏" scheme="http://xuexuanfeng.github.io/tags/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>worldstreamer的Terrain分割原理</title>
    <link href="http://xuexuanfeng.github.io/2025/04/24/worldstreamer%E7%9A%84Terrain%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86/"/>
    <id>http://xuexuanfeng.github.io/2025/04/24/worldstreamer%E7%9A%84Terrain%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86/</id>
    <published>2025-04-24T14:43:26.000Z</published>
    <updated>2025-04-24T15:09:25.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="worldstreamer的Terrain分割原理"><a href="#worldstreamer的Terrain分割原理" class="headerlink" title="worldstreamer的Terrain分割原理"></a>worldstreamer的Terrain分割原理</h1><p>SplitTerrain 函数的逻辑主要是将选定的地形（Terrain）进行分割，并将每个分割后的地形保存为独立的地形对象。以下是该函数的主要步骤和逻辑：</p><ol><li><p>创建目录：首先检查是否存在用于存储分割地形的目录，如果不存在则创建该目录。</p></li><li><p><strong>开始撤销组</strong>：使用 <code>Undo.SetCurrentGroupName</code> 开始一个撤销操作组，以便在用户需要撤销操作时能够恢复到之前的状态。</p></li><li><p><strong>设置分割数量</strong>：根据 <code>splitSize</code> 属性计算出将要创建的地形数量。</p></li><li><p><strong>获取选定的地形</strong>：根据用户的选择获取当前选定的地形，如果 <code>allTerrains</code> 为真，则获取所有活动的地形。</p></li><li><p><strong>遍历每个地形</strong>：对于每个选定的地形，执行以下操作：</p><ul><li><p><strong>创建新地形</strong>：根据分割数量创建新的地形数据和地形对象(Terrain.CreateTerrainGameObject这个接口可以想创建Gameobject一样直接在场景上面放一个terrain)。</p></li><li><p><strong>复制地形原型</strong>：将原始地形的所有原型（如树木、细节等）复制到新地形中。</p></li><li><p><strong>设置地形属性</strong>：调用 <code>SetTerrainSettings</code> 函数来设置新地形的各种属性。</p></li><li><p><strong>分割高度图</strong>：根据分割的大小，从原始地形的高度图中提取相应的部分并设置到新地形中。</p></li><li><p><strong>分割孔数据</strong>：同样处理地形的孔数据（如空洞）。</p></li><li><p><strong>分割纹理数据</strong>：处理地形的纹理数据，将其分割并设置到新地形中。</p></li><li><p><strong>分割细节数据</strong>：处理地形的细节数据（如草、灌木等），将其分割并设置到新地形中。</p></li><li><p><strong>处理树木实例</strong>：遍历原始地形的树木实例，将其位置调整并添加到新地形中。</p></li><li><p><strong>设置新地形的位置</strong>：根据原始地形的位置调整新地形的位置。</p></li></ul></li><li><p><strong>结束撤销组</strong>：在所有操作完成后，结束撤销操作组。</p></li><li><p><strong>清理进度条</strong>：在操作完成后，清理进度条。</p></li></ol><p>通过这些步骤，<code>SplitTerrain</code> 函数能够将一个大的地形分割成多个小的地形，便于管理和使用。每个新地形都保留了原始地形的特性和数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;worldstreamer的Terrain分割原理&quot;&gt;&lt;a href=&quot;#worldstreamer的Terrain分割原理&quot; class=&quot;headerlink&quot; title=&quot;worldstreamer的Terrain分割原理&quot;&gt;&lt;/a&gt;worldstream</summary>
      
    
    
    
    
    <category term="worldstreamer的Terrain分割原理" scheme="http://xuexuanfeng.github.io/tags/worldstreamer%E7%9A%84Terrain%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>unity中Sprite和Image的区别</title>
    <link href="http://xuexuanfeng.github.io/2025/04/23/unity%E4%B8%ADSprite%E5%92%8CImage%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://xuexuanfeng.github.io/2025/04/23/unity%E4%B8%ADSprite%E5%92%8CImage%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-04-23T09:34:10.000Z</published>
    <updated>2025-04-23T09:42:47.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="unity中Sprite和Image的区别"><a href="#unity中Sprite和Image的区别" class="headerlink" title="unity中Sprite和Image的区别"></a>unity中Sprite和Image的区别</h1><ol><li><p>渲染上</p><ul><li>Image 通过UGUI的Image和CanvasRenderer组件组件来渲染；</li><li>Sprite 通过SpriteRenderer组件来渲染；</li><li>两者在视觉上没有任何区别（都使用默认材质时）。它们默认的渲染也都是在Transparent Geometry队列中。</li></ul></li><li><p>原理上：</p><ul><li>GPU接收到DrawCall指令后，通过一系列流程生成最终要显示的内容并进行渲染，其中大致的步骤包括：<ul><li>CPU发送Draw Call指令给GPU；</li><li>GPU读取必要的数据到自己的显存；</li><li>GPU通过顶点着色器（vertex shader）等步骤将输入的几何体信息转化为像素点数据；</li><li>每个像素都通过片段着色器（fragment shader）处理后写入帧缓存(显存)；</li><li>当全部计算完成后，GPU将帧缓存内容显示在屏幕上。</li></ul></li><li>通过上面的认知，我们可以推断：<ul><li>Sprite由于顶点数据更加复杂，进行顶点计算时在第1、2步会比Image效率更低；</li><li>Sprite会比Image执行较多的顶点着色器运算；</li><li>Image会比Sprite执行更多的片段着色器运算；</li></ul></li></ul></li><li><p>使用上：</p><ul><li>Hierarchy窗口,可以把sprite随便放在哪，通过Transform移动其它游戏物体那样移动sprite； Image必须放在Canvas下面, 且只能通过RectTransform在UI界面中移动；</li><li>sprite和Image的一个最重要的区别在于sprite支持网格的自动构造，而UI Image的网格始终由矩形构成;SpriteRenderer会创建额外的几何体来裁剪掉多余的透明像素区域，从而减少了大量的片段着色器运算，并降低了overdraw。SpriteRenderer确实是经过优化以显示更多的元素的。所以在2D游戏开发中，游戏场景中的元素，应该尽量使用它去渲染，尤其时复杂的几何图像；</li><li>Image仅用于UI显示；</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;unity中Sprite和Image的区别&quot;&gt;&lt;a href=&quot;#unity中Sprite和Image的区别&quot; class=&quot;headerlink&quot; title=&quot;unity中Sprite和Image的区别&quot;&gt;&lt;/a&gt;unity中Sprite和Image的区别&lt;/</summary>
      
    
    
    
    
    <category term="unity优化" scheme="http://xuexuanfeng.github.io/tags/unity%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>设计模式的应用场景</title>
    <link href="http://xuexuanfeng.github.io/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://xuexuanfeng.github.io/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2025-04-18T03:17:58.000Z</published>
    <updated>2025-04-18T03:58:14.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、创建型模式（封装对象的创建）"><a href="#一、创建型模式（封装对象的创建）" class="headerlink" title="一、创建型模式（封装对象的创建）"></a>一、创建型模式（封装对象的创建）</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>需要全局唯一实例（如日志管理器、配置中心、数据库连接池）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singleton </span><br><span class="line">&#123; </span><br><span class="line">    private static Singleton _instance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>创建对象时需依赖子类决定具体类型（如不同数据库驱动、UI 控件的动态生成）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Creator </span><br><span class="line">&#123; </span><br><span class="line">    public abstract IProduct FactoryMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>创建一组相关或依赖的对象（如跨平台 UI 组件库：Windows&#x2F;Mac 的按钮、文本框）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IGUIFactory </span><br><span class="line">&#123; </span><br><span class="line">    IButton CreateButton(); </span><br><span class="line">    ITextBox CreateTextBox(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>分步骤构建复杂对象（如生成 XML&#x2F;JSON 文档、配置 HTTP 请求头）。</p><p>StringBuilder 类的链式调用</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>通过克隆已有对象创建新对象，避免重复初始化（如游戏中的敌人复制、配置模板）。</p><p>实现 ICloneable 接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public object <span class="function"><span class="title">Clone</span></span>() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">return</span> MemberwiseClone(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、结构型模式（处理对象间的组合关系）"><a href="#二、结构型模式（处理对象间的组合关系）" class="headerlink" title="二、结构型模式（处理对象间的组合关系）"></a>二、结构型模式（处理对象间的组合关系）</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将不兼容接口转换为客户端期望的接口（如旧系统接口适配新框架）。</p><p>包装第三方库的类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LegacyAdapter : INewInterface </span><br><span class="line">&#123; </span><br><span class="line">    private Legacy _legacy; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>分离抽象与实现，支持多维变化（如不同图形渲染API：OpenGL&#x2F;DirectX）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Shape</span><br><span class="line">&#123; </span><br><span class="line">    protected IRenderer _renderer; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>处理树形结构（如文件系统、UI 控件嵌套）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IComponent </span><br><span class="line">&#123; </span><br><span class="line">    void Add(IComponent component); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>动态添加功能（如日志记录、缓存、权限校验的链式扩展）</p><p>Stream 类的装饰器：BufferedStream, CryptoStream</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>简化复杂子系统调用（如封装支付流程：验证、扣款、通知）。</p><p>提供统一入口类：PaymentFacade.ProcessPayment(order)。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>共享大量细粒度对象（如字符格式复用、游戏中的粒子系统）。</p><p>String.Intern() 方法复用字符串常量</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>控制对象访问（如延迟加载、远程调用、权限验证）。</p><p>Lazy<T> 类实现延迟加载，WCF 的客户端代理。</p><h1 id="三、行为型模式（管理对象间的交互）"><a href="#三、行为型模式（管理对象间的交互）" class="headerlink" title="三、行为型模式（管理对象间的交互）"></a>三、行为型模式（管理对象间的交互）</h1><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>多个对象依次处理请求（如审批流程、异常处理过滤器）。</p><p>ASP.NET Core 中间件管道：app.UseMiddleware<LoggingMiddleware>()。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>封装请求为对象（如撤销&#x2F;重做操作、任务队列）。</p><p>WPF 的 ICommand 接口：RelayCommand。</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>定义语法规则并解释执行（如正则表达式、SQL解析）。</p><p>正则表达式引擎 System.Text.RegularExpressions</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>遍历集合元素（如自定义集合的遍历逻辑）。</p><p>实现 IEnumerable<T> 和 IEnumerator<T> 接口。</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>减少对象间直接耦合（如聊天室消息转发、UI控件交互）。</p><p>使用 MediatR 库实现事件调度。</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>保存和恢复对象状态（如游戏存档、事务回滚）。</p><p>序列化对象到文件或数据库。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>一对多依赖通知（如事件发布-订阅、数据绑定）。</p><p>C# 的 event 关键字和 IObservable<T>&#x2F;IObserver<T> 接口。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>对象行为随状态改变（如订单状态流转、游戏角色行为切换）。</p><p>定义状态接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState </span><br><span class="line">&#123; </span><br><span class="line">    void Handle(Context context); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>动态切换算法（如排序算法选择、支付方式切换）。</p><p>依赖注入中的不同服务实现：services.AddScoped&lt;IPaymentStrategy, AlipayStrategy&gt;()。</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>定义算法骨架，子类实现步骤（如工作流引擎、数据导入流程）</p><p>抽象类定义流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class DataImporter </span><br><span class="line">&#123; </span><br><span class="line">    public void <span class="function"><span class="title">Import</span></span>() </span><br><span class="line">    &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>分离数据结构与操作（如AST树解析、报表生成）。</p><p>实现 IVisitor 接口遍历复杂对象结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、创建型模式（封装对象的创建）&quot;&gt;&lt;a href=&quot;#一、创建型模式（封装对象的创建）&quot; class=&quot;headerlink&quot; title=&quot;一、创建型模式（封装对象的创建）&quot;&gt;&lt;/a&gt;一、创建型模式（封装对象的创建）&lt;/h1&gt;&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="架构设计" scheme="http://xuexuanfeng.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Unity场景物体贴地操作</title>
    <link href="http://xuexuanfeng.github.io/2025/03/19/Unity%E5%9C%BA%E6%99%AF%E7%89%A9%E4%BD%93%E8%B4%B4%E5%9C%B0%E6%93%8D%E4%BD%9C/"/>
    <id>http://xuexuanfeng.github.io/2025/03/19/Unity%E5%9C%BA%E6%99%AF%E7%89%A9%E4%BD%93%E8%B4%B4%E5%9C%B0%E6%93%8D%E4%BD%9C/</id>
    <published>2025-03-19T07:50:24.000Z</published>
    <updated>2025-03-19T07:54:26.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity场景物体贴地操作"><a href="#Unity场景物体贴地操作" class="headerlink" title="Unity场景物体贴地操作"></a>Unity场景物体贴地操作</h1><p>以前会专门为底边开发一个物体贴地的工具，但unity其实编辑器内原生自带了这个功能，选中物体按下Ctrl+Shift,场景物体中间会出现一个灰色的小方框，拖动物体编辑器就会自动处理贴地的效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity场景物体贴地操作&quot;&gt;&lt;a href=&quot;#Unity场景物体贴地操作&quot; class=&quot;headerlink&quot; title=&quot;Unity场景物体贴地操作&quot;&gt;&lt;/a&gt;Unity场景物体贴地操作&lt;/h1&gt;&lt;p&gt;以前会专门为底边开发一个物体贴地的工具，但unity</summary>
      
    
    
    
    
    <category term="UnityEditor小技巧" scheme="http://xuexuanfeng.github.io/tags/UnityEditor%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>微信小游戏反编译</title>
    <link href="http://xuexuanfeng.github.io/2025/03/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://xuexuanfeng.github.io/2025/03/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%8F%8D%E7%BC%96%E8%AF%91/</id>
    <published>2025-03-17T13:58:36.000Z</published>
    <updated>2025-03-17T15:19:31.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小游戏反编译"><a href="#微信小游戏反编译" class="headerlink" title="微信小游戏反编译"></a>微信小游戏反编译</h1><p><a href="https://www.cnblogs.com/thebeastofwar/p/17611201.html">参考文献</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>注册开发者工具+申请小游戏类目</li></ol><p>不能用微信开发者工具自带的测试者账号，有一些小程序需要调用你的token</p><p><a href="https://developers.weixin.qq.com/">https://developers.weixin.qq.com/</a></p><ol start="2"><li>安装并下载反编译软件</li></ol><p><a href="https://www.cnblogs.com/thebeastofwar/p/17611201.html">https://www.cnblogs.com/thebeastofwar/p/17611201.html</a></p><ol><li><p>wxappUnpacker-master</p><p> <a href="../../file/wxappUnpacker-master.zip">下载文件</a></p></li><li><p>UnpackMiniApp</p><p> <a href="../../file/UnpackMiniApp.zip">下载文件</a></p></li></ol><h1 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h1><ol><li>反编译小游戏</li></ol><p>在windows上的微信中打开并加载小游戏</p><p>找到小游戏的下载目录WeChatFiles\Applet,有两个包</p><p>找到游戏主包(unity转换的游戏包含_WITHOUT_MULTI_PLUGINCODE_.wxapkg),另一个自爆里面包含的是插件包，不用管</p><p>不要移动这几个包的位置，直接双击运行UnpackMiniApp.exe,选择加密小程序包</p><p>选择一个包(每次选择一个)</p><p>解密成功后，报的位置位于UnpackMiniApp.exe统计目录的wxpack目录下，由于每次解密后的包名相同，需要给解密后的包重命名，以防被覆盖</p><p>在依次解密_wasmcode_.wxapkg和_wasmcode1_.wxapkg这两个包,都重命名，得到如下三个解密的包</p><p>在使用wxappUnpacker-master这个工具，主要用到的是wuWxapkg.jg这个解包脚本和wuJs.js这个分包脚本</p><p>安装node.js，运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node .\wuWxapkg.js E:\tools\wxpack\main.wxapkg <span class="comment"># 加入路径</span></span><br></pre></td></tr></table></figure><p>解压成功</p><p>在依次解压pkg1.wxapkg和pkg2.wxapkg,得到两个文件夹</p><ol start="2"><li>导入小游戏</li></ol><ul><li><p>打开微信开发者工具-&gt;微信小游戏-&gt;import</p></li><li><p>选择项目路径-&gt;设置提前申请好的小游戏类目appid</p></li><li><p>点击create</p></li></ul><ol start="3"><li>项目设置(本地设置Local setting)</li></ol><p>首先检查微信开发者工具的相关设置</p><ul><li>确保这几项设置正确勾选(新人并运行，将JS编译成ES5,不校验合法域名)</li></ul><ol start="4"><li>Subpackages添加和配置删除</li></ol><p>根据主目录game.json中的subpackages配置，添加我们反编译的子包,并删除不存在的子包配置</p><ol start="5"><li>引擎配置问题</li></ol><p>详情查看<a href="#question3">常见问题3</a></p><p>修改game.json中的gamePlugins-&gt;plugins</p><ol start="6"><li>报错:VM2_INTERNAL_STATE_DONOT_USE_OR_PROGRAM_WILL_FAIL</li></ol><p>VM2_INTERNAL_STATE_DONOT_USE_OR_PROGRAM_WILL_FAIL undefined</p><p>在game.js中添加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL = &#123;</span><br><span class="line">  handleException: (e) =&gt; &#123;</span><br><span class="line">    console.warn(e);</span><br><span class="line">    <span class="built_in">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="7"><li>删除game.js报错(常出现在subpackages中)</li></ol><p>可能会有显示(console)和隐式(非debug模式下无法运行但没有log)的错误，导致微信开发者工具内无法显示游戏页面，通常需要对main包之外的包中game.js进行如下define和require的处理:</p><p><img src="/img/fa37821da338f520c2579457435214b.jpg" alt="图标"></p><p>例如在这个额外导入的wasmcode1包中，需要将外层注释。</p><p>建议对所有包进行预处理，避免host中可能的require错误（尽管此错误不会影响游戏运行）</p><ol start="8"><li>Mock Login</li></ol><p>详情查看<a href="#loginpipline">微信登陆服务模拟搭建流程</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><h2 id="question3">常见问题</h2></h2><ol><li>PARAMOUNT</li></ol><p>首先检查微信开发者工具的相关设置</p><ul><li>确保这几项设置正确勾选（信任并运行，将JS编译成ES5，不校验合法域名）</li></ul><ol start="2"><li>*&#x2F;game.js预处理</li></ol><p>可能会有显示(console)和隐式(非debug模式下无法运行但没有log)的错误，导致微信开发者工具内无法显示游戏页面，通常需要对main包之外的包中game.js进行如下define和require的处理:</p><p><img src="/img/fa37821da338f520c2579457435214b.jpg" alt="图标"></p><p>例如在这个额外导入的wasmcode1包中，需要将外层注释。</p><p>建议对所有包进行预处理，避免host中可能的require错误（尽管此错误不会影响游戏运行）</p><ol start="3"><li>引擎引用问题</li></ol><p>修改game.json中的gamePlugins-&gt;plugins</p><h3 id="UnityPlugin问题"><a href="#UnityPlugin问题" class="headerlink" title="UnityPlugin问题"></a>UnityPlugin问题</h3><p>在unity引擎的游戏中，需要通过微信账号导入能力地图-开发提效包-快适配，并将game.json中的gamePlugins改为plugins。一般情况下,游戏可以正常运行。</p><p>如果遇到无法运行的情况，可以留意plugins下UnityPlugin的版本。</p><p>实测1.2.38会遇到微信开发这工具中无法正确获取插件的情况。可以在此处将版本更新后在启动游戏。</p><p>建议将版本更新到1.2.54,与unity-wx-to-webgl-host转换包中的版本相对应。</p><h3 id="cocos的requirePlugin"><a href="#cocos的requirePlugin" class="headerlink" title="cocos的requirePlugin"></a>cocos的requirePlugin</h3><p>有游戏会将Cocos作为gamePlugin卸载game.json中，main&#x2F;app目录下的cocos目录里缺少cocos2d-js-min.js文件。此时游戏不会正常加载，亦不会有明显报错。需要做出一下改动：</p><ul><li><p>删除game.json下的cocos plugin定义</p></li><li><p>从网上或过往的项目里扒一个对应版本的cocos2d-js-min.js,黏贴到cocos目录下</p></li><li><p>修改game.js的</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirePlugin(<span class="string">&quot;cocos&quot;</span>);</span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">&quot;cocos/cocos2d-js-min.js&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Laya引擎处理方式"><a href="#Laya引擎处理方式" class="headerlink" title="Laya引擎处理方式"></a>Laya引擎处理方式</h3><p>同上</p><ol start="4"><li>快速hook login</li></ol><p>在game.js中添加如下代码，将url替换成本游戏的登陆密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var orgR = wx.request;</span><br><span class="line">wx.request = (obj) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.url.indexOf(<span class="string">&#x27;weixingamelogin.php?jscode=&#x27;</span>) &gt; -1) &#123;</span><br><span class="line">        debugger</span><br><span class="line">        console.log(<span class="string">&quot;获得的obj为:&quot;</span>, obj);</span><br><span class="line">        obj.url = <span class="string">&#x27;https://bd11-rel.52playgame.com&#x27;</span> + </span><br><span class="line">        <span class="string">&#x27;/gmsys/weblogic/webc/weixingamelogin.php?jscode=0e3FP5ll2xbd7e4xLPkl25sgD40FP5l1&amp;group=1&amp;systematic=3&amp;encrypteddata=undefined&amp;iv=undefined&amp;os=Windows%2011%20x64&amp;model=microsoft&amp;toutiao_cluetoken=&amp;toutiao_create_id=&amp;toutiao_ad_id=&amp;guangdiantong_minigamechannel=&amp;guangdiantong_clickid=&amp;weixinadinfo=&amp;xingtu_callback=&amp;chuanshanjia_cluetoken=&amp;baidu_bd_vid=&amp;baidu_ext_info=&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> orgR(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>加解密</li></ol><p>遇到类似  “sign1”:”OTAyMTY1M3d4NjEzMjEyZTNkNDk3ZWVkOTE3MjcyNTAxMTE&#x3D;” 的值，可以尝试用 base64解码，可能可以获取wxid和timestamp</p><p><a href="https://www.sojson.com/base64.html">https://www.sojson.com/base64.html</a></p><ol start="6"><li>[“workers”]字段需要为目录</li></ol><p>在目录下找打了workers.js的文件</p><p><img src="/img/5ab912ead2e88e55b3bdca157bb6f6a.jpg" alt="图标"></p><p>需要用wxappUnpacker-master这个工具中的wuJs.js进行分包，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node .\wuJs.js E:\tools\wxpack\main\workers.js</span><br></pre></td></tr></table></figure><p>分包成功,得到worker&#x2F;response&#x2F;index.js</p><ol start="7"><li>Unity plugin加载 data-package失败</li></ol><p>在获取游戏是，目录中没有_data-package_.wxapkg这个包。在微信开发者工具中手动创建data-package目录后，在console中遇到如下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PLUGIN ERROR 16:58.17.613]  解压资源失败, 加载方式: 分包, errMsg:  readCompressedFile:fail data-package/830ce1e8f65310db.webgl.data.unityweb.bin.br not found(<span class="built_in">env</span>: Windows,mg,1.06.2405020; lib: development)</span><br></pre></td></tr></table></figure><p>发现在data-package目录下，加载游戏分包时，并没有得到 830ce1e8f65310db.webgl.data.unityweb.bin.br 这个文件这种情况可能是在加载游戏的时候，data package 缓存到了用户的本地目录WeChat Files&lt;用户的hash码&gt;\Applet&lt;游戏的码&gt;\usr（如：WeChat Files\wxid_hq52a973p00x22\Applet\wxfc5347dec6075f3a\usr）下面解决方法：把WeChat Files&lt;用户的hash码&gt;\Applet\下的缓存文件全部删掉，并且把WeChat Files\Applet\下面的游戏缓存全部删掉，重新打开并加载游戏有可能会在游戏的文件中得到 <em>data-package</em>.wxapkg 文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小游戏反编译&quot;&gt;&lt;a href=&quot;#微信小游戏反编译&quot; class=&quot;headerlink&quot; title=&quot;微信小游戏反编译&quot;&gt;&lt;/a&gt;微信小游戏反编译&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/thebeastofwar</summary>
      
    
    
    
    
    <category term="Unity微信小游戏" scheme="http://xuexuanfeng.github.io/tags/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>FPS游戏武器被墙体遮挡的问题</title>
    <link href="http://xuexuanfeng.github.io/2025/03/11/FPS%E6%B8%B8%E6%88%8F%E6%AD%A6%E5%99%A8%E8%A2%AB%E5%A2%99%E4%BD%93%E9%81%AE%E6%8C%A1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://xuexuanfeng.github.io/2025/03/11/FPS%E6%B8%B8%E6%88%8F%E6%AD%A6%E5%99%A8%E8%A2%AB%E5%A2%99%E4%BD%93%E9%81%AE%E6%8C%A1%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2025-03-11T10:05:55.000Z</published>
    <updated>2025-03-11T10:11:12.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FPS游戏武器被墙体遮挡的问题"><a href="#FPS游戏武器被墙体遮挡的问题" class="headerlink" title="FPS游戏武器被墙体遮挡的问题"></a>FPS游戏武器被墙体遮挡的问题</h1><p>&emsp;&emsp;在FPS游戏中武器经常会因为摄像机透视视角的原因导致被游戏中的某些环境遮挡，有些游戏会要求武器永远被渲染在屏幕中不会被遮挡，这时候可以使用单独的一个相机设置culling mask来渲染武器这个层</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FPS游戏武器被墙体遮挡的问题&quot;&gt;&lt;a href=&quot;#FPS游戏武器被墙体遮挡的问题&quot; class=&quot;headerlink&quot; title=&quot;FPS游戏武器被墙体遮挡的问题&quot;&gt;&lt;/a&gt;FPS游戏武器被墙体遮挡的问题&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在FPS游戏</summary>
      
    
    
    
    
    <category term="unity优化" scheme="http://xuexuanfeng.github.io/tags/unity%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>架构设计</title>
    <link href="http://xuexuanfeng.github.io/2025/02/04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xuexuanfeng.github.io/2025/02/04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2025-02-04T07:01:41.000Z</published>
    <updated>2025-02-04T07:41:59.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><pre><code>架构设计的理论框架</code></pre><h2 id="三种需要架构的情景"><a href="#三种需要架构的情景" class="headerlink" title="三种需要架构的情景"></a>三种需要架构的情景</h2><ol><li><p>一个系统，构成复杂，需要多个子系统协同以实现系统目标</p></li><li><p>一个系统，他由多个功能相似的模块构成，模块内的功能重复度很高，且容易出错。</p></li><li><p>一个系统，规模太大，需要多人协作完成，需要保证多人协作的效率和稳定性。</p></li></ol><h2 id="三种架构设计的思维"><a href="#三种架构设计的思维" class="headerlink" title="三种架构设计的思维"></a>三种架构设计的思维</h2><ol><li><p>分层思维</p></li><li><p>分治思维</p></li><li><p>演化思维</p></li></ol><h2 id="架构设计时的考量点"><a href="#架构设计时的考量点" class="headerlink" title="架构设计时的考量点"></a>架构设计时的考量点</h2><ul><li><p>游戏引擎的选择</p></li><li><p>UI的事件系统</p></li><li><p>AI行为算法</p></li><li><p>数据如何获取和存储</p></li><li><p>场景如何拆分</p></li><li><p>是否需要将资源分离出去</p></li><li><p>长连接短连接的选择</p></li><li><p>服务器语言的选择</p></li><li><p>使用关系型数据库还是加入cache机制</p></li><li><p>网络协议是protobuf，json，xml的选择</p></li></ul><h2 id="架构的五种能力"><a href="#架构的五种能力" class="headerlink" title="架构的五种能力"></a>架构的五种能力</h2><ol><li><p>承载力</p></li><li><p>可扩展性</p></li><li><p>易用性</p></li><li><p>可伸缩力</p></li><li><p>容错力以及错误的感知力</p></li></ol><h2 id="基本的架构思维"><a href="#基本的架构思维" class="headerlink" title="基本的架构思维"></a>基本的架构思维</h2><ul><li><p>算法和数据结构</p></li><li><p>软件工程</p></li><li><p>面向对象程序设计</p></li><li><p>抽象：分层、分治、演化</p></li></ul><h2 id="前端架构的思考点"><a href="#前端架构的思考点" class="headerlink" title="前端架构的思考点"></a>前端架构的思考点</h2><ol><li>用户体验</li></ol><ul><li><p>如何让游戏加载更快</p></li><li><p>如何制作更绚丽的特效</p></li><li><p>如何减少DrawCall</p></li><li><p>如何减少CPU的负载</p></li><li><p>如何最快的响应用户的操作</p></li><li><p>如何适应更多的手机</p></li></ul><ol start="2"><li><p>操作系统</p></li><li><p>游戏引擎</p></li><li><p>应用层框架</p></li><li><p>业务逻辑</p></li></ol><h2 id="UI前端框架的技术栈"><a href="#UI前端框架的技术栈" class="headerlink" title="UI前端框架的技术栈"></a>UI前端框架的技术栈</h2><ol><li><p>UI框架</p></li><li><p>主要逻辑框架</p></li></ol><ul><li><p>编辑器</p></li><li><p>角色行为框架</p></li><li><p>AI框架</p></li><li><p>地图场景与寻路框架</p></li><li><p>Shader与特效</p></li><li><p>设备平台</p></li></ul><ol start="3"><li>资源管理</li></ol><ul><li><p>Assetbundle资源管理</p></li><li><p>prefab资源管理</p></li></ul><ol start="4"><li>数据管理</li></ol><ul><li><p>内存数据管理</p></li><li><p>外部数据管理</p></li></ul><ol start="5"><li>网络</li></ol><h2 id="各个模块的拆分"><a href="#各个模块的拆分" class="headerlink" title="各个模块的拆分"></a>各个模块的拆分</h2><ol><li>数据表</li></ol><ul><li>XLS导为二进制文件还是json或者其他格式，读取接口和解析接口的定义</li></ul><ol start="2"><li>UI层</li></ol><ul><li><p>使用UGUI,NGUI,FGUI框架</p></li><li><p>界面基类，界面管理，输入事件封装，自定义各类通用组件</p></li></ul><ol start="3"><li>外部资源管理</li></ol><ul><li>是否使用AssetBundle，AssetBundle资源分类，AssetBundle资源之间的依赖关系，加载与释放AssetBundle的管理，AssetBundle加密</li></ul><ol start="4"><li>AI层</li></ol><ul><li>使用状态机还是行为树或是其他，状态机或行为树接口实现，AI可视化工具，AI扩展接口</li></ul><ol start="5"><li>地形地图</li></ol><ul><li>地图是2D还是3D，场景编辑器的结构，是否需要mesh合并，场景内的大小物件区别对待，大地形在游戏里该怎么逐步显示，是否需要划分区块。</li></ul><ol start="6"><li>寻路与网格</li></ol><ul><li><p>使用A星还是跳点算法还是其他</p></li><li><p>使用网格栅格还是三角形</p></li><li><p>长距离寻路的解决方案</p></li><li><p>地图数据管理</p></li></ul><ol start="7"><li>常用库</li></ol><ul><li>时间函数、数学函数、数字变量加密封装、坐标转换函数、Debug调试工具、各大逻辑系统通用工具</li></ul><ol start="8"><li>角色行为控制</li></ol><ul><li>人物移动处理方案，摄像机的碰撞检测，动画特效编辑器，技能编辑器、行为流的建立</li></ul><ol start="9"><li>2D动画控制</li></ol><ul><li>动画组件封装，2D动画的制作流程，2D图合并为图集</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;架构设计&quot;&gt;&lt;a href=&quot;#架构设计&quot; class=&quot;headerlink&quot; title=&quot;架构设计&quot;&gt;&lt;/a&gt;架构设计&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;架构设计的理论框架
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;三种需要架构的情景&quot;&gt;&lt;a href=&quot;#三</summary>
      
    
    
    
    
    <category term="架构设计" scheme="http://xuexuanfeng.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>TextMeshPro中文字体的处理</title>
    <link href="http://xuexuanfeng.github.io/2025/01/10/TextMeshPro%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://xuexuanfeng.github.io/2025/01/10/TextMeshPro%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E7%9A%84%E5%A4%84%E7%90%86/</id>
    <published>2025-01-10T15:38:21.000Z</published>
    <updated>2025-01-10T15:40:54.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity插件工具相关"><a href="#Unity插件工具相关" class="headerlink" title="Unity插件工具相关"></a>Unity插件工具相关</h1><p>网上有很多TextMeshPro的中文处理，主要都是使用预制常用字体文件生成静态字体</p><p>这篇文章使用了动态字体，感觉很方便。</p><p><a href="https://www.bilibili.com/opus/816972383961219126">https://www.bilibili.com/opus/816972383961219126</a></p><p>字体下载git<br><a href="https://github.com/adobe-fonts/source-han-sans/tree/release">https://github.com/adobe-fonts/source-han-sans/tree/release</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity插件工具相关&quot;&gt;&lt;a href=&quot;#Unity插件工具相关&quot; class=&quot;headerlink&quot; title=&quot;Unity插件工具相关&quot;&gt;&lt;/a&gt;Unity插件工具相关&lt;/h1&gt;&lt;p&gt;网上有很多TextMeshPro的中文处理，主要都是使用预制常用字体</summary>
      
    
    
    
    
    <category term="Unity插件工具相关" scheme="http://xuexuanfeng.github.io/tags/Unity%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>捏脸系统</title>
    <link href="http://xuexuanfeng.github.io/2024/12/19/%E6%8D%8F%E8%84%B8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://xuexuanfeng.github.io/2024/12/19/%E6%8D%8F%E8%84%B8%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-12-19T15:37:42.000Z</published>
    <updated>2025-02-04T07:04:40.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="捏脸系统学习开发"><a href="#捏脸系统学习开发" class="headerlink" title="捏脸系统学习开发"></a>捏脸系统学习开发</h1><h2 id="学习日志"><a href="#学习日志" class="headerlink" title="学习日志"></a>学习日志</h2><ul><li><p>目前看下来主要的流程是模型导入到blend中，添加blendshape参数，然后导入unity中，通过unity中UI动态设置skinmesh里的blendshape参数来调整模型的容貌</p></li><li><p>blender里面的值是0-1，unity中对应的是0-100</p></li><li><p>unity里面有个插件叫UMA，可以做blendershape，还能有换装的效果，具体的话以后单独开一期研究下</p></li><li><p>决定先将大奉的捏脸模块单独拿出来，用于以后的修改</p></li><li><p>大奉家里老版本，需要晚上更新一下最新版本，但是半天的时候看了下uma发现这个插件可以满足捏脸的一切需求，决定深入研究一下。</p></li><li><p>由于先看了uma，感觉这个插件大有可为，系统分为recipe，slot，overlay，整体撸了一遍插件使用，但是模型制作的pipline还是有所缺失，补习blender中。</p></li><li><p>gitee测试项目地址<a href="https://gitee.com/xuexuanfeng/unity_-uma.git">https://gitee.com/xuexuanfeng/unity_-uma.git</a></p></li><li><p>目前来看制作衣橱配方再blend里面需要将导出fbx设为6.1，如果是7.4的话坐标会对不上，目前还不知到原理</p></li><li><p>免费模型网站 Daz3D，Adobe fuse已经停止服务了，相对的可以再stream上面找到Mixamo fuse，但是steam版本没法直接上传mixamo，老是提示登陆203.</p></li><li><p>Mixamo fuse由于不能再软件里上传mixamo，所以得导出obj去上传绑定骨骼，这样的话贴图就没了</p></li><li><p>经过尝试，youtube教程上的模型导出流程已经过时了，故而用character creator导出FBX，导入blender之后2.X版本材质丢失，4.x版本显示正常，而且也有blendshape。看来新的工作流与教程上的blender2还是有出路的，但是blender4的界面和2又很不一样，学习过程中会比较绕。目前看来也没什么好的解决办法，只能用4.x处理模型了。</p></li><li><p>自己创建baserace，bone的结构很重要，必须要又Global和Position节点。另一步是分割网格，把一个body分割成头身体手脚这些部分</p></li><li><p>再制作base race的时候发现一个问题，当一个mesh里面又多个submesh的时候转换slot会有问题，比如说两个眼珠子，他只会转一个眼珠子出来，目前看来解决办法是将blender里面的材质球全部删除就没有submesh，导出的fbx为白模，这样的话mesh也就没有submesh了，但是这样材质需要合并，合并材质B站上也有教学，比较麻烦，就先无视了</p></li><li><p>大风捏脸系统的界面lua转C#处理</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;捏脸系统学习开发&quot;&gt;&lt;a href=&quot;#捏脸系统学习开发&quot; class=&quot;headerlink&quot; title=&quot;捏脸系统学习开发&quot;&gt;&lt;/a&gt;捏脸系统学习开发&lt;/h1&gt;&lt;h2 id=&quot;学习日志&quot;&gt;&lt;a href=&quot;#学习日志&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="学习记录" scheme="http://xuexuanfeng.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Dots学习心得</title>
    <link href="http://xuexuanfeng.github.io/2024/12/18/Dots%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <id>http://xuexuanfeng.github.io/2024/12/18/Dots%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</id>
    <published>2024-12-18T15:47:31.000Z</published>
    <updated>2024-12-23T14:15:02.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网球游戏开发"><a href="#网球游戏开发" class="headerlink" title="网球游戏开发"></a>网球游戏开发</h1><p>codemonkey的免费学习教程学习记录</p><h2 id="学习日志"><a href="#学习日志" class="headerlink" title="学习日志"></a>学习日志</h2><ul><li><p>Entity可以通过mono脚本进行烘培，通过Baker类中的抽象接口写入烘培逻辑，先get一个Entity，然后再addcomponent</p></li><li><p>Isytem使用非托管内存，建议使用</p></li><li><p>创建Entity和NativeArray都需要加上一个参数</p></li><li><p>使用碰撞检测比较麻烦，需要先获得一个PhysicsWorldSingleton，然后通过这个单例获取CollisionWorld，其中CollisionWorld就类似于主线程中的Physic。</p></li><li><p>感觉主要的变成思想就是IcomponentData内存储数据，然后再System中处理数据，Entity就是单纯的IcomponentData载体。</p></li><li><p>debuger目前知道的只能通过打log，并没有很好的办法。</p></li><li><p>Isystem内的逻辑是不会使用多线程的，根据教程上面说的主要是先再Isystem内的OnUpdate写好逻辑，测试没什么问题，创建IJobEntity，再IJobEntity内的Execute函数内写逻辑。调用方法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UnitMoverJob unitMoverJob = new UnitMoverJob</span><br><span class="line">&#123;</span><br><span class="line">    daltaTime = SystemAPI.Time.DeltaTime</span><br><span class="line">&#125;;</span><br><span class="line">unitMoverJob.ScheduleParallel();</span><br></pre></td></tr></table></figure><ul><li>使用Jobes的Execute有一点很方便，不用像再System的Update里面写很长的foreach，直接把想要的component写在形参里面就行了，ref代表RW，in代表RO</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[BurstCompile]</span><br><span class="line">public partial struct UnitMoverJob : IJobEntity</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="built_in">float</span> daltaTime;</span><br><span class="line">    public void Execute(ref LocalTransform localTransform,<span class="keyword">in</span> UnitMover unitMover, ref PhysicsVelocity physicVelocity)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>mono脚本可以访问entity数据，system也可以访问主线程的数据，但是这样的话burst会失效。</p></li><li><p>mono访问entity脚本很麻烦，需要先获取实体管理器，然后调用实体查询器，查询器依赖于管理器。其中有一个暗坑。获取到的component组件修改完之后需要调用SetComponentData来保存，要不然entity上的值是不会变得，因为component是struct值类型，具体代码如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EntityManager entitymanager = World.DefaultGameObjectInjectionWorld.EntityManager;</span><br><span class="line">EntityQuery entityQuery = new EntityQueryBuilder(Allocator.Temp).WithAll&lt;Selected&gt;().Build(entitymanager);</span><br><span class="line">NativeArray&lt;Entity&gt; entityArray = entityQuery.ToEntityArray(Allocator.Temp);</span><br><span class="line">NativeArray&lt;Selected&gt; selectedArray = entityQuery.ToComponentDataArray&lt;Selected&gt;(Allocator.Temp);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; entityArray.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    entitymanager.SetComponentEnabled&lt;Selected&gt;(entityArray[i], <span class="literal">false</span>);</span><br><span class="line">    Selected selected = selectedArray[i];</span><br><span class="line">    selected.onDeselected = <span class="literal">true</span>;</span><br><span class="line">    selectedArray[i] = selected;</span><br><span class="line">    entitymanager.SetComponentData(entityArray[i], selected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>System中获取DeltaTime需要用SystemAPI.Time.DeltaTime</p></li><li><p>Entity的判空处理是 &#x3D;&#x3D; Entity.Null</p></li><li><p>entitymanager给我的感觉就好像是GameObject类，里面有很多的getcomponent，setcomponet，hascomponet这种关于component的操作</p></li><li><p>system中通过查询component可以很方便的使用WithEntityAccess获取entity，通过state可以直接访问实体管理器，foreach中是不能直接删除entity的，必须把entity删除命令放到EntityCommandBuffer中，再foreach结束之后调用entityCommandBuffer.Playback</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    EntityCommandBuffer entityCommandBuffer = new EntityCommandBuffer(Unity.Collections.Allocator.Temp);</span><br><span class="line">    foreach ((RefRO&lt;Health&gt; health,</span><br><span class="line">        Entity entity) </span><br><span class="line">        in SystemAPI.Query&lt;RefRO&lt;Health&gt;&gt;().WithEntityAccess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(health.ValueRO.healthAmount &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            //state.EntityManager.DestroyEntity(entity);</span><br><span class="line">            entityCommandBuffer.DestroyEntity(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entityCommandBuffer.Playback(state.EntityManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果使用系统自带的缓冲区，就不需要new一个EntityCommandBuffer了，而且会自动Playback</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    EntityCommandBuffer entityCommandBuffer = SystemAPI.GetSingleton&lt;EndSimulationEntityCommandBufferSystem.Singleton&gt;().CreateCommandBuffer(state.WorldUnmanaged);</span><br><span class="line">    foreach ((RefRO&lt;Health&gt; health,</span><br><span class="line">        Entity entity) </span><br><span class="line">        in SystemAPI.Query&lt;RefRO&lt;Health&gt;&gt;().WithEntityAccess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(health.ValueRO.healthAmount &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            //state.EntityManager.DestroyEntity(entity);</span><br><span class="line">            entityCommandBuffer.DestroyEntity(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一般再system遇到报错时候堆栈会无法跳转，难以阅读，这时候需要关闭burst进行调试</p></li><li><p>当一个entity被销毁之后不能判断他是不是null，需要通过SystemAPI.Exists(target.ValueRO.targetEntity)来进行判断</p></li><li><p>system可以通过[UpdateInGroup(typeof(LateSimulationSystemGroup))]属性来设置不同system的执行时序，避免逻辑混乱</p></li><li><p>如果DestroyEntity之后实体消失了但是网格渲染还在，这说明entity的预制件上面需要添加LinkedEntityGroupAuthoring组件</p></li><li><p>再system中可以实例化entity对象，就像实例化gameobject对象一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entity bulletEntity = state.EntityManager.Instantiate(entityReferences.bulletPrefabEntity);</span><br></pre></td></tr></table></figure></li><li><p>如果某个component全局只有一个，如同单例一般，可以直接通过SystemAPI直接调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityReference entityReferences = SystemAPI.GetSingleton&lt;EntityReference&gt;();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网球游戏开发&quot;&gt;&lt;a href=&quot;#网球游戏开发&quot; class=&quot;headerlink&quot; title=&quot;网球游戏开发&quot;&gt;&lt;/a&gt;网球游戏开发&lt;/h1&gt;&lt;p&gt;codemonkey的免费学习教程学习记录&lt;/p&gt;
&lt;h2 id=&quot;学习日志&quot;&gt;&lt;a href=&quot;#学习日志</summary>
      
    
    
    
    
    <category term="学习记录" scheme="http://xuexuanfeng.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
