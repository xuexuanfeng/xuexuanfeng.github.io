<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>unity导出urp小游戏在微信开发者工具中黑屏</title>
      <link href="/2026/01/20/unity%E5%AF%BC%E5%87%BAurp%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B8%AD%E9%BB%91%E5%B1%8F/"/>
      <url>/2026/01/20/unity%E5%AF%BC%E5%87%BAurp%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B8%AD%E9%BB%91%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="unity导出urp小游戏在微信开发者工具中黑屏"><a href="#unity导出urp小游戏在微信开发者工具中黑屏" class="headerlink" title="unity导出urp小游戏在微信开发者工具中黑屏"></a>unity导出urp小游戏在微信开发者工具中黑屏</h1><p>unity2022.3.45f1版本导出urp小游戏在微信开发者工具中黑屏，但是手机调试运行却又可以正常运行。</p><p>重新创建新工程导出空场景，结果还是黑屏。</p><p>微信社群查到有类似问题，但是官方并没有回复。团结社群也能查到类似问题，得到回复说是新版的团结引擎已修复，随即使用团结引擎创建urp工程导出微信小游戏，运行正常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> unity开发遇到的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniRx使用指南</title>
      <link href="/2025/12/23/UniRx%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2025/12/23/UniRx%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="UniRx使用指南"><a href="#UniRx使用指南" class="headerlink" title="UniRx使用指南"></a>UniRx使用指南</h1><pre><code>最近接入新项目，发现UniRx这个工具，非常好用，可以大大简化代码，提高开发效率。</code></pre><h2 id="UniRx响应式编程核心概念与实践指南"><a href="#UniRx响应式编程核心概念与实践指南" class="headerlink" title="UniRx响应式编程核心概念与实践指南"></a>UniRx响应式编程核心概念与实践指南</h2><h3 id="一、核心思想"><a href="#一、核心思想" class="headerlink" title="一、核心思想"></a>一、核心思想</h3><pre><code>UniRx将Unity中的一切（事件、生命周期、协程、数据）抽象为可观察的事件流（IObservable&lt;T&gt;），通过声明式的操作符进行组合、转换与订阅，从而编写出更简洁、异步友好、可组合的代码。</code></pre><h3 id="二、核心理念：为什么使用UniRx？——“事件流”的意义"><a href="#二、核心理念：为什么使用UniRx？——“事件流”的意义" class="headerlink" title="二、核心理念：为什么使用UniRx？——“事件流”的意义"></a>二、核心理念：为什么使用UniRx？——“事件流”的意义</h3><ol><li>解决Unity传统编程的痛点</li></ol><ul><li>回调地狱：多重异步操作（如UI、网络、资源加载）嵌套，代码难以阅读和维护</li><li>状态管理分散：数据变化需要手动通知多个UI组件或逻辑模块，容易遗漏</li><li>生命周期管理复杂：需要在OnDestroy中手动取消订阅事件、停止协程，易造成内存泄漏</li></ul><ol start="2"><li>事件流的优势</li></ol><ul><li>统一异步模型：将时间、输入、碰撞、协程等都视为”流”，用同一套模式处理</li><li>声明式编程：用”要做什么”（如过滤、转换、合并）代替”怎么做”，意图更清晰】</li><li>卓越的可组合性：通过操作符（如Where、Select、Merge）像搭积木一样组合复杂逻辑</li><li>自动化的生命周期管理：与GameObject生命周期绑定，自动处理资源释放</li></ul><h3 id="三、核心基础：Observable与Observer"><a href="#三、核心基础：Observable与Observer" class="headerlink" title="三、核心基础：Observable与Observer"></a>三、核心基础：Observable与Observer</h3><ol><li>核心接口</li></ol><ul><li>IObservable<T>：可观察序列</li><li>IObserver<T>：观察者</li></ul><ol start="2"><li>创建流的方法<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.EveryUpdate()      <span class="comment">// 每帧触发</span></span><br><span class="line">Observable.Timer()            <span class="comment">// 定时器</span></span><br><span class="line">Observable.FromCoroutine()    <span class="comment">// 将协程转换为Observable</span></span><br><span class="line">Observable.Return()           <span class="comment">// 返回单个值</span></span><br><span class="line">Observable.Empty()            <span class="comment">// 返回空序列</span></span><br><span class="line">Observable.Never()            <span class="comment">// 永不结束的序列</span></span><br><span class="line">Observable.Throw()            <span class="comment">// 抛出错误的序列</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="四、与Unity生命周期的深度集成"><a href="#四、与Unity生命周期的深度集成" class="headerlink" title="四、与Unity生命周期的深度集成"></a>四、与Unity生命周期的深度集成</h3><ol><li><p>增强的生命周期事件</p><p> 将MonoBehaviour生命周期转化为Observable流：</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123; Move(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UniRx方式</span></span><br><span class="line"><span class="keyword">this</span>.UpdateAsObservable().Subscribe(_ =&gt; Move()).AddTo(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>可用的生命周期事件</li></ol><ul><li>StartAsObservable()、OnEnableAsObservable()、OnDisableAsObservable()</li><li>FixedUpdateAsObservable()、LateUpdateAsObservable()</li><li>OnDestroyAsObservable()</li><li>OnCollisionEnterAsObservable()、OnTriggerEnterAsObservable()等</li></ul><ol start="3"><li><p>自动订阅管理：AddTo方法</p><p> 作用：将订阅（IDisposable）绑定到指定的GameObject或Component。当目标对象被销毁时，订阅自动释放，彻底避免内存泄漏。</p><p> 最佳实践：所有在MonoBehaviour中的订阅，都应使用.AddTo(this)（绑定到Component）或.AddTo(gameObject)（绑定到GameObject）。</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line">Observable.Timer(TimeSpan.FromSeconds(<span class="number">5</span>))</span><br><span class="line">    .Subscribe(_ =&gt; Debug.Log(<span class="string">&quot;5秒后执行&quot;</span>))</span><br><span class="line">    .AddTo(<span class="keyword">this</span>); <span class="comment">// 当组件销毁时自动取消订阅</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险示例（不推荐）</span></span><br><span class="line">Observable.EveryUpdate()</span><br><span class="line">    .Subscribe(_ =&gt; DoSomething());</span><br><span class="line">    <span class="comment">// 忘记取消订阅 → 内存泄漏！</span></span><br></pre></td></tr></table></figure><h3 id="五、强大的操作符（Operators）"><a href="#五、强大的操作符（Operators）" class="headerlink" title="五、强大的操作符（Operators）"></a>五、强大的操作符（Operators）</h3><ol><li><p>与LINQ类似的查询操作符</p><p> 参考文档：<a href="https://gitee.com/xiaoTNT/uni-rx-intensive-lecture/tree/master">UniRx操作符文档</a></p><p> 过滤操作符</p><ul><li>Where：过滤流中满足条件的元素</li><li>First：取第一个元素</li><li>Last：取最后一个元素</li><li>Skip：跳过前N个元素</li><li>Take：只取前N个元素</li><li>Distinct：去重</li><li>DistinctUntilChanged：跳过连续重复的值</li></ul><p> 投影&#x2F;转换操作符</p><ul><li>Select：将元素转换为另一种形式</li><li>SelectMany：展平嵌套Observable</li><li>Cast：类型转换</li><li>OfType：过滤特定类型</li></ul><p> 组合操作符</p><ul><li>Merge：合并多个流</li><li>Zip：像拉链一样配对（等待所有源头都有新值）</li><li>CombineLatest：任一源头发射时，取各源头最新值组合</li><li>Concat：按顺序连接多个流</li><li>Switch：切换到最新的内部流</li></ul><p> 条件&#x2F;聚合操作符</p><ul><li>TakeUntil：直到另一个流发射时停止</li><li>TakeWhile：当条件满足时继续</li><li>SkipUntil：直到某个条件满足才开始</li><li>Buffer：缓冲一段时间或数量的元素</li><li>Throttle：节流，在指定时间内只取最后一个</li><li>Debounce：防抖，等待一段时间没有新值再发射</li></ul></li><li><p>UniRx特有操作符</p></li></ol><ul><li>FrameInterval：计算帧间隔</li><li>BatchFrame：将帧内的多次发射批量处理</li><li>SampleFrame：按固定帧数采样</li><li>ThrottleFirstFrame：每N帧内只取第一个</li></ul><h3 id="六、核心组件详解"><a href="#六、核心组件详解" class="headerlink" title="六、核心组件详解"></a>六、核心组件详解</h3><ol><li><p>Subject：既是Observable又是Observer</p><p> 类比：类似于C#的事件（event）或Action，是手动控制的事件源。</p><p> 使用：通过执行.OnNext(value)、.OnError()、.OnCompleted()来”推送”事件。</p><p> 类型：</p><ul><li>Subject<T>：基本的Subject</li><li>BehaviorSubject<T>：有当前值，订阅时立即发送当前值</li><li>ReplaySubject<T>：重播历史值（可指定缓冲区大小）</li><li>AsyncSubject<T>：只发布最后一个值（在Complete时）</li></ul></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Subject</span></span><br><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Subject&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line"><span class="keyword">var</span> subscription = subject.Subscribe(</span><br><span class="line">    msg =&gt; Debug.Log(<span class="string">&quot;收到消息: &quot;</span> + msg),</span><br><span class="line">    error =&gt; Debug.LogError(<span class="string">&quot;错误: &quot;</span> + error),</span><br><span class="line">    () =&gt; Debug.Log(<span class="string">&quot;完成&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">subject.OnNext(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">subject.OnNext(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">subject.OnCompleted();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">subscription.Dispose();</span><br></pre></td></tr></table></figure><pre><code>注意：在UniRx中，通常优先使用ReactiveProperty或从现有事件创建Observable，Subject多用于桥接非响应式代码。</code></pre><ol start="2"><li><p>ReactiveProperty：响应式属性</p><p> 本质：是一个实现了IObservable<T>的可观察的数据容器。</p><p> 用途：完美用于MVVM（Model-View-ViewModel）模式。当属性值改变时，自动通知所有订阅者。</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义响应式属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ReactiveProperty&lt;<span class="built_in">int</span>&gt; Hp &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> ReactiveProperty&lt;<span class="built_in">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">public</span> ReactiveProperty&lt;<span class="built_in">bool</span>&gt; IsAlive &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> ReactiveProperty&lt;<span class="built_in">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在View中绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerView</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Slider hpSlider;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Text hpText;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> PlayerModel model = <span class="keyword">new</span> PlayerModel();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绑定数据到UI</span></span><br><span class="line">        model.Hp.Subscribe(hp =&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            hpSlider.<span class="keyword">value</span> = hp;</span><br><span class="line">            hpText.text = <span class="string">$&quot;HP: <span class="subst">&#123;hp&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;).AddTo(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 双向绑定</span></span><br><span class="line">        hpSlider.OnValueChangedAsObservable()</span><br><span class="line">            .Subscribe(<span class="keyword">value</span> =&gt; model.Hp.Value = (<span class="built_in">int</span>)<span class="keyword">value</span>)</span><br><span class="line">            .AddTo(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>扩展：</code></pre><ul><li>ReactiveCollection<T>：可观察的列表</li><li>ReactiveDictionary&lt;TKey, TValue&gt;：可观察的字典</li><li>ReadOnlyReactiveProperty<T>：只读的响应式属性</li></ul><ol start="3"><li><p>MessageBroker：进程内全局事件总线</p><p> 作用：用于模块间松耦合的通信，收发自定义事件，无需相互引用。</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义消息类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerDeathMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PlayerName &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Vector3 DeathPosition &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlayerDeathMessage</span>(<span class="params"><span class="built_in">string</span> name, Vector3 pos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerName = name;</span><br><span class="line">        DeathPosition = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">MessageBroker.Default.Publish(<span class="keyword">new</span> PlayerDeathMessage(<span class="string">&quot;Player1&quot;</span>, transform.position));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line">MessageBroker.Default.Receive&lt;PlayerDeathMessage&gt;()</span><br><span class="line">    .Subscribe(msg =&gt; Debug.Log(<span class="string">$&quot;<span class="subst">&#123;msg.PlayerName&#125;</span> 被击败了！&quot;</span>))</span><br><span class="line">    .AddTo(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><pre><code>注意：MessageBroker是全局的，要小心管理订阅的生命周期，避免内存泄漏。</code></pre><h3 id="七、与协程（Coroutine）的协同与对比"><a href="#七、与协程（Coroutine）的协同与对比" class="headerlink" title="七、与协程（Coroutine）的协同与对比"></a>七、与协程（Coroutine）的协同与对比</h3><ol><li>协程的缺陷与Observable的优势对比</li></ol><table><thead><tr><th>特性</th><th>协程 (IEnumerator)</th><th>UniRx Observable</th></tr></thead><tbody><tr><td>异常处理</td><td>无法用try…catch捕获协程内部的异常，错误会静默消失</td><td>可以使用.Catch操作符优雅地捕获和处理异常，或定义错误流</td></tr><tr><td>组合性</td><td>困难，yield return另一个协程的方式有限</td><td>极强，通过操作符可轻松组合、取消、超时控制</td></tr><tr><td>返回值</td><td>只能通过回调或修改外部变量传递</td><td>流本身即携带值，天然支持</td></tr><tr><td>生命周期</td><td>需要手动停止，易遗漏</td><td>可通过AddTo自动管理</td></tr><tr><td>可读性</td><td>回调嵌套时难以理解</td><td>声明式编程，逻辑清晰</td></tr><tr><td>取消操作</td><td>支持，但需传递CancellationToken</td><td>支持，通过Dispose或TakeUntil等操作符</td></tr></tbody></table><ol start="2"><li><p>相互转换</p><p> 协程 → Observable</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadResourcesCoroutine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;加载资源...&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;资源加载完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为Observable</span></span><br><span class="line">Observable.FromCoroutine(() =&gt; LoadResourcesCoroutine())</span><br><span class="line">    .Subscribe(</span><br><span class="line">        _ =&gt; &#123; &#125;, <span class="comment">// 每帧执行，通常不需要</span></span><br><span class="line">        () =&gt; Debug.Log(<span class="string">&quot;协程完成，可在这里执行回调&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    .AddTo(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><pre><code>好处：可以监听结束、取消，并与其他Observable组合。Observable → 协程</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">WaitForPlayerInput</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将Observable转换为可yield的指令</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> Observable.Timer(TimeSpan.FromSeconds(<span class="number">3</span>))</span><br><span class="line">        .ToYieldInstruction();</span><br><span class="line">    </span><br><span class="line">    Debug.Log(<span class="string">&quot;3秒后执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>目的：在现有的协程结构中等待一个异步Observable完成。</code></pre><ol start="3"><li>异常处理对比</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协程：无法捕获内部异常</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">ProblematicCoroutine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;协程内部错误！&quot;</span>);</span><br><span class="line">    <span class="comment">// 这个异常会被Unity静默吞掉，不会在调用处被catch</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observable：可以优雅处理异常</span></span><br><span class="line">Observable.FromCoroutine(() =&gt; ProblematicCoroutine())</span><br><span class="line">    .Catch((Exception e) =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">$&quot;捕获到异常: <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Observable.ReturnUnit(); <span class="comment">// 返回一个空序列继续</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .Subscribe()</span><br><span class="line">    .AddTo(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h3 id="八、资源释放与最佳实践"><a href="#八、资源释放与最佳实践" class="headerlink" title="八、资源释放与最佳实践"></a>八、资源释放与最佳实践</h3><ol><li><p>主动释放</p><p> 订阅返回的IDisposable对象，调用其.Dispose()方法可立即取消订阅。</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存Disposable引用</span></span><br><span class="line"><span class="keyword">private</span> IDisposable subscription;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    subscription = Observable.EveryUpdate()</span><br><span class="line">        .Subscribe(_ =&gt; UpdateLogic());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 主动取消订阅</span></span><br><span class="line">    subscription?.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用CompositeDisposable管理多个订阅</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompositeDisposable disposables = <span class="keyword">new</span> CompositeDisposable();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Subscribe(_ =&gt; UpdateLogic())</span><br><span class="line">        .AddTo(disposables);</span><br><span class="line">    </span><br><span class="line">    Observable.Timer(TimeSpan.FromSeconds(<span class="number">5</span>))</span><br><span class="line">        .Subscribe(_ =&gt; DoSomething())</span><br><span class="line">        .AddTo(disposables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一次性取消所有订阅</span></span><br><span class="line">    disposables.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>黄金法则</p><p> 始终使用.AddTo(disposable)来管理基于生命周期的订阅，这是避免Unity中内存泄漏的最重要习惯。</p></li></ol><h3 id="九、实际应用示例"><a href="#九、实际应用示例" class="headerlink" title="九、实际应用示例"></a>九、实际应用示例</h3><ol><li>输入处理</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InputHandler</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 组合键盘输入</span></span><br><span class="line">        <span class="keyword">var</span> moveStream = Observable.EveryUpdate()</span><br><span class="line">            .Select(_ =&gt; <span class="keyword">new</span> Vector2(</span><br><span class="line">                Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>),</span><br><span class="line">                Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>)</span><br><span class="line">            ))</span><br><span class="line">            .Where(v =&gt; v.magnitude &gt; <span class="number">0.1f</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 节流控制：每秒最多移动10次</span></span><br><span class="line">        moveStream.Throttle(TimeSpan.FromMilliseconds(<span class="number">100</span>))</span><br><span class="line">            .Subscribe(v =&gt; Move(v))</span><br><span class="line">            .AddTo(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 双击检测</span></span><br><span class="line">        <span class="keyword">var</span> clickStream = Observable.EveryUpdate()</span><br><span class="line">            .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">            .Timestamp(); <span class="comment">// 添加时间戳</span></span><br><span class="line">        </span><br><span class="line">        clickStream.Buffer(clickStream.Throttle(TimeSpan.FromMilliseconds(<span class="number">250</span>)))</span><br><span class="line">            .Where(list =&gt; list.Count &gt;= <span class="number">2</span>)</span><br><span class="line">            .Subscribe(list =&gt; </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> timeDiff = list[<span class="number">1</span>].Timestamp - list[<span class="number">0</span>].Timestamp;</span><br><span class="line">                <span class="keyword">if</span> (timeDiff.TotalMilliseconds &lt; <span class="number">500</span>)</span><br><span class="line">                    Debug.Log(<span class="string">&quot;双击！&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            .AddTo(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params">Vector2 direction</span>)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>网络请求处理</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiService</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IObservable</span>&lt;<span class="title">string</span>&gt; <span class="title">GetUserData</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.FromCoroutine&lt;<span class="built_in">string</span>&gt;((observer) =&gt; </span><br><span class="line">            GetUserDataCoroutine(userId, observer)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">GetUserDataCoroutine</span>(<span class="params"><span class="built_in">int</span> userId, IObserver&lt;<span class="built_in">string</span>&gt; observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (UnityWebRequest request = UnityWebRequest.Get(<span class="string">$&quot;https://api.example.com/users/<span class="subst">&#123;userId&#125;</span>&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">            &#123;</span><br><span class="line">                observer.OnNext(request.downloadHandler.text);</span><br><span class="line">                observer.OnCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                observer.OnError(<span class="keyword">new</span> Exception(<span class="string">$&quot;请求失败: <span class="subst">&#123;request.error&#125;</span>&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ApiService api = GetComponent&lt;ApiService&gt;();</span><br><span class="line">        </span><br><span class="line">        api.GetUserData(<span class="number">123</span>)</span><br><span class="line">            .Timeout(TimeSpan.FromSeconds(<span class="number">10</span>)) <span class="comment">// 10秒超时</span></span><br><span class="line">            .Retry(<span class="number">3</span>) <span class="comment">// 失败重试3次</span></span><br><span class="line">            .Subscribe(</span><br><span class="line">                json =&gt; Debug.Log(<span class="string">$&quot;获取到用户数据: <span class="subst">&#123;json&#125;</span>&quot;</span>),</span><br><span class="line">                error =&gt; Debug.LogError(<span class="string">$&quot;获取失败: <span class="subst">&#123;error.Message&#125;</span>&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            .AddTo(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十、总结：UniRx事件流思想的终极意义"><a href="#十、总结：UniRx事件流思想的终极意义" class="headerlink" title="十、总结：UniRx事件流思想的终极意义"></a>十、总结：UniRx事件流思想的终极意义</h3><ol><li>异步代码同步写：将复杂的、基于时间或回调的异步逻辑，转化为直观的、顺序声明式的”流水线”，极大提升可读性和可维护性。</li><li>数据与表现绑定：通过ReactiveProperty等，实现数据驱动的UI&#x2F;逻辑更新，减少手动状态同步的bug。</li><li>生命周期安全：通过AddTo机制，将资源管理与Unity对象生命周期深度绑定，编写出更健壮的代码。</li><li>高度的抽象与组合：它提供了一套强大的”语言”（操作符），让你能以极高的效率表达复杂的交互和业务逻辑，是应对现代游戏前端复杂性的利器。</li><li>异常处理能力：相比协程，提供了更强大的错误处理机制，让异步代码更加健壮。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Unity插件工具相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化编辑器下UGUI的点击选取对象脚本</title>
      <link href="/2025/12/15/%E4%BC%98%E5%8C%96%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8BUGUI%E7%9A%84%E7%82%B9%E5%87%BB%E9%80%89%E5%8F%96%E5%AF%B9%E8%B1%A1%E8%84%9A%E6%9C%AC/"/>
      <url>/2025/12/15/%E4%BC%98%E5%8C%96%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8BUGUI%E7%9A%84%E7%82%B9%E5%87%BB%E9%80%89%E5%8F%96%E5%AF%B9%E8%B1%A1%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="优化编辑器下UGUI点击选取对象脚本"><a href="#优化编辑器下UGUI点击选取对象脚本" class="headerlink" title="优化编辑器下UGUI点击选取对象脚本"></a>优化编辑器下UGUI点击选取对象脚本</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在新项目中接触到一个便捷脚本，在编辑器运行模式下点击Game视图中的UGUI对象，会自动选中对应的GameObject，极大提升了调试效率。</p><h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line">public class UGUIEditorTool : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void <span class="function"><span class="title">Start</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line"></span><br><span class="line">    [SerializeField]</span><br><span class="line">    <span class="built_in">float</span> PingObjectTime = 1;</span><br><span class="line">    <span class="built_in">float</span> holdTime = 0;</span><br><span class="line">    void <span class="function"><span class="title">Update</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(0))</span><br><span class="line">        &#123;</span><br><span class="line">            holdTime += Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (holdTime &gt;= PingObjectTime)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3 mousePos = Input.mousePosition;</span><br><span class="line"></span><br><span class="line">                var go = PointerOverUIGameObject(new Vector2(mousePos.x, mousePos.y));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (go)</span><br><span class="line">                &#123;</span><br><span class="line">                    UnityEditor.EditorGUIUtility.PingObject(go);</span><br><span class="line">                    //Debug.Log($<span class="string">&quot;Pressed secondary button &#123;Input.mousePosition&#125; &#123;go.name&#125;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                holdTime = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            holdTime = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    GameObject PointerOverUIGameObject(Vector2 screenPos)</span><br><span class="line">    &#123;</span><br><span class="line">        var hitObject = UIRaycast(ScreenPosToPointerData(screenPos));</span><br><span class="line">        <span class="built_in">return</span> hitObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObject UIRaycast(PointerEventData pointerData)</span><br><span class="line">    &#123;</span><br><span class="line">        var results = new List&lt;RaycastResult&gt;();</span><br><span class="line">        EventSystem.current.RaycastAll(pointerData, results);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> results.Count &lt; 1 ? null : results[0].gameObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PointerEventData ScreenPosToPointerData(Vector2 screenPos)</span><br><span class="line">       =&gt; new PointerEventData(EventSystem.current) &#123; position = screenPos &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>在实际项目中可以采用以下优化方案：</p><ol><li><strong>单例模式</strong> - 将脚本作为单例，避免重复实例</li><li><strong>逻辑分离</strong> - 将执行逻辑移至其他Mono脚本的Update方法中</li><li><strong>条件编译</strong> - 通过宏指令控制，减少不必要的性能消耗</li><li><strong>按需执行</strong> - 优化检测频率，避免每帧执行</li></ol><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol><li>将脚本挂载到场景任意GameObject</li><li>设置<code>PingObjectTime</code>参数（默认1秒）</li><li>进入Play模式</li><li>在Game视图中长按UI元素，Hierarchy中会自动选中对应GameObject</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>仅Unity编辑器运行模式下有效</li><li>需要场景中存在有效的EventSystem</li><li>长按时间可根据需求调整</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unity插件工具相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小游戏StripEngineCode的问题</title>
      <link href="/2025/11/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8FStripEngineCode%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2025/11/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8FStripEngineCode%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小游戏Strip-Engine-Code的问题"><a href="#微信小游戏Strip-Engine-Code的问题" class="headerlink" title="微信小游戏Strip Engine Code的问题"></a>微信小游戏Strip Engine Code的问题</h1><p>今天接入快手小游戏时导出的unity小游戏运行时报错Could not produce class with ID 81。推测class编号为81的类被裁剪掉了，导致没有找到对应代码。</p><p>对应的引擎类ID可以通过 <a href="https://docs.unity3d.com/6000.2/Documentation/Manual/ClassIDReference.html">官网文档</a> 找到，通过文档发现ID为81的类是AudioListener，在vs中找到AudioListener对应的dll为UnityEngine.AudioModule，在工程目录中的link.xml文件加入以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;assembly fullname=<span class="string">&quot;UnityEngine.AudioModule&quot;</span> preserve=<span class="string">&quot;all&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>重新打包测试游戏，问题解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity微信小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGUI界面SafeArea自适应</title>
      <link href="/2025/09/23/NGUI%E7%95%8C%E9%9D%A2SafeArea%E8%87%AA%E9%80%82%E5%BA%94/"/>
      <url>/2025/09/23/NGUI%E7%95%8C%E9%9D%A2SafeArea%E8%87%AA%E9%80%82%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="NGUI界面SafeArea自适应"><a href="#NGUI界面SafeArea自适应" class="headerlink" title="NGUI界面SafeArea自适应"></a>NGUI界面SafeArea自适应</h1><p>主要需要修改的类有以下几个：</p><ol><li>UIRectEditor</li></ol><p>修改代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void <span class="function"><span class="title">DrawFinalProperties</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((target as UIRect).canBeAnchored))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NGUIEditorTools.DrawHeader(<span class="string">&quot;SafeArea&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            NGUIEditorTools.BeginContents();</span><br><span class="line">            &#123;</span><br><span class="line">                GUILayout.BeginHorizontal();</span><br><span class="line">                NGUIEditorTools.SetLabelWidth(100f);</span><br><span class="line">                NGUIEditorTools.DrawProperty(<span class="string">&quot;ShowInSafeArea&quot;</span>, serializedObject, <span class="string">&quot;mShowInSafeArea&quot;</span>, GUILayout.Width(120f));</span><br><span class="line">                GUILayout.Label(<span class="string">&quot;控制子节点的锚点在安全区域内显示&quot;</span>);</span><br><span class="line">                GUILayout.EndHorizontal();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            NGUIEditorTools.EndContents();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NGUISettings.unifiedTransform) DrawAnchorTransform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>NGUITools</li></ol><p>修改代码（因为是横屏游戏，这里图方便上下并没有做自适应，如果是竖屏游戏的话需要的话需要另外添加一个yOffset）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Get sides relative to the specified camera. The order is left, top, right, bottom.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">    static public Vector3[] GetSides(this Camera cam, Transform relativeTo, bool showInSafeArea = <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> cam.GetSides(Mathf.Lerp(cam.nearClipPlane, cam.farClipPlane, 0.5f), relativeTo, showInSafeArea);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Get sides relative to the specified camera. The order is left, top, right, bottom.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">    static public Vector3[] GetSides(this Camera cam, <span class="built_in">float</span> depth, Transform relativeTo, bool showInSafeArea = <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">#if UNITY_4_3 || UNITY_4_5 || UNITY_4_6</span></span><br><span class="line"><span class="keyword">if</span> (cam.isOrthoGraphic)</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        <span class="keyword">if</span> (cam.orthographic)</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> xOffset = 1f;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (showInSafeArea)</span><br><span class="line">            &#123;</span><br><span class="line">                xOffset = Simulate_SafeAreaScale;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> os = cam.orthographicSize;</span><br><span class="line">            <span class="built_in">float</span> x0 = -os * xOffset;</span><br><span class="line">            <span class="built_in">float</span> x1 = os * xOffset;</span><br><span class="line">            <span class="built_in">float</span> y0 = -os;</span><br><span class="line">            <span class="built_in">float</span> y1 = os;</span><br><span class="line"></span><br><span class="line">            Rect rect = cam.rect;</span><br><span class="line">            Vector2 size = screenSize;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> aspect = size.x / size.y;</span><br><span class="line">            aspect *= rect.width / rect.height;</span><br><span class="line">            x0 *= aspect;</span><br><span class="line">            x1 *= aspect;</span><br><span class="line"></span><br><span class="line">            // We want to ignore the scale, as scale doesn<span class="string">&#x27;t affect the camera&#x27;</span>s view region <span class="keyword">in</span> Unity</span><br><span class="line">            Transform t = cam.transform;</span><br><span class="line">            Quaternion rot = t.rotation;</span><br><span class="line">            Vector3 pos = t.position;</span><br><span class="line"></span><br><span class="line">            int w = Mathf.RoundToInt(size.x);</span><br><span class="line">            int h = Mathf.RoundToInt(size.y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((w &amp; <span class="number">1</span>) == <span class="number">1</span>) pos.x -= <span class="number">1</span>f / size.x;</span><br><span class="line">            if ((h &amp; <span class="number">1</span>) == <span class="number">1</span>) pos.y += <span class="number">1</span>f / size.y;</span><br><span class="line"></span><br><span class="line">            mSides[<span class="number">0</span>] = rot * (new Vector3(x0, <span class="number">0</span>f, depth)) + pos;</span><br><span class="line">            mSides[1] = rot * (new Vector3(0f, y1, depth)) + pos;</span><br><span class="line">            mSides[2] = rot * (new Vector3(x1, 0f, depth)) + pos;</span><br><span class="line">            mSides[3] = rot * (new Vector3(0f, y0, depth)) + pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mSides[0] = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, depth));</span><br><span class="line">            mSides[1] = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, depth));</span><br><span class="line">            mSides[2] = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, depth));</span><br><span class="line">            mSides[3] = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (relativeTo != null)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 4; ++i)</span><br><span class="line">                mSides[i] = relativeTo.InverseTransformPoint(mSides[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> mSides;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">    private static Rect WeChatASafeArea;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 获取异型屏幕的安全区域SafeArea</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;Rect&lt;/returns&gt;</span><br><span class="line">    public static Rect <span class="function"><span class="title">GetSafeArea</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">#if !UNITY_EDITOR &amp;&amp; USE_WECHATMINISDK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(WeChatASafeArea.width == 0 &amp;&amp; WeChatASafeArea.height == 0)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> radio = (<span class="built_in">float</span>)WX.GetWindowInfo().windowWidth / Screen.width;</span><br><span class="line"></span><br><span class="line">    WeChatASafeArea = new Rect();</span><br><span class="line">WeChatASafeArea.width = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.width / radio;</span><br><span class="line">    WeChatASafeArea.height = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.height / radio;</span><br><span class="line">WeChatASafeArea.x = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.left / radio;</span><br><span class="line">WeChatASafeArea.y = ((float)WX.GetWindowInfo().windowHeight - (float)WX.GetWindowInfo().safeArea.height)/radio;</span><br><span class="line"></span><br><span class="line">UnityEngine.Debug.Log(&quot;WeChatASafeArea---------&quot;+WeChatASafeArea);</span><br><span class="line">&#125;</span><br><span class="line">return WeChatASafeArea;</span><br><span class="line">#elif !UNITY_EDITOR &amp;&amp; RPK_TTDOUYIN</span><br><span class="line">        if (WeChatASafeArea.width == <span class="number">0</span> &amp;&amp; WeChatASafeArea.height == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            float radio = (float)TT.GetSystemInfo().screenWidth / Screen.width;</span><br><span class="line"></span><br><span class="line">            WeChatASafeArea = new Rect();</span><br><span class="line">            WeChatASafeArea.width = (float)TT.GetSystemInfo().safeArea.width / radio;</span><br><span class="line">            WeChatASafeArea.height = (float)TT.GetSystemInfo().safeArea.height / radio;</span><br><span class="line">            WeChatASafeArea.x = (float)TT.GetSystemInfo().safeArea.left / radio;</span><br><span class="line">            WeChatASafeArea.y = ((float)TT.GetSystemInfo().screenHeight - (float)TT.GetSystemInfo().safeArea.height) / radio;</span><br><span class="line"></span><br><span class="line">            UnityEngine.Debug.Log(&quot;WeChatASafeArea---------&quot; + WeChatASafeArea);</span><br><span class="line">        &#125;</span><br><span class="line">        return WeChatASafeArea;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">        return Screen.safeArea;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static bool Simulate_SafeArea</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return ((WindowInfoWidth() != WindowInfoSafeWidth() || WindowInfoHeight() != WindowInfoSafeHeight()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">float</span> windowWidth;</span><br><span class="line">public static <span class="built_in">float</span> <span class="function"><span class="title">WindowInfoWidth</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(windowWidth == 0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">windowWidth = Screen.width;</span><br><span class="line"><span class="comment">#elif USE_WECHATMINISDK</span></span><br><span class="line">            windowWidth = WX.GetWindowInfo().windowWidth;</span><br><span class="line"><span class="comment">#elif RPK_TTDOUYIN</span></span><br><span class="line">            windowWidth = TT.GetSystemInfo().screenWidth;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> windowWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="built_in">float</span> safeWidth;</span><br><span class="line">    public static <span class="built_in">float</span> <span class="function"><span class="title">WindowInfoSafeWidth</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (safeWidth == 0)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">            safeWidth = GetSafeArea().width;</span><br><span class="line"><span class="comment">#elif USE_WECHATMINISDK</span></span><br><span class="line">            safeWidth = WX.GetWindowInfo().safeArea.width;</span><br><span class="line"><span class="comment">#elif RPK_TTDOUYIN</span></span><br><span class="line">            safeWidth = TT.GetSystemInfo().safeArea.width;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> safeWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="built_in">float</span> windowHeight;</span><br><span class="line">    public static <span class="built_in">float</span> <span class="function"><span class="title">WindowInfoHeight</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (windowHeight == 0)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">            windowHeight = Screen.height;</span><br><span class="line"><span class="comment">#elif USE_WECHATMINISDK</span></span><br><span class="line">            windowHeight = WX.GetWindowInfo().windowHeight;</span><br><span class="line"><span class="comment">#elif RPK_TTDOUYIN</span></span><br><span class="line">            windowHeight = TT.GetSystemInfo().screenHeight;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> windowHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="built_in">float</span> windowSafeHeight;</span><br><span class="line">    public static <span class="built_in">float</span> <span class="function"><span class="title">WindowInfoSafeHeight</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (windowSafeHeight == 0)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">            windowSafeHeight = GetSafeArea().height;</span><br><span class="line"><span class="comment">#elif USE_WECHATMINISDK</span></span><br><span class="line">            windowSafeHeight = WX.GetWindowInfo().safeArea.height;</span><br><span class="line"><span class="comment">#elif RPK_TTDOUYIN</span></span><br><span class="line">            windowSafeHeight = TT.GetSystemInfo().safeArea.height;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> windowSafeHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 模拟iPhone X比例</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public static <span class="built_in">float</span> Simulate_SafeAreaScale</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Simulate_SafeArea) <span class="built_in">return</span> 1f;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> (Screen.width - GetSafeArea().x * 2) / Screen.width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>UIRect</li></ol><p>添加变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[HideInInspector]</span><br><span class="line">[SerializeField]</span><br><span class="line">public bool mShowInSafeArea = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// Get the sides of the rectangle relative to the specified transform.</span><br><span class="line">/// The order is left, top, right, bottom.</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">public virtual Vector3[] GetSides(Transform relativeTo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (anchorCamera != null) <span class="built_in">return</span> mCam.GetSides(cameraRayDistance, relativeTo, mShowInSafeArea);</span><br><span class="line"></span><br><span class="line">    Vector3 pos = cachedTransform.position;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 4; ++i)</span><br><span class="line">        mSides[i] = pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (relativeTo != null)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 4; ++i)</span><br><span class="line">            mSides[i] = relativeTo.InverseTransformPoint(mSides[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> mSides;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Convenience <span class="keyword">function</span> that returns the sides the anchored point is anchored to.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">        public Vector3[] GetSides(Transform relativeTo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (target != null)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (rect != null) <span class="built_in">return</span> rect.GetSides(relativeTo);</span><br><span class="line"><span class="comment">#if UNITY_4_3 || UNITY_4_5 || UNITY_4_6 || UNITY_4_7</span></span><br><span class="line"><span class="keyword">if</span> (target.camera != null) <span class="built_in">return</span> target.camera.GetSides(relativeTo,rect.mShowInSafeArea);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">                var cam = target.GetComponent&lt;Camera&gt;();</span><br><span class="line">                <span class="keyword">if</span> (cam != null) <span class="built_in">return</span> cam.GetSides(relativeTo, rect.mShowInSafeArea);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>UIAnchor</li></ol><p>修改代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">Update</span></span> ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mAnim != null &amp;&amp; mAnim.enabled &amp;&amp; mAnim.isPlaying) <span class="built_in">return</span>;</span><br><span class="line"><span class="keyword">if</span> (mTrans == null) <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">bool useCamera = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">UIWidget <span class="built_in">wc</span> = (container == null) ? null : container.GetComponent&lt;UIWidget&gt;();</span><br><span class="line">UIPanel pc = (container == null &amp;&amp; <span class="built_in">wc</span> == null) ? null : container.GetComponent&lt;UIPanel&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">wc</span> != null)</span><br><span class="line">&#123;</span><br><span class="line">Bounds b = wc.CalculateBounds(container.transform.parent);</span><br><span class="line"></span><br><span class="line">mRect.x = b.min.x;</span><br><span class="line">mRect.y = b.min.y;</span><br><span class="line"></span><br><span class="line">mRect.width = b.size.x;</span><br><span class="line">mRect.height = b.size.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pc != null)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span> (pc.clipping == UIDrawCall.Clipping.None)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> ratio = (mRoot != null) ? (<span class="built_in">float</span>)mRoot.activeHeight / Screen.height : 0.5f;</span><br><span class="line">                mRect.xMin = -Screen.width * ratio * 0.5f + NGUITools.GetSafeArea().x * ratio;</span><br><span class="line">                mRect.yMin = -Screen.height * ratio * 0.5f + NGUITools.GetSafeArea().y * ratio;</span><br><span class="line">                mRect.xMax = mRect.xMin + NGUITools.GetSafeArea().width * ratio;</span><br><span class="line">                mRect.yMax = mRect.yMin+ NGUITools.GetSafeArea().height * ratio; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                // Panel has clipping -- use it as the mRect</span><br><span class="line">                Vector4 pos = pc.finalClipRegion;</span><br><span class="line">                mRect.x = pos.x - (pos.z * 0.5f);</span><br><span class="line">                mRect.y = pos.y - (pos.w * 0.5f);</span><br><span class="line">                mRect.width = pos.z;</span><br><span class="line">                mRect.height = pos.w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (container != null)</span><br><span class="line">&#123;</span><br><span class="line">Transform root = container.transform.parent;</span><br><span class="line">Bounds b = (root != null) ? NGUIMath.CalculateRelativeWidgetBounds(root, container.transform) :</span><br><span class="line">NGUIMath.CalculateRelativeWidgetBounds(container.transform);</span><br><span class="line"></span><br><span class="line">mRect.x = b.min.x;</span><br><span class="line">mRect.y = b.min.y;</span><br><span class="line"></span><br><span class="line">mRect.width = b.size.x;</span><br><span class="line">mRect.height = b.size.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (uiCamera != null)</span><br><span class="line">&#123;</span><br><span class="line">useCamera = <span class="literal">true</span>;</span><br><span class="line">mRect = uiCamera.pixelRect;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> cx = (mRect.xMin + mRect.xMax) * 0.5f;</span><br><span class="line"><span class="built_in">float</span> cy = (mRect.yMin + mRect.yMax) * 0.5f;</span><br><span class="line">Vector3 v = new Vector3(cx, cy, 0f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (side != Side.Center)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (side == Side.Right || side == Side.TopRight || side == Side.BottomRight) v.x = mRect.xMax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (side == Side.Top || side == Side.Center || side == Side.Bottom) v.x = cx;</span><br><span class="line"><span class="keyword">else</span> v.x = mRect.xMin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (side == Side.Top || side == Side.TopRight || side == Side.TopLeft) v.y = mRect.yMax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (side == Side.Left || side == Side.Center || side == Side.Right) v.y = cy;</span><br><span class="line"><span class="keyword">else</span> v.y = mRect.yMin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> width = mRect.width;</span><br><span class="line"><span class="built_in">float</span> height = mRect.height;</span><br><span class="line"></span><br><span class="line">v.x += pixelOffset.x + relativeOffset.x * width;</span><br><span class="line">v.y += pixelOffset.y + relativeOffset.y * height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (useCamera)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (uiCamera.orthographic)</span><br><span class="line">&#123;</span><br><span class="line">v.x = Mathf.Round(v.x);</span><br><span class="line">v.y = Mathf.Round(v.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.z = uiCamera.WorldToScreenPoint(mTrans.position).z;</span><br><span class="line">v = uiCamera.ScreenToWorldPoint(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v.x = Mathf.Round(v.x);</span><br><span class="line">v.y = Mathf.Round(v.y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pc != null)</span><br><span class="line">&#123;</span><br><span class="line">v = pc.cachedTransform.TransformPoint(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (container != null)</span><br><span class="line">&#123;</span><br><span class="line">Transform t = container.transform.parent;</span><br><span class="line"><span class="keyword">if</span> (t != null) v = t.TransformPoint(v);</span><br><span class="line">&#125;</span><br><span class="line">v.z = mTrans.position.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Wrapped <span class="keyword">in</span> an <span class="string">&#x27;if&#x27;</span> so the scene doesn<span class="string">&#x27;t get marked as &#x27;</span>edited<span class="string">&#x27; every frame</span></span><br><span class="line"><span class="string">#if UNITY_4_3 || UNITY_4_5 || UNITY_4_6 || UNITY_4_7</span></span><br><span class="line"><span class="string">if (useCamera &amp;&amp; uiCamera.isOrthoGraphic &amp;&amp; mTrans.parent != null)</span></span><br><span class="line"><span class="string">#else</span></span><br><span class="line"><span class="string">if (useCamera &amp;&amp; uiCamera.orthographic &amp;&amp; mTrans.parent != null)</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">v = mTrans.parent.InverseTransformPoint(v);</span></span><br><span class="line"><span class="string">v.x = Mathf.RoundToInt(v.x);</span></span><br><span class="line"><span class="string">v.y = Mathf.RoundToInt(v.y);</span></span><br><span class="line"><span class="string">if (mTrans.localPosition != v) mTrans.localPosition = v;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else if (mTrans.position != v) mTrans.position = v;</span></span><br><span class="line"><span class="string">if (runOnlyOnce &amp;&amp; Application.isPlaying) enabled = false;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>PS：如果是小游戏的话需要另外获取胶囊按钮的layout来修改safeArea的数据，用于适配被胶囊按钮遮住的UI</p>]]></content>
      
      
      
        <tags>
            
            <tag> unity优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity游戏开发RTS框选单位功能</title>
      <link href="/2025/09/04/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91RTS%E6%A1%86%E9%80%89%E5%8D%95%E4%BD%8D%E5%8A%9F%E8%83%BD/"/>
      <url>/2025/09/04/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91RTS%E6%A1%86%E9%80%89%E5%8D%95%E4%BD%8D%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity游戏开发RTS框选单位功能"><a href="#Unity游戏开发RTS框选单位功能" class="headerlink" title="Unity游戏开发RTS框选单位功能"></a>Unity游戏开发RTS框选单位功能</h1><pre><code>Unity RTS游戏中框选单位的功能实现主要分为两种实现方式1.LineRender2.UGUI的Image组件这两种方式各有优缺点，LineRender可以实时渲染，但是需要手动去控制LineRender的顶点位置，而Image组件则不需要，只需要设置好Image的锚点，然后设置好Image的宽高，就可以实现框选功能了，但是Image组件需要手动去控制Image的宽高，所以需要写一个脚本去控制Image的宽高，然后把Image的宽高赋值给RectTransform的宽高，这样就可以实现框选功能了。两者的原理是一样的，都是先记录鼠标按下时的坐标，然后每帧记录当前鼠标的坐标，通过两点计算Rect矩阵的信息，然后通过Camera.main.ScreenToWorldPoint(screenPoint)将屏幕坐标转换为世界坐标，有了这个关键数据就可以进行UI绘制了。下面主要说一下LineRender的部分代码：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//设置loop之后第四个点才会和第一个点重合</span><br><span class="line">lineRenderer.loop = <span class="literal">true</span>;           </span><br><span class="line">lineRenderer.material = lineMaterial;</span><br><span class="line">lineRenderer.startColor = lineColor;</span><br><span class="line">lineRenderer.endColor = lineColor;</span><br><span class="line">lineRenderer.startWidth = lineWidth;</span><br><span class="line">lineRenderer.endWidth = lineWidth;</span><br><span class="line">//这个比较重要，如果不设置成<span class="literal">true</span>，那么lineRenderer的顶点坐标会随着物体的移动而移动，如果设置成<span class="literal">true</span>，那么lineRenderer的顶点坐标就不会随着物体的移动而移动，而是保持不变。</span><br><span class="line">lineRenderer.useWorldSpace = <span class="literal">true</span>;  </span><br><span class="line">lineRenderer.positionCount = 4;</span><br><span class="line">lineRenderer.loop = <span class="literal">true</span>;</span><br><span class="line">lineRenderer.enabled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取屏幕空间中的框选区域</span><br><span class="line">Vector3[] corners = GetSelectionCorners(startMousePosition, currentMousePosition);</span><br><span class="line"></span><br><span class="line">// 将屏幕坐标转换为世界坐标</span><br><span class="line">Vector3[] worldCorners = new Vector3[4];</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">    worldCorners[i] = ScreenToWorldPoint(corners[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lineRenderer.SetPositions(worldCorners);</span><br></pre></td></tr></table></figure><pre><code>单位单选功能实现原理主要是在场景单位上添加一个Collider，挂载一个继承IPointerClickHandler的脚本，并且重写OnPointerClick方法，这里需要注意的是Camera必须挂载Physics Raycaster，否则OnPointerClick不会触发。</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public override void OnPointerClick(PointerEventData eventData)</span><br><span class="line">&#123;</span><br><span class="line">    base.OnPointerClick(eventData);</span><br><span class="line">    SetSelect(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>单位多选功能实现原理主要是通过自定义的事件系统派发事件，之前生成的rect信息作为参数，场景的Unit单位作为事件的接收者，然后通过事件接收者去判断是否在rect内，如果在rect内，就设置该单位为选中状态，否则取消选中状态。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Unity RTS游戏功能开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双人游戏的分屏处理</title>
      <link href="/2025/07/04/%E5%8F%8C%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E5%B1%8F%E5%A4%84%E7%90%86/"/>
      <url>/2025/07/04/%E5%8F%8C%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E5%B1%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="双人游戏的分屏处理"><a href="#双人游戏的分屏处理" class="headerlink" title="双人游戏的分屏处理"></a>双人游戏的分屏处理</h1><pre><code>类似于双人成行那种左右两边分屏的功能，可以使用两个摄像机，设置摄像机的viewport Rect来做。但是测下来，drawcall会成倍增加，貌似不是一个很好的解决方案。</code></pre><p><img src="/img/_20250704222449.png" alt="截图"></p><pre><code>尝试使用cinemachine,drawcall并不会减少。使用Split Screen Pro，drawcall会减少些，但是摄像机跟随在demo里面并没有很好的实现。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> unity游戏功能开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2D游戏开发H2D技术</title>
      <link href="/2025/06/21/2D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91H2D%E6%8A%80%E6%9C%AF/"/>
      <url>/2025/06/21/2D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91H2D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><pre><code>最近有接触2D游戏初创，聊到了潜水员大夫以及八方旅人这类的2D游戏，说是用到了叫做H2D的技术，所以就稍微了解了一下，记录一下。</code></pre><ol><li>H2D核心技术构成</li></ol><ul><li>传统2D游戏使用静态精灵（Sprite），而H2D技术通过​​2D光源系统​​（如Unity URP的Freeform&#x2F;Sprite灯光）实现动态阴影、全局光照，增强场景层次感。例如，《空洞骑士》通过多层光源营造氛围。</li><li>​​后期处理效果​​（如景深、色彩校正）提升视觉表现，Unity的URP管线支持此类效果无需复杂编码。</li></ul><ol start="2"><li>骨骼动画与物理融合</li></ol><ul><li>角色动画采用​​骨骼绑定​​（如Unity的2D Animation工具），替代逐帧动画，节省资源并支持更流畅的动作。</li><li>物理引擎集成​​（如Box2D或Unity Rigidbody 2D）实现真实碰撞反馈，例如平台跳跃游戏中的角色与地面互动。</li></ul><ol start="3"><li>​​混合维度效果</li></ol><ul><li>2.5D透视​​：使用正交或倾斜投影（如等轴测视角），在2D平面模拟3D空间深度。《塞尔达传说：众神的三角量》是经典案例。</li><li>粒子系统与着色器​​：通过Shader Graph编写自定义着色器，实现水面折射、动态烟雾等效果，增强沉浸感。</li></ul><h2 id="2D场景的光照"><a href="#2D场景的光照" class="headerlink" title="2D场景的光照"></a>2D场景的光照</h2><ol><li><p>2D光照的设置</p><p> 原来2D光照需要packagemanager中install才能使用，现在已经集成在了universal rp中，Hierarcy右键Light-&gt;2D LIGHT，里面有各种2D光源。<br> 2D的默认材质是不受光照影响的，像默认渲染管线材质球转urp材质球那样，但是新版本我似乎找不到这个批量转换选项，只能选择材质球之后转换。目前看来只要是URP的项目，创建的2D对象都会使用Sprite-Lit-Default这个支持3D灯光的材质球。<br> 2D光源也支持normalmap，可以让2D物体有凹凸感，但是2D光源不支持阴影，所以需要配合3D光源使用。</p><p> 以下是批量转换脚本代码</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 文件名：TilemapMaterialConverter.cs</span><br><span class="line"><span class="comment">#if UNITY_EDITOR</span></span><br><span class="line">using UnityEditor;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class TilemapMaterialConverter</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(<span class="string">&quot;Tools/Batch Convert Tilemap Materials&quot;</span>)]</span><br><span class="line">    public static void <span class="function"><span class="title">ConvertMaterials</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        // 找到所有旧材质（根据您的原材质命名调整匹配规则）</span><br><span class="line">        string searchFilter = <span class="string">&quot;t:Material&quot;</span>;</span><br><span class="line">        string[] materialPaths = AssetDatabase.FindAssets(searchFilter);</span><br><span class="line"></span><br><span class="line">        int convertedCount = 0;</span><br><span class="line">        Shader targetShader = Shader.Find(<span class="string">&quot;Universal Render Pipeline/2D/Sprite-Lit-Default&quot;</span>);</span><br><span class="line"></span><br><span class="line">        foreach (string guid <span class="keyword">in</span> materialPaths)</span><br><span class="line">        &#123;</span><br><span class="line">            string path = AssetDatabase.GUIDToAssetPath(guid);</span><br><span class="line">            Material mat = AssetDatabase.LoadAssetAtPath&lt;Material&gt;(path);</span><br><span class="line"></span><br><span class="line">            // 仅转换特定条件的材质（调整过滤逻辑）</span><br><span class="line">            <span class="keyword">if</span> (mat.shader.name.Contains(<span class="string">&quot;Sprites/Default&quot;</span>) || </span><br><span class="line">                mat.shader.name.Contains(<span class="string">&quot;Sprites/Diffuse&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                mat.shader = targetShader;</span><br><span class="line">                EditorUtility.SetDirty(mat);</span><br><span class="line">                convertedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AssetDatabase.SaveAssets();</span><br><span class="line">        Debug.Log($<span class="string">&quot;转换完成！共转换了&#123;convertedCount&#125;个材质&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p><img src="/img/2DLIGHT_EXAMPLE.png" alt="截图"></p><ol start="2"><li>2D光源的性能</li></ol><ul><li>每个 ​​动态光源​​（如 Point Light 2D）会产生 ​​独立的光照贴图​</li><li>最终叠加到场景需进行 ​​Alpha 混合​​，消耗 GPU 带宽</li><li>典型场景：10 个动态光源 &#x3D; 10 次光照纹理绘制 + 1 次主场景绘制</li><li>每个激活的 ​​Light 2D​​ 会遍历其 ​​光照范围内的所有 Renderer​，物体数量越多，CPU 侧计算耗时越高</li></ul><ol start="3"><li>优化策略</li></ol><ul><li>减少动态光源数量​</li><li>使用烘焙光照​(虽然AI给出了烘培的方案，但是我并没有网上查到烘培相关的教程)</li><li>​​合并光源范围​<ol><li>多个相邻光源 → 替换为 ​​1 个覆盖更大区域的点光源​</li><li>或使用 ​​Sprite Mask + 单一光源​​ 模拟局部光照</li></ol></li><li>​​优化光源属性​<ol><li>启用 ​​Light Volume Intensity​​：近亮远暗，降低边缘计算</li><li>关闭不必要光源的 ​​Use Normal Maps​​（如背景光）</li></ol></li><li>材质层级优化​<ol><li>非交互背景​​：使用无光照材质（Sprite&#x2F;Unlit-Default）</li><li>​​动态物体​​：批量使用相同光照材质（减少 Shader 切换）</li></ol></li><li>移除或者禁用远处的额光源</li></ul><h2 id="2D-Animation工具"><a href="#2D-Animation工具" class="headerlink" title="2D Animation工具"></a>2D Animation工具</h2><pre><code>跟着教程跑了一边，大致了解一下，主要是PS源素材进行分层，保存PSB文件。导入unity中，素材图标会类似于FBX，而inspector面板是类似图片的选项，点击openSpriteEditor,打开如下面板</code></pre><p><img src="/img/2DANIMATION_EXAMPLE2.png" alt="截图"></p><pre><code>点击左上角切换skinning Editor，之后的流程就和blender差不多，就是创建骨骼，生成蒙皮，刷上权重，随后图片的顶点坐标就会随着骨骼的偏移而进行移动。完成2D骨骼的处理之后就可以添加animator，录制动画了。因为spine没有怎么用过，不好评论2D Animator和Spine哪个比较好用点，但是B站上有博主对比过，大致的意思就是spine的工作流比起unity来更加人性化、易操作。但是在我看来2D Animaton也是可以用的，避免了spine的学习投入成本。但是2D Animaton我并没有找到换装相关的功能，unity还有一个插件叫Character Creator 2D，可以用来制作2D角色动画以及支持换装。PS:2D Animation可以使用sprite library组件实现换装。换装教程https://www.bilibili.com/video/BV1ht4y177Ev/?spm_id_from=333.1391.0.0&amp;vd_source=757af868ca167689ee49a2bde553ef7f</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小游戏的转换遇到的一些问题</title>
      <link href="/2025/05/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2025/05/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小游戏的转换遇到的一些问题"><a href="#微信小游戏的转换遇到的一些问题" class="headerlink" title="微信小游戏的转换遇到的一些问题"></a>微信小游戏的转换遇到的一些问题</h1><ol><li>抖音小游戏转换之后onApplicationPause不生效，需要改为抖音sdk提供的接口</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StarkSDK.API.GetStarkAppLifeCycle().OnHide += OnHideFun;</span><br><span class="line">StarkSDK.API.GetStarkAppLifeCycle().OnShowWithDict += OnShowWithDictFun;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>抖音小游戏PlayerPrefs获取本地缓存，当StarkFileSystemManager.IsDataMigrated()为false的时候重启应用之后会不生效，主要原因是抖音sdk过老，可以写死StarkFileSystemManager.IsDataMigrated为true或者直接调用StarkStorage接口，当然这也是有问题的，比如切换账号之后本地缓存也会丢失，最终方案是使用抖音自带的文件系统。</p></li><li><p>抖音侧边栏是必接入项</p></li><li><p>抖音小游戏没有内购的情况下可以不用接入客服</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Unity微信小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity资源网站</title>
      <link href="/2025/05/13/Unity%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/"/>
      <url>/2025/05/13/Unity%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity资源网站"><a href="#Unity资源网站" class="headerlink" title="Unity资源网站"></a>Unity资源网站</h1><h1 id="2DTilemap相关素材"><a href="#2DTilemap相关素材" class="headerlink" title="2DTilemap相关素材"></a>2DTilemap相关素材</h1><p><a href="https://itch.io/">https://itch.io/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> unity资源相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity的插值计算</title>
      <link href="/2025/05/08/unity%E7%9A%84%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
      <url>/2025/05/08/unity%E7%9A%84%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="unity的插值计算"><a href="#unity的插值计算" class="headerlink" title="unity的插值计算"></a>unity的插值计算</h1><h2 id="Mathf的插值运算API"><a href="#Mathf的插值运算API" class="headerlink" title="Mathf的插值运算API"></a>Mathf的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个浮点数之间的插值运算。</li><li>API：Mathf.Lerp(float a, float b, float t)</li><li>参数：a为起始值，b为结束值，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的插值结果。</li></ul></li></ul><p><img src="/img/202505081609.png" alt="截图"></p><p><img src="/img/MathfLerp.gif" alt="截图"></p><h2 id="Vector3的插值运算API"><a href="#Vector3的插值运算API" class="headerlink" title="Vector3的插值运算API"></a>Vector3的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个三维向量之间的线性插值运算。</li><li>API：Vector3.Lerp(Vector3 a, Vector3 b, float t)</li><li>参数：a为起始向量，b为结束向量，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的线性插值向量。</li><li>应用场景：常用于物体的位置移动、方向变化等线性过渡效果。</li></ul></li></ul><p><img src="/img/202505081613.png" alt="截图"></p><p><img src="/img/Vector3Lerp.gif" alt="截图"></p><p>Slerp方法：</p><ul><li>功能：实现两个三维向量之间的球形插值运算，即沿球面的大圆弧进行插值。<ul><li>API：Vector3.Slerp(Vector3 a, Vector3 b, float t)</li><li>参数：a为起始向量，b为结束向量，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的球形插值向量。</li><li>应用场景：常用于物体的平滑旋转、摄像机朝向变化等需要保持恒定角速度的插值效果。</li><li>相比线性插值Lerp将Vector3当作空间的点，球形插值Slerp则是将Vector3当作方向，返回的Vector3的长度是两点之前的距离插值，方向是两个向量之间的夹角度数的插值。游戏中主要的应用场景有角色或物体的曲线跳跃,武器或抛射物的弧形弹道。</li></ul></li></ul><p><img src="/img/202505081614.png" alt="截图"></p><p><img src="/img/Vector3SLerp.gif" alt="截图"></p><h2 id="Quaternion的插值运算API"><a href="#Quaternion的插值运算API" class="headerlink" title="Quaternion的插值运算API"></a>Quaternion的插值运算API</h2><ul><li><p>Lerp方法：</p><ul><li>功能：实现两个四元数之间的线性插值运算，用于旋转的线性过渡。</li><li>API及参数：与Vector3.Lerp类似，但操作对象为四元数。</li><li>返回值：根据插值因子返回两个四元数之间的线性插值结果。</li><li>应用场景：虽然可以用于旋转插值，但可能产生“万向节锁”问题，因此不如Slerp常用。</li></ul></li><li><p>Slerp方法：</p><ul><li>功能：实现两个四元数之间的球形插值运算，用于旋转的平滑过渡。</li><li>API：Quaternion.Slerp(Quaternion a, Quaternion b, float t)</li><li>参数：a为起始四元数，b为结束四元数，t为插值因子（0到1之间）。</li><li>返回值：根据t的值，返回a和b之间的球形插值四元数。</li><li>应用场景：相机的平滑跟随与视角切换，角色的平滑转向，动画中的关节旋转过渡，UI 元素的动态旋转效果等等</li></ul></li></ul><p>Quaternion的插值分析及总结<br>Lerp求得的是四元数在圆上的弦上的等分，而Slerp求得的是四元数载圆上的圆弧的等分</p><p><img src="/img/202505081617.png" alt="截图"></p><p>从这张图可以看出lerp的运动轨迹是开始和结束慢，中间又比较快</p><p><img src="/img/202505081618.png" alt="截图"></p><p><img src="/img/QuaternionSlerp.gif" alt="截图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Addressables小游戏改造</title>
      <link href="/2025/05/08/Addressables%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%94%B9%E9%80%A0/"/>
      <url>/2025/05/08/Addressables%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%94%B9%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Addressables小游戏改造"><a href="#Addressables小游戏改造" class="headerlink" title="Addressables小游戏改造"></a>Addressables小游戏改造</h1><ol><li><p>安装addressables的package</p></li><li><p>打开Addressables Groups，这里遇到几个问题，我发现直接把Resource目录的Addressable勾上，他Resource目录中的资源并不会移出包体</p></li></ol><p><img src="/img/202405081038.png" alt="截图"></p><p><img src="/img/202405081038_1.png" alt="截图"></p><p>&emsp;&emsp;只有当勾选resource内部的时候才会有移出资源的提示，所以不能直接偷懒这么做。</p><ol start="3"><li>导出路径可以选择Remote</li></ol><p><img src="/img/202505081041.png" alt="截图"></p><p>&emsp;&emsp;打开Manage Profiles修改LoadPath路径</p><p><img src="/img/202505081042.png" alt="截图"></p><ol start="4"><li>打包的时候如果Bundle Mode选择Pack Together的话单个Group的资源会打成一个bundle，这样会产生一些无用资源的加载浪费，所以我的解决办法是一个类型文件一个Group，然后Bundle Mode选择Pack Separately，这样一个文件打成一个bundle。个人测下来Pack Separately的打包逻辑是当前目录下的所有子对象都自成一个bundle，并不是目录下的所有资源都打成单独的bundle，比方说目录A勾选addressables,然后目录A里面又有目录B,C,D，打包的资源在第三层目录结构下，如果这时候build，他会生成三个bundle，分别代表目录B,C,D。所以正确的做法是目录B,C,D勾选为addressables，而不是勾选目录A。</li></ol><p><img src="/img/202505081043.png" alt="截图"></p><ol start="5"><li>加载资源使用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;GameObject&gt; handle = Addressables.LoadAssetAsync&lt;GameObject&gt;(<span class="string">&quot;Name&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>加载场景使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;SceneInstance&gt; sceneHandle = Addressables.LoadSceneAsync(<span class="string">&quot;Assets/Scenes/Level1.unity&quot;</span>, LoadSceneMode.Additive);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还可以通过SceneInstance控制场景的激活和加载进度</p><p><img src="/img/202505081045.png" alt="截图"></p><ol start="6"><li>最后就是将同步加载结构改为异步加载API的枯燥过程了</li></ol><p>PS：这里有几点需要注意，刚开始从together切换成Pack Separately后打出来的包还是一整个，清理下缓存恢复正常，建议每次build之前都清理一下。</p><p><img src="/img/202505081046.png" alt="截图"></p><p>PS: 使用服务器下载bundle的方式测试会报错</p><p><img src="/img/202505081047.png" alt="截图"></p><p>经检查服务器地址和端口都没有问题，但是断点进去看了之后发现最终的请求地址端口为字符串HostingServicePort。Clear和Update之后能够正常访问。</p><p><img src="/img/202505081047_1.png" alt="截图"></p><p><img src="/img/202505081048_1.png" alt="截图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity微信小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>worldstreamer的Terrain分割原理</title>
      <link href="/2025/04/24/worldstreamer%E7%9A%84Terrain%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86/"/>
      <url>/2025/04/24/worldstreamer%E7%9A%84Terrain%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="worldstreamer的Terrain分割原理"><a href="#worldstreamer的Terrain分割原理" class="headerlink" title="worldstreamer的Terrain分割原理"></a>worldstreamer的Terrain分割原理</h1><p>SplitTerrain 函数的逻辑主要是将选定的地形（Terrain）进行分割，并将每个分割后的地形保存为独立的地形对象。以下是该函数的主要步骤和逻辑：</p><ol><li><p>创建目录：首先检查是否存在用于存储分割地形的目录，如果不存在则创建该目录。</p></li><li><p><strong>开始撤销组</strong>：使用 <code>Undo.SetCurrentGroupName</code> 开始一个撤销操作组，以便在用户需要撤销操作时能够恢复到之前的状态。</p></li><li><p><strong>设置分割数量</strong>：根据 <code>splitSize</code> 属性计算出将要创建的地形数量。</p></li><li><p><strong>获取选定的地形</strong>：根据用户的选择获取当前选定的地形，如果 <code>allTerrains</code> 为真，则获取所有活动的地形。</p></li><li><p><strong>遍历每个地形</strong>：对于每个选定的地形，执行以下操作：</p><ul><li><p><strong>创建新地形</strong>：根据分割数量创建新的地形数据和地形对象(Terrain.CreateTerrainGameObject这个接口可以想创建Gameobject一样直接在场景上面放一个terrain)。</p></li><li><p><strong>复制地形原型</strong>：将原始地形的所有原型（如树木、细节等）复制到新地形中。</p></li><li><p><strong>设置地形属性</strong>：调用 <code>SetTerrainSettings</code> 函数来设置新地形的各种属性。</p></li><li><p><strong>分割高度图</strong>：根据分割的大小，从原始地形的高度图中提取相应的部分并设置到新地形中。</p></li><li><p><strong>分割孔数据</strong>：同样处理地形的孔数据（如空洞）。</p></li><li><p><strong>分割纹理数据</strong>：处理地形的纹理数据，将其分割并设置到新地形中。</p></li><li><p><strong>分割细节数据</strong>：处理地形的细节数据（如草、灌木等），将其分割并设置到新地形中。</p></li><li><p><strong>处理树木实例</strong>：遍历原始地形的树木实例，将其位置调整并添加到新地形中。</p></li><li><p><strong>设置新地形的位置</strong>：根据原始地形的位置调整新地形的位置。</p></li></ul></li><li><p><strong>结束撤销组</strong>：在所有操作完成后，结束撤销操作组。</p></li><li><p><strong>清理进度条</strong>：在操作完成后，清理进度条。</p></li></ol><p>通过这些步骤，<code>SplitTerrain</code> 函数能够将一个大的地形分割成多个小的地形，便于管理和使用。每个新地形都保留了原始地形的特性和数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> worldstreamer的Terrain分割原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity中Sprite和Image的区别</title>
      <link href="/2025/04/23/unity%E4%B8%ADSprite%E5%92%8CImage%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/04/23/unity%E4%B8%ADSprite%E5%92%8CImage%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="unity中Sprite和Image的区别"><a href="#unity中Sprite和Image的区别" class="headerlink" title="unity中Sprite和Image的区别"></a>unity中Sprite和Image的区别</h1><ol><li><p>渲染上</p><ul><li>Image 通过UGUI的Image和CanvasRenderer组件组件来渲染；</li><li>Sprite 通过SpriteRenderer组件来渲染；</li><li>两者在视觉上没有任何区别（都使用默认材质时）。它们默认的渲染也都是在Transparent Geometry队列中。</li></ul></li><li><p>原理上：</p><ul><li>GPU接收到DrawCall指令后，通过一系列流程生成最终要显示的内容并进行渲染，其中大致的步骤包括：<ul><li>CPU发送Draw Call指令给GPU；</li><li>GPU读取必要的数据到自己的显存；</li><li>GPU通过顶点着色器（vertex shader）等步骤将输入的几何体信息转化为像素点数据；</li><li>每个像素都通过片段着色器（fragment shader）处理后写入帧缓存(显存)；</li><li>当全部计算完成后，GPU将帧缓存内容显示在屏幕上。</li></ul></li><li>通过上面的认知，我们可以推断：<ul><li>Sprite由于顶点数据更加复杂，进行顶点计算时在第1、2步会比Image效率更低；</li><li>Sprite会比Image执行较多的顶点着色器运算；</li><li>Image会比Sprite执行更多的片段着色器运算；</li></ul></li></ul></li><li><p>使用上：</p><ul><li>Hierarchy窗口,可以把sprite随便放在哪，通过Transform移动其它游戏物体那样移动sprite； Image必须放在Canvas下面, 且只能通过RectTransform在UI界面中移动；</li><li>sprite和Image的一个最重要的区别在于sprite支持网格的自动构造，而UI Image的网格始终由矩形构成;SpriteRenderer会创建额外的几何体来裁剪掉多余的透明像素区域，从而减少了大量的片段着色器运算，并降低了overdraw。SpriteRenderer确实是经过优化以显示更多的元素的。所以在2D游戏开发中，游戏场景中的元素，应该尽量使用它去渲染，尤其时复杂的几何图像；</li><li>Image仅用于UI显示；</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> unity优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的应用场景</title>
      <link href="/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="一、创建型模式（封装对象的创建）"><a href="#一、创建型模式（封装对象的创建）" class="headerlink" title="一、创建型模式（封装对象的创建）"></a>一、创建型模式（封装对象的创建）</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>需要全局唯一实例（如日志管理器、配置中心、数据库连接池）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singleton </span><br><span class="line">&#123; </span><br><span class="line">    private static Singleton _instance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>创建对象时需依赖子类决定具体类型（如不同数据库驱动、UI 控件的动态生成）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Creator </span><br><span class="line">&#123; </span><br><span class="line">    public abstract IProduct FactoryMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>创建一组相关或依赖的对象（如跨平台 UI 组件库：Windows&#x2F;Mac 的按钮、文本框）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IGUIFactory </span><br><span class="line">&#123; </span><br><span class="line">    IButton CreateButton(); </span><br><span class="line">    ITextBox CreateTextBox(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>分步骤构建复杂对象（如生成 XML&#x2F;JSON 文档、配置 HTTP 请求头）。</p><p>StringBuilder 类的链式调用</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>通过克隆已有对象创建新对象，避免重复初始化（如游戏中的敌人复制、配置模板）。</p><p>实现 ICloneable 接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public object <span class="function"><span class="title">Clone</span></span>() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">return</span> MemberwiseClone(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、结构型模式（处理对象间的组合关系）"><a href="#二、结构型模式（处理对象间的组合关系）" class="headerlink" title="二、结构型模式（处理对象间的组合关系）"></a>二、结构型模式（处理对象间的组合关系）</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将不兼容接口转换为客户端期望的接口（如旧系统接口适配新框架）。</p><p>包装第三方库的类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LegacyAdapter : INewInterface </span><br><span class="line">&#123; </span><br><span class="line">    private Legacy _legacy; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>分离抽象与实现，支持多维变化（如不同图形渲染API：OpenGL&#x2F;DirectX）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Shape</span><br><span class="line">&#123; </span><br><span class="line">    protected IRenderer _renderer; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>处理树形结构（如文件系统、UI 控件嵌套）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IComponent </span><br><span class="line">&#123; </span><br><span class="line">    void Add(IComponent component); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>动态添加功能（如日志记录、缓存、权限校验的链式扩展）</p><p>Stream 类的装饰器：BufferedStream, CryptoStream</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>简化复杂子系统调用（如封装支付流程：验证、扣款、通知）。</p><p>提供统一入口类：PaymentFacade.ProcessPayment(order)。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>共享大量细粒度对象（如字符格式复用、游戏中的粒子系统）。</p><p>String.Intern() 方法复用字符串常量</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>控制对象访问（如延迟加载、远程调用、权限验证）。</p><p>Lazy<T> 类实现延迟加载，WCF 的客户端代理。</p><h1 id="三、行为型模式（管理对象间的交互）"><a href="#三、行为型模式（管理对象间的交互）" class="headerlink" title="三、行为型模式（管理对象间的交互）"></a>三、行为型模式（管理对象间的交互）</h1><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>多个对象依次处理请求（如审批流程、异常处理过滤器）。</p><p>ASP.NET Core 中间件管道：app.UseMiddleware<LoggingMiddleware>()。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>封装请求为对象（如撤销&#x2F;重做操作、任务队列）。</p><p>WPF 的 ICommand 接口：RelayCommand。</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>定义语法规则并解释执行（如正则表达式、SQL解析）。</p><p>正则表达式引擎 System.Text.RegularExpressions</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>遍历集合元素（如自定义集合的遍历逻辑）。</p><p>实现 IEnumerable<T> 和 IEnumerator<T> 接口。</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>减少对象间直接耦合（如聊天室消息转发、UI控件交互）。</p><p>使用 MediatR 库实现事件调度。</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>保存和恢复对象状态（如游戏存档、事务回滚）。</p><p>序列化对象到文件或数据库。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>一对多依赖通知（如事件发布-订阅、数据绑定）。</p><p>C# 的 event 关键字和 IObservable<T>&#x2F;IObserver<T> 接口。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>对象行为随状态改变（如订单状态流转、游戏角色行为切换）。</p><p>定义状态接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState </span><br><span class="line">&#123; </span><br><span class="line">    void Handle(Context context); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>动态切换算法（如排序算法选择、支付方式切换）。</p><p>依赖注入中的不同服务实现：services.AddScoped&lt;IPaymentStrategy, AlipayStrategy&gt;()。</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>定义算法骨架，子类实现步骤（如工作流引擎、数据导入流程）</p><p>抽象类定义流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class DataImporter </span><br><span class="line">&#123; </span><br><span class="line">    public void <span class="function"><span class="title">Import</span></span>() </span><br><span class="line">    &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>分离数据结构与操作（如AST树解析、报表生成）。</p><p>实现 IVisitor 接口遍历复杂对象结构。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity场景物体贴地操作</title>
      <link href="/2025/03/19/Unity%E5%9C%BA%E6%99%AF%E7%89%A9%E4%BD%93%E8%B4%B4%E5%9C%B0%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/19/Unity%E5%9C%BA%E6%99%AF%E7%89%A9%E4%BD%93%E8%B4%B4%E5%9C%B0%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity场景物体贴地操作"><a href="#Unity场景物体贴地操作" class="headerlink" title="Unity场景物体贴地操作"></a>Unity场景物体贴地操作</h1><p>以前会专门为底边开发一个物体贴地的工具，但unity其实编辑器内原生自带了这个功能，选中物体按下Ctrl+Shift,场景物体中间会出现一个灰色的小方框，拖动物体编辑器就会自动处理贴地的效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> UnityEditor小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小游戏反编译</title>
      <link href="/2025/03/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
      <url>/2025/03/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小游戏反编译"><a href="#微信小游戏反编译" class="headerlink" title="微信小游戏反编译"></a>微信小游戏反编译</h1><p><a href="https://www.cnblogs.com/thebeastofwar/p/17611201.html">参考文献</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>注册开发者工具+申请小游戏类目</li></ol><p>不能用微信开发者工具自带的测试者账号，有一些小程序需要调用你的token</p><p><a href="https://developers.weixin.qq.com/">https://developers.weixin.qq.com/</a></p><ol start="2"><li>安装并下载反编译软件</li></ol><p><a href="https://www.cnblogs.com/thebeastofwar/p/17611201.html">https://www.cnblogs.com/thebeastofwar/p/17611201.html</a></p><ol><li><p>wxappUnpacker-master</p><p> <a href="../../file/wxappUnpacker-master.zip">下载文件</a></p></li><li><p>UnpackMiniApp</p><p> <a href="../../file/UnpackMiniApp.zip">下载文件</a></p></li></ol><h1 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h1><ol><li>反编译小游戏</li></ol><p>在windows上的微信中打开并加载小游戏</p><p>找到小游戏的下载目录WeChatFiles\Applet,有两个包</p><p>找到游戏主包(unity转换的游戏包含_WITHOUT_MULTI_PLUGINCODE_.wxapkg),另一个自爆里面包含的是插件包，不用管</p><p>不要移动这几个包的位置，直接双击运行UnpackMiniApp.exe,选择加密小程序包</p><p>选择一个包(每次选择一个)</p><p>解密成功后，报的位置位于UnpackMiniApp.exe统计目录的wxpack目录下，由于每次解密后的包名相同，需要给解密后的包重命名，以防被覆盖</p><p>在依次解密_wasmcode_.wxapkg和_wasmcode1_.wxapkg这两个包,都重命名，得到如下三个解密的包</p><p>在使用wxappUnpacker-master这个工具，主要用到的是wuWxapkg.jg这个解包脚本和wuJs.js这个分包脚本</p><p>安装node.js，运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node .\wuWxapkg.js E:\tools\wxpack\main.wxapkg <span class="comment"># 加入路径</span></span><br></pre></td></tr></table></figure><p>解压成功</p><p>在依次解压pkg1.wxapkg和pkg2.wxapkg,得到两个文件夹</p><ol start="2"><li>导入小游戏</li></ol><ul><li><p>打开微信开发者工具-&gt;微信小游戏-&gt;import</p></li><li><p>选择项目路径-&gt;设置提前申请好的小游戏类目appid</p></li><li><p>点击create</p></li></ul><ol start="3"><li>项目设置(本地设置Local setting)</li></ol><p>首先检查微信开发者工具的相关设置</p><ul><li>确保这几项设置正确勾选(新人并运行，将JS编译成ES5,不校验合法域名)</li></ul><ol start="4"><li>Subpackages添加和配置删除</li></ol><p>根据主目录game.json中的subpackages配置，添加我们反编译的子包,并删除不存在的子包配置</p><ol start="5"><li>引擎配置问题</li></ol><p>详情查看<a href="#question3">常见问题3</a></p><p>修改game.json中的gamePlugins-&gt;plugins</p><ol start="6"><li>报错:VM2_INTERNAL_STATE_DONOT_USE_OR_PROGRAM_WILL_FAIL</li></ol><p>VM2_INTERNAL_STATE_DONOT_USE_OR_PROGRAM_WILL_FAIL undefined</p><p>在game.js中添加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL = &#123;</span><br><span class="line">  handleException: (e) =&gt; &#123;</span><br><span class="line">    console.warn(e);</span><br><span class="line">    <span class="built_in">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="7"><li>删除game.js报错(常出现在subpackages中)</li></ol><p>可能会有显示(console)和隐式(非debug模式下无法运行但没有log)的错误，导致微信开发者工具内无法显示游戏页面，通常需要对main包之外的包中game.js进行如下define和require的处理:</p><p><img src="/img/fa37821da338f520c2579457435214b.jpg" alt="图标"></p><p>例如在这个额外导入的wasmcode1包中，需要将外层注释。</p><p>建议对所有包进行预处理，避免host中可能的require错误（尽管此错误不会影响游戏运行）</p><ol start="8"><li>Mock Login</li></ol><p>详情查看<a href="#loginpipline">微信登陆服务模拟搭建流程</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><h2 id="question3">常见问题</h2></h2><ol><li>PARAMOUNT</li></ol><p>首先检查微信开发者工具的相关设置</p><ul><li>确保这几项设置正确勾选（信任并运行，将JS编译成ES5，不校验合法域名）</li></ul><ol start="2"><li>*&#x2F;game.js预处理</li></ol><p>可能会有显示(console)和隐式(非debug模式下无法运行但没有log)的错误，导致微信开发者工具内无法显示游戏页面，通常需要对main包之外的包中game.js进行如下define和require的处理:</p><p><img src="/img/fa37821da338f520c2579457435214b.jpg" alt="图标"></p><p>例如在这个额外导入的wasmcode1包中，需要将外层注释。</p><p>建议对所有包进行预处理，避免host中可能的require错误（尽管此错误不会影响游戏运行）</p><ol start="3"><li>引擎引用问题</li></ol><p>修改game.json中的gamePlugins-&gt;plugins</p><h3 id="UnityPlugin问题"><a href="#UnityPlugin问题" class="headerlink" title="UnityPlugin问题"></a>UnityPlugin问题</h3><p>在unity引擎的游戏中，需要通过微信账号导入能力地图-开发提效包-快适配，并将game.json中的gamePlugins改为plugins。一般情况下,游戏可以正常运行。</p><p>如果遇到无法运行的情况，可以留意plugins下UnityPlugin的版本。</p><p>实测1.2.38会遇到微信开发这工具中无法正确获取插件的情况。可以在此处将版本更新后在启动游戏。</p><p>建议将版本更新到1.2.54,与unity-wx-to-webgl-host转换包中的版本相对应。</p><h3 id="cocos的requirePlugin"><a href="#cocos的requirePlugin" class="headerlink" title="cocos的requirePlugin"></a>cocos的requirePlugin</h3><p>有游戏会将Cocos作为gamePlugin卸载game.json中，main&#x2F;app目录下的cocos目录里缺少cocos2d-js-min.js文件。此时游戏不会正常加载，亦不会有明显报错。需要做出一下改动：</p><ul><li><p>删除game.json下的cocos plugin定义</p></li><li><p>从网上或过往的项目里扒一个对应版本的cocos2d-js-min.js,黏贴到cocos目录下</p></li><li><p>修改game.js的</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirePlugin(<span class="string">&quot;cocos&quot;</span>);</span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">&quot;cocos/cocos2d-js-min.js&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Laya引擎处理方式"><a href="#Laya引擎处理方式" class="headerlink" title="Laya引擎处理方式"></a>Laya引擎处理方式</h3><p>同上</p><ol start="4"><li>快速hook login</li></ol><p>在game.js中添加如下代码，将url替换成本游戏的登陆密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var orgR = wx.request;</span><br><span class="line">wx.request = (obj) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.url.indexOf(<span class="string">&#x27;weixingamelogin.php?jscode=&#x27;</span>) &gt; -1) &#123;</span><br><span class="line">        debugger</span><br><span class="line">        console.log(<span class="string">&quot;获得的obj为:&quot;</span>, obj);</span><br><span class="line">        obj.url = <span class="string">&#x27;https://bd11-rel.52playgame.com&#x27;</span> + </span><br><span class="line">        <span class="string">&#x27;/gmsys/weblogic/webc/weixingamelogin.php?jscode=0e3FP5ll2xbd7e4xLPkl25sgD40FP5l1&amp;group=1&amp;systematic=3&amp;encrypteddata=undefined&amp;iv=undefined&amp;os=Windows%2011%20x64&amp;model=microsoft&amp;toutiao_cluetoken=&amp;toutiao_create_id=&amp;toutiao_ad_id=&amp;guangdiantong_minigamechannel=&amp;guangdiantong_clickid=&amp;weixinadinfo=&amp;xingtu_callback=&amp;chuanshanjia_cluetoken=&amp;baidu_bd_vid=&amp;baidu_ext_info=&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> orgR(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>加解密</li></ol><p>遇到类似  “sign1”:”OTAyMTY1M3d4NjEzMjEyZTNkNDk3ZWVkOTE3MjcyNTAxMTE&#x3D;” 的值，可以尝试用 base64解码，可能可以获取wxid和timestamp</p><p><a href="https://www.sojson.com/base64.html">https://www.sojson.com/base64.html</a></p><ol start="6"><li>[“workers”]字段需要为目录</li></ol><p>在目录下找打了workers.js的文件</p><p><img src="/img/5ab912ead2e88e55b3bdca157bb6f6a.jpg" alt="图标"></p><p>需要用wxappUnpacker-master这个工具中的wuJs.js进行分包，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node .\wuJs.js E:\tools\wxpack\main\workers.js</span><br></pre></td></tr></table></figure><p>分包成功,得到worker&#x2F;response&#x2F;index.js</p><ol start="7"><li>Unity plugin加载 data-package失败</li></ol><p>在获取游戏是，目录中没有_data-package_.wxapkg这个包。在微信开发者工具中手动创建data-package目录后，在console中遇到如下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PLUGIN ERROR 16:58.17.613]  解压资源失败, 加载方式: 分包, errMsg:  readCompressedFile:fail data-package/830ce1e8f65310db.webgl.data.unityweb.bin.br not found(<span class="built_in">env</span>: Windows,mg,1.06.2405020; lib: development)</span><br></pre></td></tr></table></figure><p>发现在data-package目录下，加载游戏分包时，并没有得到 830ce1e8f65310db.webgl.data.unityweb.bin.br 这个文件这种情况可能是在加载游戏的时候，data package 缓存到了用户的本地目录WeChat Files&lt;用户的hash码&gt;\Applet&lt;游戏的码&gt;\usr（如：WeChat Files\wxid_hq52a973p00x22\Applet\wxfc5347dec6075f3a\usr）下面解决方法：把WeChat Files&lt;用户的hash码&gt;\Applet\下的缓存文件全部删掉，并且把WeChat Files\Applet\下面的游戏缓存全部删掉，重新打开并加载游戏有可能会在游戏的文件中得到 <em>data-package</em>.wxapkg 文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity微信小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPS游戏武器被墙体遮挡的问题</title>
      <link href="/2025/03/11/FPS%E6%B8%B8%E6%88%8F%E6%AD%A6%E5%99%A8%E8%A2%AB%E5%A2%99%E4%BD%93%E9%81%AE%E6%8C%A1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/11/FPS%E6%B8%B8%E6%88%8F%E6%AD%A6%E5%99%A8%E8%A2%AB%E5%A2%99%E4%BD%93%E9%81%AE%E6%8C%A1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="FPS游戏武器被墙体遮挡的问题"><a href="#FPS游戏武器被墙体遮挡的问题" class="headerlink" title="FPS游戏武器被墙体遮挡的问题"></a>FPS游戏武器被墙体遮挡的问题</h1><p>&emsp;&emsp;在FPS游戏中武器经常会因为摄像机透视视角的原因导致被游戏中的某些环境遮挡，有些游戏会要求武器永远被渲染在屏幕中不会被遮挡，这时候可以使用单独的一个相机设置culling mask来渲染武器这个层</p>]]></content>
      
      
      
        <tags>
            
            <tag> unity优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计</title>
      <link href="/2025/02/04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/02/04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><pre><code>架构设计的理论框架</code></pre><h2 id="三种需要架构的情景"><a href="#三种需要架构的情景" class="headerlink" title="三种需要架构的情景"></a>三种需要架构的情景</h2><ol><li><p>一个系统，构成复杂，需要多个子系统协同以实现系统目标</p></li><li><p>一个系统，他由多个功能相似的模块构成，模块内的功能重复度很高，且容易出错。</p></li><li><p>一个系统，规模太大，需要多人协作完成，需要保证多人协作的效率和稳定性。</p></li></ol><h2 id="三种架构设计的思维"><a href="#三种架构设计的思维" class="headerlink" title="三种架构设计的思维"></a>三种架构设计的思维</h2><ol><li><p>分层思维</p></li><li><p>分治思维</p></li><li><p>演化思维</p></li></ol><h2 id="架构设计时的考量点"><a href="#架构设计时的考量点" class="headerlink" title="架构设计时的考量点"></a>架构设计时的考量点</h2><ul><li><p>游戏引擎的选择</p></li><li><p>UI的事件系统</p></li><li><p>AI行为算法</p></li><li><p>数据如何获取和存储</p></li><li><p>场景如何拆分</p></li><li><p>是否需要将资源分离出去</p></li><li><p>长连接短连接的选择</p></li><li><p>服务器语言的选择</p></li><li><p>使用关系型数据库还是加入cache机制</p></li><li><p>网络协议是protobuf，json，xml的选择</p></li></ul><h2 id="架构的五种能力"><a href="#架构的五种能力" class="headerlink" title="架构的五种能力"></a>架构的五种能力</h2><ol><li><p>承载力</p></li><li><p>可扩展性</p></li><li><p>易用性</p></li><li><p>可伸缩力</p></li><li><p>容错力以及错误的感知力</p></li></ol><h2 id="基本的架构思维"><a href="#基本的架构思维" class="headerlink" title="基本的架构思维"></a>基本的架构思维</h2><ul><li><p>算法和数据结构</p></li><li><p>软件工程</p></li><li><p>面向对象程序设计</p></li><li><p>抽象：分层、分治、演化</p></li></ul><h2 id="前端架构的思考点"><a href="#前端架构的思考点" class="headerlink" title="前端架构的思考点"></a>前端架构的思考点</h2><ol><li>用户体验</li></ol><ul><li><p>如何让游戏加载更快</p></li><li><p>如何制作更绚丽的特效</p></li><li><p>如何减少DrawCall</p></li><li><p>如何减少CPU的负载</p></li><li><p>如何最快的响应用户的操作</p></li><li><p>如何适应更多的手机</p></li></ul><ol start="2"><li><p>操作系统</p></li><li><p>游戏引擎</p></li><li><p>应用层框架</p></li><li><p>业务逻辑</p></li></ol><h2 id="UI前端框架的技术栈"><a href="#UI前端框架的技术栈" class="headerlink" title="UI前端框架的技术栈"></a>UI前端框架的技术栈</h2><ol><li><p>UI框架</p></li><li><p>主要逻辑框架</p></li></ol><ul><li><p>编辑器</p></li><li><p>角色行为框架</p></li><li><p>AI框架</p></li><li><p>地图场景与寻路框架</p></li><li><p>Shader与特效</p></li><li><p>设备平台</p></li></ul><ol start="3"><li>资源管理</li></ol><ul><li><p>Assetbundle资源管理</p></li><li><p>prefab资源管理</p></li></ul><ol start="4"><li>数据管理</li></ol><ul><li><p>内存数据管理</p></li><li><p>外部数据管理</p></li></ul><ol start="5"><li>网络</li></ol><h2 id="各个模块的拆分"><a href="#各个模块的拆分" class="headerlink" title="各个模块的拆分"></a>各个模块的拆分</h2><ol><li>数据表</li></ol><ul><li>XLS导为二进制文件还是json或者其他格式，读取接口和解析接口的定义</li></ul><ol start="2"><li>UI层</li></ol><ul><li><p>使用UGUI,NGUI,FGUI框架</p></li><li><p>界面基类，界面管理，输入事件封装，自定义各类通用组件</p></li></ul><ol start="3"><li>外部资源管理</li></ol><ul><li>是否使用AssetBundle，AssetBundle资源分类，AssetBundle资源之间的依赖关系，加载与释放AssetBundle的管理，AssetBundle加密</li></ul><ol start="4"><li>AI层</li></ol><ul><li>使用状态机还是行为树或是其他，状态机或行为树接口实现，AI可视化工具，AI扩展接口</li></ul><ol start="5"><li>地形地图</li></ol><ul><li>地图是2D还是3D，场景编辑器的结构，是否需要mesh合并，场景内的大小物件区别对待，大地形在游戏里该怎么逐步显示，是否需要划分区块。</li></ul><ol start="6"><li>寻路与网格</li></ol><ul><li><p>使用A星还是跳点算法还是其他</p></li><li><p>使用网格栅格还是三角形</p></li><li><p>长距离寻路的解决方案</p></li><li><p>地图数据管理</p></li></ul><ol start="7"><li>常用库</li></ol><ul><li>时间函数、数学函数、数字变量加密封装、坐标转换函数、Debug调试工具、各大逻辑系统通用工具</li></ul><ol start="8"><li>角色行为控制</li></ol><ul><li>人物移动处理方案，摄像机的碰撞检测，动画特效编辑器，技能编辑器、行为流的建立</li></ul><ol start="9"><li>2D动画控制</li></ol><ul><li>动画组件封装，2D动画的制作流程，2D图合并为图集</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TextMeshPro中文字体的处理</title>
      <link href="/2025/01/10/TextMeshPro%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2025/01/10/TextMeshPro%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity插件工具相关"><a href="#Unity插件工具相关" class="headerlink" title="Unity插件工具相关"></a>Unity插件工具相关</h1><p>网上有很多TextMeshPro的中文处理，主要都是使用预制常用字体文件生成静态字体</p><p>这篇文章使用了动态字体，感觉很方便。</p><p><a href="https://www.bilibili.com/opus/816972383961219126">https://www.bilibili.com/opus/816972383961219126</a></p><p>字体下载git<br><a href="https://github.com/adobe-fonts/source-han-sans/tree/release">https://github.com/adobe-fonts/source-han-sans/tree/release</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity插件工具相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dots学习心得</title>
      <link href="/2024/12/18/Dots%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
      <url>/2024/12/18/Dots%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="网球游戏开发"><a href="#网球游戏开发" class="headerlink" title="网球游戏开发"></a>网球游戏开发</h1><p>codemonkey的免费学习教程学习记录</p><h2 id="学习日志"><a href="#学习日志" class="headerlink" title="学习日志"></a>学习日志</h2><ul><li><p>Entity可以通过mono脚本进行烘培，通过Baker类中的抽象接口写入烘培逻辑，先get一个Entity，然后再addcomponent</p></li><li><p>Isytem使用非托管内存，建议使用</p></li><li><p>创建Entity和NativeArray都需要加上一个参数</p></li><li><p>使用碰撞检测比较麻烦，需要先获得一个PhysicsWorldSingleton，然后通过这个单例获取CollisionWorld，其中CollisionWorld就类似于主线程中的Physic。</p></li><li><p>感觉主要的变成思想就是IcomponentData内存储数据，然后再System中处理数据，Entity就是单纯的IcomponentData载体。</p></li><li><p>debuger目前知道的只能通过打log，并没有很好的办法。</p></li><li><p>Isystem内的逻辑是不会使用多线程的，根据教程上面说的主要是先再Isystem内的OnUpdate写好逻辑，测试没什么问题，创建IJobEntity，再IJobEntity内的Execute函数内写逻辑。调用方法如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UnitMoverJob unitMoverJob = new UnitMoverJob</span><br><span class="line">&#123;</span><br><span class="line">    daltaTime = SystemAPI.Time.DeltaTime</span><br><span class="line">&#125;;</span><br><span class="line">unitMoverJob.ScheduleParallel();</span><br></pre></td></tr></table></figure><ul><li>使用Jobes的Execute有一点很方便，不用像再System的Update里面写很长的foreach，直接把想要的component写在形参里面就行了，ref代表RW，in代表RO</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[BurstCompile]</span><br><span class="line">public partial struct UnitMoverJob : IJobEntity</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="built_in">float</span> daltaTime;</span><br><span class="line">    public void Execute(ref LocalTransform localTransform,<span class="keyword">in</span> UnitMover unitMover, ref PhysicsVelocity physicVelocity)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>mono脚本可以访问entity数据，system也可以访问主线程的数据，但是这样的话burst会失效。</p></li><li><p>mono访问entity脚本很麻烦，需要先获取实体管理器，然后调用实体查询器，查询器依赖于管理器。其中有一个暗坑。获取到的component组件修改完之后需要调用SetComponentData来保存，要不然entity上的值是不会变得，因为component是struct值类型，具体代码如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EntityManager entitymanager = World.DefaultGameObjectInjectionWorld.EntityManager;</span><br><span class="line">EntityQuery entityQuery = new EntityQueryBuilder(Allocator.Temp).WithAll&lt;Selected&gt;().Build(entitymanager);</span><br><span class="line">NativeArray&lt;Entity&gt; entityArray = entityQuery.ToEntityArray(Allocator.Temp);</span><br><span class="line">NativeArray&lt;Selected&gt; selectedArray = entityQuery.ToComponentDataArray&lt;Selected&gt;(Allocator.Temp);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; entityArray.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    entitymanager.SetComponentEnabled&lt;Selected&gt;(entityArray[i], <span class="literal">false</span>);</span><br><span class="line">    Selected selected = selectedArray[i];</span><br><span class="line">    selected.onDeselected = <span class="literal">true</span>;</span><br><span class="line">    selectedArray[i] = selected;</span><br><span class="line">    entitymanager.SetComponentData(entityArray[i], selected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>System中获取DeltaTime需要用SystemAPI.Time.DeltaTime</p></li><li><p>Entity的判空处理是 &#x3D;&#x3D; Entity.Null</p></li><li><p>entitymanager给我的感觉就好像是GameObject类，里面有很多的getcomponent，setcomponet，hascomponet这种关于component的操作</p></li><li><p>system中通过查询component可以很方便的使用WithEntityAccess获取entity，通过state可以直接访问实体管理器，foreach中是不能直接删除entity的，必须把entity删除命令放到EntityCommandBuffer中，再foreach结束之后调用entityCommandBuffer.Playback</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    EntityCommandBuffer entityCommandBuffer = new EntityCommandBuffer(Unity.Collections.Allocator.Temp);</span><br><span class="line">    foreach ((RefRO&lt;Health&gt; health,</span><br><span class="line">        Entity entity) </span><br><span class="line">        in SystemAPI.Query&lt;RefRO&lt;Health&gt;&gt;().WithEntityAccess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(health.ValueRO.healthAmount &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            //state.EntityManager.DestroyEntity(entity);</span><br><span class="line">            entityCommandBuffer.DestroyEntity(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entityCommandBuffer.Playback(state.EntityManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果使用系统自带的缓冲区，就不需要new一个EntityCommandBuffer了，而且会自动Playback</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    EntityCommandBuffer entityCommandBuffer = SystemAPI.GetSingleton&lt;EndSimulationEntityCommandBufferSystem.Singleton&gt;().CreateCommandBuffer(state.WorldUnmanaged);</span><br><span class="line">    foreach ((RefRO&lt;Health&gt; health,</span><br><span class="line">        Entity entity) </span><br><span class="line">        in SystemAPI.Query&lt;RefRO&lt;Health&gt;&gt;().WithEntityAccess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(health.ValueRO.healthAmount &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            //state.EntityManager.DestroyEntity(entity);</span><br><span class="line">            entityCommandBuffer.DestroyEntity(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一般再system遇到报错时候堆栈会无法跳转，难以阅读，这时候需要关闭burst进行调试</p></li><li><p>当一个entity被销毁之后不能判断他是不是null，需要通过SystemAPI.Exists(target.ValueRO.targetEntity)来进行判断</p></li><li><p>system可以通过[UpdateInGroup(typeof(LateSimulationSystemGroup))]属性来设置不同system的执行时序，避免逻辑混乱</p></li><li><p>如果DestroyEntity之后实体消失了但是网格渲染还在，这说明entity的预制件上面需要添加LinkedEntityGroupAuthoring组件</p></li><li><p>再system中可以实例化entity对象，就像实例化gameobject对象一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entity bulletEntity = state.EntityManager.Instantiate(entityReferences.bulletPrefabEntity);</span><br></pre></td></tr></table></figure></li><li><p>如果某个component全局只有一个，如同单例一般，可以直接通过SystemAPI直接调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityReference entityReferences = SystemAPI.GetSingleton&lt;EntityReference&gt;();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityAI编程工具Cursor</title>
      <link href="/2024/11/04/UnityAI%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7Cursor/"/>
      <url>/2024/11/04/UnityAI%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7Cursor/</url>
      
        <content type="html"><![CDATA[<h1 id="UnityAI编程工具Cursor"><a href="#UnityAI编程工具Cursor" class="headerlink" title="UnityAI编程工具Cursor"></a>UnityAI编程工具Cursor</h1><p>B站闲逛发现了一个很炸裂的工具Cursor，chatGpt的免费平替了</p><p>Cursor下载: <a href="https://www.cursor.com/">https://www.cursor.com/</a><br>Uinty 插件下下载: <a href="https://github.com/boxqkrtm/com.unity.ide.cursor">https://github.com/boxqkrtm/com.unity.ide.cursor</a><br>或者packagemanager直接输入: <a href="https://github.com/boxqkrtm/com.unity.ide.cursor.git">https://github.com/boxqkrtm/com.unity.ide.cursor.git</a></p><ol><li><p>先要去Cursor官网下载，需要翻墙。安装完毕之后选择中文。</p></li><li><p>打开unity工程，在packagemanager中install by githuburl 安装unity插件。</p></li><li><p>Preferences中加入Cursor编辑器</p></li><li><p>双击脚本打开编辑器，界面和vs code差不多。在插件扩展栏搜索unity，把相关的插件都装了。</p></li><li><p>Ctrl+L 呼出AI进行对话，生成代码，点击accept复制代码到文件中。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Unity插件工具相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量修改图片脚本</title>
      <link href="/2024/11/04/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/11/04/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity插件工具相关"><a href="#Unity插件工具相关" class="headerlink" title="Unity插件工具相关"></a>Unity插件工具相关</h1><p>借鉴现有工程代码，比较完美的工具代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">using System.Linq;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEditor;</span><br><span class="line"></span><br><span class="line">public static class WebGLTextureSet</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(<span class="string">&quot;OptimizeTool/Texture/WebGLTextureSet&quot;</span>)]</span><br><span class="line">    private static void <span class="function"><span class="title">_Set</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        var paths = AssetDatabase.FindAssets(<span class="string">&quot;t:Texture&quot;</span>, GetPath()).Select(AssetDatabase.GUIDToAssetPath);</span><br><span class="line"></span><br><span class="line">        foreach (var path <span class="keyword">in</span> paths)</span><br><span class="line">        &#123;</span><br><span class="line">            Set(path);</span><br><span class="line">        &#125;</span><br><span class="line">        AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static string[] <span class="function"><span class="title">GetPath</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> new string[] &#123; <span class="string">&quot;Assets/HotUpdateResources&quot;</span>, <span class="string">&quot;Assets/Resources&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Set(string path)</span><br><span class="line">    &#123;</span><br><span class="line">        var item = TextureImporter.GetAtPath(path) as TextureImporter;</span><br><span class="line">        <span class="keyword">if</span> (item != null)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bool isChange = Set(item);</span><br><span class="line">        <span class="keyword">if</span> (isChange)</span><br><span class="line">        &#123;</span><br><span class="line">            AssetDatabase.ImportAsset(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static bool Set(TextureImporter item)</span><br><span class="line">    &#123;</span><br><span class="line">        bool isChange = Set(item, <span class="string">&quot;WebGL&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> isChange; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static bool Set(TextureImporter item, string str)</span><br><span class="line">    &#123;</span><br><span class="line">        var seting = item.GetPlatformTextureSettings(str);</span><br><span class="line">        bool isChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!seting.overridden)</span><br><span class="line">        &#123;</span><br><span class="line">            seting.overridden = <span class="literal">true</span>;</span><br><span class="line">            isChange = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seting.format != TextureImporterFormat.ASTC_8x8)</span><br><span class="line">        &#123;</span><br><span class="line">            seting.format = TextureImporterFormat.ASTC_8x8;</span><br><span class="line">            isChange = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seting.textureCompression == TextureImporterCompression.Uncompressed)</span><br><span class="line">        &#123;</span><br><span class="line">            seting.textureCompression = TextureImporterCompression.Compressed;</span><br><span class="line">            isChange = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isChange)</span><br><span class="line">        &#123;</span><br><span class="line">            item.SetPlatformTextureSettings(seting);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> isChange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unity插件工具相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webgl与Js的交互</title>
      <link href="/2024/11/03/Webgl%E4%B8%8EJs%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
      <url>/2024/11/03/Webgl%E4%B8%8EJs%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h1 id="Webgl与Js的交互"><a href="#Webgl与Js的交互" class="headerlink" title="Webgl与Js的交互"></a>Webgl与Js的交互</h1><p>工作中遇到需求，想要将某些URL进行配置，首先想到的是配置本地数据文件，加载之后反序列化。过程复杂了点，但是可以实现功能。还发现了一种简单的配置方法，就是将url写入js文件中，然后通过Webgl去调用对应的函数取值。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先要创建jslib文件存入工程中，再编辑器中会看到一个类似于dll状态的文件。大致写法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mergeInto(LibraryManager.library, &#123;</span><br><span class="line">    </span><br><span class="line">    Hello: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        window.alert(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    HelloString: <span class="keyword">function</span> (str) &#123;</span><br><span class="line">        //这里使用Pointer_stringify方法转换unity传递过来的字符串</span><br><span class="line">        window.alert(Pointer_stringify(str));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    PrintFloatArray: <span class="keyword">function</span> (array, size) &#123;</span><br><span class="line">        <span class="keyword">for</span>(var i = 0; i &lt; size; i++)&#123;</span><br><span class="line">            //遍历<span class="built_in">float</span>数组使用HEAPF32，更多类型：HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64</span><br><span class="line">            console.log(HEAPF32[(array &gt;&gt; 2) + i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    AddNumbers: <span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">        //这里unity传递过来int类型数字，不需要转换</span><br><span class="line">        <span class="built_in">return</span> x + y;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    //返回一个字符串到unity</span><br><span class="line">    StringReturnValueFunction: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var returnStr = <span class="string">&quot;bla&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        var bufferSize = lengthBytesUTF8(returnStr) + 1;</span><br><span class="line">        var buffer = _malloc(bufferSize);</span><br><span class="line">        stringToUTF8(returnStr, buffer, bufferSize);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> buffer;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    BindWebGLTexture: <span class="keyword">function</span> (texture) &#123;</span><br><span class="line">        GLctx.bindTexture(GLctx.TEXTURE_2D, GL.textures[texture]);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>C#代码中调用如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using System.Runtime.InteropServices;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class callJSTest : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern void Hello();</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern void HelloString(string str);</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern void PrintFloatArray(<span class="built_in">float</span>[] array, int size);</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern int AddNumbers(int x, int y);</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern string StringReturnValueFunction();</span><br><span class="line"></span><br><span class="line">    [DllImport(<span class="string">&quot;__Internal&quot;</span>)]</span><br><span class="line">    private static extern void BindWebGLTexture(int texture);</span><br><span class="line"></span><br><span class="line">    void <span class="function"><span class="title">Start</span></span>() &#123;</span><br><span class="line">        Hello();</span><br><span class="line">        </span><br><span class="line">        HelloString(<span class="string">&quot;This is a string.&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">float</span>[] myArray = new <span class="built_in">float</span>[10];</span><br><span class="line">        PrintFloatArray(myArray, myArray.Length);</span><br><span class="line">        </span><br><span class="line">        int result = AddNumbers(5, 7);</span><br><span class="line">        Debug.Log(result);</span><br><span class="line">        </span><br><span class="line">        Debug.Log(StringReturnValueFunction());</span><br><span class="line">        </span><br><span class="line">        var texture = new Texture2D(0, 0, TextureFormat.ARGB32, <span class="literal">false</span>);</span><br><span class="line">        BindWebGLTexture(texture.GetNativeTextureID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际操作中需要到了点问题，Js中直接return字符串，C#这边取到的值一直为空，网上找了下貌似js的string和C#的string还是有点区别的，不能直接传递。string要从Javascript返回到 Unity，必须使用_malloc分配内存，然后将数据从变量stringToUTF8复制到新分配的内存中，然后返回该内存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity微信小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ilruntime调试环境搭建</title>
      <link href="/2024/10/28/Ilruntime%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/10/28/Ilruntime%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Ilruntime调试环境搭建"><a href="#Ilruntime调试环境搭建" class="headerlink" title="Ilruntime调试环境搭建"></a>Ilruntime调试环境搭建</h1><p>Ilruntime的安装教程地址<a href="https://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html">(点击跳转)</a></p><p>目前看来Ilruntime的调试与xlua相似，都是unity安装完运行环境之后，编辑器内安装对应插件Ilruntime Debugger。据说2.0之前的版本调试插件要上github官网下载对应的插件，2.0以上的直接VS2022扩展里面下载就行，端口就用56000，主要还是StartDebugService调用的时机很关键，太早调用的话会导致打不到断点</p><p>调试器问题解答<a href="https://blog.csdn.net/qq_39162826/article/details/128221561">(点击跳转)</a></p><p>调试条件</p><ol><li><p>安装ILRuntime的VS调试插件（Github上可下载）</p></li><li><p>确定启用DEBUG宏和禁用DISABLE_ILRUNTIME_DEBUG宏</p></li><li><p>检查ILRDomain.DebugService.StartDebugService(56000)是否启用</p></li><li><p>检查PDB是否被加载</p></li><li><p>检查DLL是否为DEBUG版本（提高调试准确性）</p></li></ol><p>以上条件满足还可以支持真机调试</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity插件工具相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IlRuntime小游戏转换</title>
      <link href="/2024/10/22/IlRuntime%E5%B0%8F%E6%B8%B8%E6%88%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>/2024/10/22/IlRuntime%E5%B0%8F%E6%B8%B8%E6%88%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="IlRuntime小游戏转换工作记录"><a href="#IlRuntime小游戏转换工作记录" class="headerlink" title="IlRuntime小游戏转换工作记录"></a>IlRuntime小游戏转换工作记录</h1><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><p>day1 项目移除ILRuntime，提升性能</p><p>day2 config文件资源打包成zip，执行预加载，之后统一解析数据</p><p>day3 FGUI的package数据加入预加载中，调用UIPACKAGE中的异步加载，但是界面没有打开，spineanimation那个玩意儿会报空，得找出解决方案<br>目前看来有三个解决方案：</p><p>先加载完必要的资源然后打开界面—–有很多getwindow之后的调用，而且数量众多<br>使用异步加载界面，然01元素等待加载——日前流程没有跑通，而且spineneanimat1on会报空<br>使用adduisource——目前看来他可以挡住init，但是又很多外部的地方会直接调用界面的public函数</p><p>day4 主要还是使用使用异步加载界面来解决同步加载的问题，主要聚焦于主流程的前两个界面，第一个过场动画已经适配异步了，主界面待调试，目前遇到两个问题，第一个是有很多同步的方式使用spine动画，目前的方案是再3Dloader类中加入委托，将所有需要执行的操作存入委托中，资源加载完毕之后派发事件，通知3DLOADER统一执行委托。但是又发现了一个问题，有很多地方getwindow之后会直接调用界面的内部函数，由于是同步的流程，会导致异步加载完没有完成，panel为空导致报错。</p><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><p>day5 早上对其了下spine动画和fgui的异步加载，目前只用createobject就行，他结构初始化和资源加载本身就是分开的逻辑互不影响，这么看来fgui同步改异步还是很方便的，但是进入主界面之后有些spine动画一会显示一会不显示。debug之后发现之前使用的事件派发更新显示逻辑因为Gloader再初始化的时候会调用dispose接口，这就导致了有时候消息发过来了，但是事件侦听被remove了，随即改成了packageitem再gloader注册的时候加入委托对象，这样的好处是packageitem再异步加载完成之后可以精确的派发到指定的gloader对象，而不用像事件派发到每个gloader对象然后在做数据判断。<br>最后开始游戏的时候还会黑屏，需要原项目工程导入ilruntime的debug插件进行逻辑对比。</p><p>day6 早上加入了spinedata的预加载功能，可以特殊化处理一下spine为同步加载，避免了一下繁琐的代码修改，可以说是救命的功能。处理了表格加载异常导致血量血量显示错误的bug。导出webgl版本尝试跑了下，发现浏览器没有log，排查了下log的enable开关没有关，projectsetting的log也打开了，最后原来是filterLogType被设为了只显示error。然后链接登录服务器的时候websocket报错了。目前还在排查。顺带一提webgl导出develope版本后可以模糊的看到报错的函数名，可以说是螺丝壳里做到场了，有用但是不多。</p><p>day7 早上排查了下webgl报错，发现打release版本也可以查看堆栈。只要把publish里的Debug Symbol勾选就会多生成一个文件，里面打开会看到wasm里面的函数ID所对应的函数名，函数里面就需要打log定位了，然后继续说webgl排查问题，游戏底层的log使用stackframe，webgl环境内貌似不支持stackframe，无法实例化，new出来的是null。游戏网络socket通讯用的是tcpclient对象，貌似webgl也支持，传入host之后控制台会报无法解析地址，换成unitywebsocket组件之后就可以正常连接了。不过云开发环境的代理造成了不小的麻烦，打开代理的时候浏览器无法链接服务器。那些localposition为nan的报错也改了，主要是异步加载之后fgui会进行layout组件操作，判断下contentwidth和contentheight如果都为0的话说明正在异步加载，不执行layout操作，资源下载完之后还会进行一次layout的。</p><p>day8 测试发现登陆界面的spine动画有几率会不显示，排查之后发现存在bundle.error不为null的情况，推断应该是本地服务器吞吐量不够，导致的并发下载部分丢失的问题，主要还是代码异步加载里缺少下载失败重新下载的功能，加入之后完美解决。昨天改的GLoader3D中的layout函数会导致进入游戏后unity占用cpu100%,就算停止之后还是100%，很难排查，不过还原代码之后webgl模式下面到没有报错，webgl虽然可以正常游戏，但是有几个奇怪的地方，图片压缩格式一直warning不支持，不管是astc还是etc，然后audio也有一个警告，最要命的是每次加压一张图片就会卡一下，当没有图片解压的时候客户端流畅运行，游戏中也有需要优化的地方，场景物体特效一多就会造成卡顿。</p><p>day9 主要聚焦了下fgui造成的cpu100%问题，通过排除法很难定位到有问题的代码，感觉bug的触发点有很多。奇怪的是cpu虽然占用100%但是编辑器的FPS缺没有降低，而且profile也是很平稳的一个状态，一度怀疑是编辑器的bug。没有找出问题，后面做了下js配置cdn地址。学了一招，原来webgl是可以和js交互的。通过js配置cdn地址可比本地json加载之后解析方便多了。</p><h2 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h2><p>day10 早上做了个图片批处理工具，将所有图片转为astc8*8，并且压缩，bundle总量小了三分之二。研究了下UOS服务，主要的就是搞清楚bucket和relesse版本的关系就可以了，每个release版本就是一个bucket的文件状态，如果bucket里面文件都删光了，不发布release版本，那么还是有文件可以下载下来的。然后开始看抖音sdk的文档，感觉大多和微信差不多，首先官方下载package，导入到工程中，打开BGDT，安装StarkSDKUnityTools之后会又dll的报错，排查下来原来是没有安装editor的安装环境，很好奇为何抖音小游戏和安卓有关系。安装完毕后打开BuildTool，选择运行框架webgl，然后构建WebGL生成zip，再点击开发者工具发布。抖音开发者工具会自动打开项目。感觉很乱，抖音开发者工具把unity工程的根目录作为了小游戏工程的更目录，然后他运行的项目本体就是那个zip文件。</p><p>day11 今天主要主攻小游戏主包瘦身相关的工作，目前定下的方案是将resources文件夹内的图片字体音频打入一个bundle中，然后解包之后进行同步加载处理，这样改动较小，也可以保留项目原有的逻辑。之前createobject执行之后cpu占用100%的bug貌似找到了，在界面资源异步加载处理的地方没有加队列。导致一下子又300多个对象需要reload。加入队列之后继续观察。</p><p>day12 早上收尾了启动界面的开发，实现了resource内资源的剥离，但是界面自适应有点问题，FGUI的界面自适应模式是在代码里面实现的，有个类似于UGUI的canvasscaler的接口。接着加入了bundle下载队列的最大数量限制，不出所料果然是并发下载bundle过多导致的cpu100%。</p><p>day13 发现游戏中有些spine物体会不显示，看了下gowarp下面就没有spine对象，排查之后发现原来每次异步加载之后会调用packitem内的action，但是gloader3d和packitem并不是一一对应的，而是一个packitem公用多个gloader3d对象，从而导致了两次action回调都调用到了一个gloader对象上，导致第二个spine没有被创建。调整了下逻辑，将action改为了delegate，一个spine加载完之后初始化所有用到这个packageitem的loader对象。其中异步加载也做了一系列的优化，当多个组件用到一张图片的时候，第二次下载将会被return，只保留第一次加载的操作，下载完成后统一初始化所有组件。目前看来效果明显。只是进入大厅之后会黑一阵子等待图片加载。</p><p>day14 早上由于外网进步俩服务器，看了会抖音开发者文档，发现有个启动参数可以配置，正好拿来做CDN配置。发散了下思维试了下外网是否可以访问游戏服务器，发现外网并没有503报错，由此判断是unity办公室的网络问题，上报IT后当天解决问题。</p><h2 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h2><p>day15 早上对接了抖音的inputtext，2022及以上的unity和最新的fgui貌似都适配抖音的输入框，但是老版本还是要做一下适配，微信和抖音的实现原理都差不多，主要就是获取焦点之后调用API呼出keyboard。下午发现游戏中的时候有些gloader下面的image会显示不出。debug后发现，主要是游戏中主动调用了seticon，然后又设置了icon的材质球。因为是异步的加载，会导致材质球设置不成功。在设置材质球的代码中加入等待icon加载完全之后再执行逻辑，解决问题。</p><p>day16 小游戏右上角工具图标的界面适配，游戏本身就有这个功能，webgl调整下默认值就行了。小游戏的语言不是中文问题也解决了，原来项目语言是通过application.systemlanguage来判断的，惊了。并且优化了进入大厅的加载，去除了一些不必要的界面初始化。</p><p>day17 添加了异步加载的优化功能，再等待加载的时候放置白色的马赛克图片作为替代。优化了新手引导创建角色的加载，原来gamewindow初始化过早，导致选角界面和战斗界面同时加载造成卡顿，gamewindow的init挪后，选角加载效果变为流畅。但是遇到一个问题，我的手机扫码真机运行之后会报错。DeviceOrientationEvent is not defined。</p><p>day18 DeviceOrientationEvent is not defined的问题找到了，是因为游戏内调用了systemInfo里面的陀螺仪权限，估计是为了做界面的前景与后景结合的立体感。加入了编译宏DOU_YIN,用于区分是否再抖音平台，通过自定义的导出脚本，动态添加编译宏，编译版本成功之后再去除宏，不影响正常的editor使用，为了就是不让douyin的业务逻辑影响到webgl，方便调试。本来想顺便一起通过脚本把plastic的变更项提交了，然后发现不好弄，版本之间的冲突不好处理，不像以前版本机上面无脑用其他人的版本就行了，最终还是决定导出的版本手动提交。还遇到了一个恶心的问题就是新手引导第一关之后必掉线，经过排查发现通关之后只要发送消息，websocke就会close，目前猜测是服务器与客户端协议不一致导致的服务单报错，触发主动断开的逻辑。</p><p>day19 频繁短线的问题找到了，主要是新手引导的时候客户端逻辑不发心跳包，导致下个消息发送到服务器如果间隔时间过长的话服务器会主动断开，新手引导加入心跳解决问题。融合sdk的输入接口接完之后keyboard无法呼出，果断还原成抖音原生的解决方案了，周一的话要一个最新的融合sdk再本地测试一下。</p><h2 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h2><p>day20 早上加入了TTAssetbundle,真机测试之后可以看到cache日志，第二次加载速度明显变快。然后原来融合sdk的inputtext的确是无法接入，他是按照ugui做的，对应的component无法挂在textfield组件，因为fgui的textfield不是mono。下午了解了下抖音侧边栏，抖音审核必备的功能，主要是一个按钮和一个界面组成，目标是引导用户发现并且使用抖音侧边栏。但是sdk给的侧边栏界面是ugui做的，无法和fgui一起自适应。所以决定入口作为fgui动态加载到主界面中，避免后续的频繁改动就不做在主界面里面了。具体做法还需调研。</p><p>day21 考虑了下鉴于项目使用的是FGUI，而融合sdk的通用侧边栏是ugui，最后决定重新依样画葫芦用FGUI做个侧边栏界面，这样既能去除textmeshpro和ugui的package，既缩小了首包大小也缩小了wasm大小，一举两得。侧边栏的真机测试需要联系客服开通测试权限，然后都应打开开发者选项，这样才能再侧边栏看到我的app图标，实现跳转。今天完成了FGUI的界面搭建以及代码编写。</p><p>day22 今天主要是继续侧边栏的调试。再侧边栏测试权限没有审核通过之前可以先用开发者工具测试流程，接入了点击后的奖励领取，以及奖励状态的管理。目前没有服务器，领取奖励之后跳出弹框提示。今天还遇到了个奇怪的东西，进入大厅弹框报错memory out of bound。结果删除library之后重新发布回复正常。再测试时候发现一个问题，用了ttassetbundle之后当bundle有更新，会不去下载而用本地cache，这是因为bundle的名字相同，导致代码判断不需要下载，这样看来bundle的逻辑还得修改，得加上打包option里的md5码后缀才行。然后打bundle的代码也进行了优化，加入了windows和webgl的打包选项，免得我每次都切来切去的打包了，webgl的dxt就不管他了，反正也不打用。</p><p>day23 昨天真机崩溃的bug还是存在，排查下来居然是TTassetBundle的问题，还原成assetbundle之后居然好了，等后面bundle加载md5后缀之后再试试是不是有问题。今天合并了新的版本，代码和资源部分已经全部合并完毕，跑下来进入战斗之后显示有问题，需要再新版本上跑一下看看流程。明天尝试新版本去除ilruntime看看流程对不对。</p><p>day24 合并了新版本的资源，原来的报错是因为有些函数为了性能改为了携程，所以不执行了。处理了下侧边栏按钮的关联自适应，加上了客服按钮并对接功能。下周处理下客服和侧边栏按钮的位置，客服再最左边，应为是个常态的按钮。</p><h2 id="week6"><a href="#week6" class="headerlink" title="week6"></a>week6</h2><p>day25 调整了客服与侧边栏按钮的位置。下午debug了一下断线重连的问题，发现这个游戏不是很需要短线重连，游戏中的断线也只不过是更新下battlecode，客户端主导结果，只顾过再结束的时候要发一个fightresult的消息，只有消息返回结果之<br>后结算流程才会走下去，所以再发送消息断线之后会卡在最后异步，解决方法是发送消息之后注册重连事件侦听，放过程中有重连的操作马上派发事件到gamemode中，执行重连消息的回调，再发一次fightresult。</p><p>day26 今天继续修复了下招财猫的短线重连问题，原来是上一句的侦听没有移除，导致提前触发了result。移除侦听之后恢复正常。sdk相关按钮移到了右边，左侧按钮太多有重叠。明天看一下TTassetbundle，看看能不能重新接入。</p><p>day27 早上看了下bundle的打包流程，原来bundle的命名是更具path而转换成的hash值，所以当内容变化是他的名字是不会改变的。下午重新接入了下TTassetbundle。resourcebundle为了方便更新，后缀加入了版本号，再jengine脚本上配置resourceversion，将所有bundle后缀加入hash值，然后将mainfest.uinty3d文件加入到缓存黑名单，如果这个文件被缓存了那就无法热更新了。这样一来我也理解了为何会有缓存黑名单的存在了。已提交待测试。</p><p>day28 早上bundle加载略微修改了下，resourcebundle加入unload逻辑，测试通过。下午主攻ios内存崩溃问题。测试了一下，dymicmenory再200以下，进入战斗之后到结算崩溃，dymicmenory再200以上进入战斗，直接崩溃，明明还有200多M的内存未使用。增加unityHeap到756之后依然崩溃，估计还是突然加载峰值的问题把，menoryprofile查看内存发现有些界面就算关闭了，但是spine动画的资源依然残留，bundle引用计数是饭否正常运行，主界面是否需要拆分，但是内存回收不处理的话就算拆分了界面还是得崩溃，需要解决的问题还很多。只能先组个demo试一下基础的fgui资源如何释放。</p><p>day29 尝试了下fgui自带的package资源释放可行，spine动画资源释放就比较恶心，有好几个地方引用到了材质球，逐一释清理之后成功释放。对应逻辑已加入项目中。</p><h2 id="week7"><a href="#week7" class="headerlink" title="week7"></a>week7</h2><p>day30 发现resourcebundle卸载之后，进入游戏会有一行报错，排查发现bgm是流失加载，再unloadbundle之后，可能音频流断掉了而导致报错。音频改为不是stream之后解决问题。ios游戏中会出现无法拖动的问题，但是模拟断线重连数次并未重现，真机模拟也是，故而放弃。</p><p>day31 接入了抖音激励广告，很奇怪其他人接的小游戏再播放广告的时候游戏bgm会自动关闭，潮玩团的就不会，不纠结直接代码手动关闭，为了容错，选择静音，再游戏出现问题的时候玩家也可以手动恢复。微信和抖音的貌似有区别，接入微信的时候还得适配一下。逐步开始改QA提出的bug。今天发现了一个神奇的语法，原来ref传入的形参无法再lamd表达式内调用，震惊一百年。</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>之後就是内存优化的问题了，由于月底合同就不续签了，当烂尾处理没什么可以记录得了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity微信小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity解压bundle工具</title>
      <link href="/2024/10/22/Unity%E8%A7%A3%E5%8E%8Bbundle%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/10/22/Unity%E8%A7%A3%E5%8E%8Bbundle%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity解压bundle工具"><a href="#Unity解压bundle工具" class="headerlink" title="Unity解压bundle工具"></a>Unity解压bundle工具</h1><p>github工程链接地址<a href="https://github.com/RazTools/Studio/releases/tag/v1.36.00">(点击跳转)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity插件工具相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity微信小游戏刘海屏适配</title>
      <link href="/2024/10/20/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%88%98%E6%B5%B7%E5%B1%8F%E9%80%82%E9%85%8D/"/>
      <url>/2024/10/20/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%88%98%E6%B5%B7%E5%B1%8F%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity原生刘海屏适配方案"><a href="#Unity原生刘海屏适配方案" class="headerlink" title="Unity原生刘海屏适配方案"></a>Unity原生刘海屏适配方案</h1><p>网络文章<a href="https://blog.uwa4d.com/archives/USparkle_UGUI-NGUI.html">(文档链接)</a>，给出了UGUI和NGUI的刘海屏适配方案。主要还是通过获取到的safeArea区域的数据，对锚点做偏移处理。新版本的unity可以直接通过Screen.SafeArea来获取安全区域，并不需要文章内的这么麻烦通过原生底层获取。</p><p>UGUI比较简单，在panel上面挂载mono脚本，对RectTransform的anchorMin和anchorMax进行修改即可。要注意的是Panel节点的锚点需要选择右下角的那个撑满选项，并且四个角的锚点都为0，不然的话效果会不符合预期。<br><img src="/img/20241020234707.png" alt="锚点选项"></p><p>NGUI就比较复杂，需要修改NGUI的源码，大致原理都差不多。</p><h1 id="Unity小游戏刘海屏适配方案"><a href="#Unity小游戏刘海屏适配方案" class="headerlink" title="Unity小游戏刘海屏适配方案"></a>Unity小游戏刘海屏适配方案</h1><p>微信小游戏文档给出了获取safeArea的方案<a href="https://wechat-miniprogram.github.io/minigame-unity-webgl-transform/Design/fixScreen.html">(文档链接)</a></p><p>但是有一点比较奇怪的是，WX.GetWindowInfo().windowWidth与unity中的Screen.width并不相等。</p><p>如图<br><img src="/img/20241020235412.png" alt="小游戏输入日志"></p><p>但是通过计算可以知道WX.GetWindowInfo().windowWidth和Screen.width的比例与WX.GetWindowInfo().windowHeight和Screen.height是相等的，都是0.333333，所以可以通过这个参数因子反向推得得到类似于Screen.SafeArea的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static Rect WeChatASafeArea;</span><br><span class="line">public static Rect SafeArea</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">#if !UNITY_EDITOR &amp;&amp; USE_WECHATMINISDK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(WeChatASafeArea.width == 0 &amp;&amp; WeChatASafeArea.height == 0)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> radio = (<span class="built_in">float</span>)WX.GetWindowInfo().windowWidth / Screen.width;</span><br><span class="line"></span><br><span class="line">    WeChatASafeArea = new Rect();</span><br><span class="line">WeChatASafeArea.width = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.width / radio;</span><br><span class="line">    WeChatASafeArea.height = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.height / radio;</span><br><span class="line">WeChatASafeArea.x = (<span class="built_in">float</span>)WX.GetWindowInfo().safeArea.left / radio;</span><br><span class="line">WeChatASafeArea.y = ((float)WX.GetWindowInfo().windowHeight - (float)WX.GetWindowInfo().safeArea.height)/radio;</span><br><span class="line"></span><br><span class="line">UnityEngine.Debug.Log(&quot;WeChatASafeArea---------&quot;+WeChatASafeArea);</span><br><span class="line">&#125;</span><br><span class="line">return WeChatASafeArea;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">            return Screen.safeArea;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>导出小游戏后完美解决<br><img src="/img/20241020235827.png" alt="微信开发者工具截图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity微信小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity微信小游戏的bundle加载流程</title>
      <link href="/2024/10/16/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84bundle%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/10/16/Unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84bundle%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity微信小游戏的bundle加载流程"><a href="#Unity微信小游戏的bundle加载流程" class="headerlink" title="Unity微信小游戏的bundle加载流程"></a>Unity微信小游戏的bundle加载流程</h1><p>最近在看unity的微信小游戏导出文档<a href="https://hexo.io/docs/writing.html">(文档链接)</a></p><p>1.ab包的发布</p><p>设置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(<span class="string">&quot;TOOL/BuildBundle&quot;</span>)]</span><br><span class="line">    public static void <span class="function"><span class="title">BuildBundleFun</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        string saveDir = <span class="string">&quot;Assets/StreamingAssets&quot;</span>;</span><br><span class="line"></span><br><span class="line">        AssetBundleBuild[] buildMap = new AssetBundleBuild[1];</span><br><span class="line">        buildMap[0] = new AssetBundleBuild();</span><br><span class="line">        buildMap[0].assetBundleName = <span class="string">&quot;PrefabImage&quot;</span>;</span><br><span class="line">        buildMap[0].assetNames = new string[] &#123; <span class="string">&quot;Assets/Prefab/PrefabImage.prefab&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        BuildAssetBundleOptions options = BuildAssetBundleOptions.AppendHashToAssetBundleName | BuildAssetBundleOptions.ChunkBasedCompression | UnityEditor.BuildAssetBundleOptions.DisableWriteTypeTree | BuildAssetBundleOptions.None;</span><br><span class="line"></span><br><span class="line">        BuildPipeline.BuildAssetBundles(saveDir, buildMap, options, BuildTarget.WeixinMiniGame);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.加载bundle</p><p>加载代码如下，中甲遇到的坑都注释上了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class BundleLoader : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public GameObject UIRoot;</span><br><span class="line">    public TextMeshProUGUI TextMeshPro;</span><br><span class="line"></span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void <span class="function"><span class="title">Start</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        TextMeshPro.text = <span class="string">&quot;bundle开始加载&quot;</span>;</span><br><span class="line"></span><br><span class="line">        StartCoroutine(GetAssetBundle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator <span class="function"><span class="title">GetAssetBundle</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        // TextMeshPro.text = <span class="string">&quot;bundle加载中&quot;</span>;</span><br><span class="line">        // AssetBundle ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/prefabimage_4e539e965d7dbddf7c882ccf00899425&quot;</span>);</span><br><span class="line">        // AssetBundleRequest request = ab.LoadAssetAsync&lt;GameObject&gt;(Application.streamingAssetsPath + <span class="string">&quot;prefabimage&quot;</span>);</span><br><span class="line">        // yield <span class="built_in">return</span> request;</span><br><span class="line">        // TextMeshPro.text = <span class="string">&quot;bundle加载完毕&quot;</span>;</span><br><span class="line"></span><br><span class="line">        TextMeshPro.text = <span class="string">&quot;bundle加载中&quot;</span>;</span><br><span class="line">        UnityWebRequest www = UnityWebRequestAssetBundle.GetAssetBundle(<span class="string">&quot;http://localhost/prefabimage_4e539e965d7dbddf7c882ccf00899425&quot;</span>);</span><br><span class="line">        //不是小游戏的话得通过streamassets路径加载，要不然会could not be loaded <span class="keyword">in</span> the Editor because it was built without <span class="built_in">type</span> trees</span><br><span class="line">        //好像是他给出的优化打包方案DisableWriteTypeTree导致的</span><br><span class="line">        //DownloadHandlerAssetBundle handler = new DownloadHandlerAssetBundle(www.url, uint.MaxValue);  //这里会报Error <span class="keyword">while</span> downloading Asset Bundle: CRC Mismatc</span><br><span class="line">        //www.downloadHandler = handler;</span><br><span class="line">        yield <span class="built_in">return</span> www.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (www.result != UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(www.error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            // Extracts AssetBundle</span><br><span class="line">            AssetBundle assetBundle = (www.downloadHandler as DownloadHandlerAssetBundle).assetBundle;</span><br><span class="line"></span><br><span class="line">            AssetBundleRequest request = assetBundle.LoadAssetAsync&lt;GameObject&gt;(<span class="string">&quot;Assets/Prefab/PrefabImage.prefab&quot;</span>);</span><br><span class="line">            yield <span class="built_in">return</span> request;</span><br><span class="line">            GameObject.Instantiate(request.asset, UIRoot.transform);</span><br><span class="line"></span><br><span class="line">            TextMeshPro.text = <span class="string">&quot;bundle加载完毕&quot;</span>;</span><br><span class="line"></span><br><span class="line">            assetBundle.Unload(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        www.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol><li>由于打出的ab包是带hash后缀的，所以业务逻辑加载的时候怎么拼接路径</li></ol><p>首先获取manifest文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(Application.streamingAssetsPath+<span class="string">&quot;/StreamingAssets&quot;</span>);</span><br><span class="line">yield <span class="built_in">return</span> assetBundleCreateRequest;</span><br><span class="line">        </span><br><span class="line">AssetBundleManifest mBundleManifest = (AssetBundleManifest)assetBundleCreateRequest.assetBundle.LoadAsset(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以先通过mBundleManifest.GetAllAssetBundles()获取所有的bundle列表，然后再通过mBundleManifest.GetAssetBundleHash(bundlename)来获取到对应bundle的hash，但是这样就要再初始化的时候新建一个列表来保存bundle和hash之间的关系，然而这样又会有很多字符串的分割操作在里面，显得很不效率。能想到比较合理的方法是打包的时候就解manifest，然后取出对应的hash做记录，进入游戏的时候加载hash解释文件。</p><ol start="2"><li>目前这个demo没有触发小游戏的缓存逻辑，等文档通读之后还得继续走流程</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Unity微信小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNITY  3D HUD 的优化以及原理</title>
      <link href="/2024/10/13/UNITY%203D%20HUD%20%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2024/10/13/UNITY%203D%20HUD%20%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="UNITY-3D-HUD-的优化以及原理"><a href="#UNITY-3D-HUD-的优化以及原理" class="headerlink" title="UNITY  3D HUD 的优化以及原理"></a>UNITY  3D HUD 的优化以及原理</h1><h3 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h3><p>&emsp;&emsp;前一阵面试的时候被面试官问道3D HUD 的实现原理，将2D,3D实现原理自信的阐述了一番，以为万事大吉！不料面试官提问：如果3DHUD在角色旋转的时候变糊这是为什么？  说实话应为没有实操过，并没有遇到这个问题，一顿已读乱回，接下来就看看到底是为什么。</p><p>&emsp;&emsp;B站搜索发现猛男demo传送门  <a href="https://www.bilibili.com/video/BV1cS4y1M7JL/?spm_id_from=333.880.my_history.page.click&vd_source=757af868ca167689ee49a2bde553ef7f">https://www.bilibili.com/video/BV1cS4y1M7JL/?spm_id_from=333.880.my_history.page.click&amp;vd_source=757af868ca167689ee49a2bde553ef7f</a></p><p>&emsp;&emsp;其实很简单，主要的核心就是这几行代码,原来一直以为hud做look摄像机就可以了，其实是不对的，如果使用lookat那么在有些角度hud会又倾斜还是会给人一种3D感，将rotation设置与camera一样则可以完美的解决这一个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// slider.direction = Slider.Direction.RightToLeft;</span><br><span class="line">// slider.transform.LookAt(Camera.main.transform.position);</span><br><span class="line"></span><br><span class="line">slider.direction = Slider.Direction.LeftToRight;</span><br><span class="line">slider.transform.rotation = Camera.main.transform.rotation;</span><br></pre></td></tr></table></figure><p>unity层级结构如下<br><img src="/img/20241013224055.png" alt="unity层级结构如下"></p><p>&emsp;&emsp;项目运行一段时间之后发现，的确图片会出现变糊的现象，经过排查，判断应该是cube旋转之后影响到了hud的rotation，然后hud由于mono脚本也在不停的改变其rotation，如果有一针cube旋转的执行时序慢于mono脚本。那么就会出现抖动的情况，我估计面试官想表达的就是这个。累了，但愿天堂没有面试。</p><p><a href="https://gitee.com/WondrousWisdomcard/unity3d-homework/tree/master/Homework06">测试项目地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> unity优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
